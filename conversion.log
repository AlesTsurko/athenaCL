Available transformations for the -f/--fix option:
apply
asserts
basestring
buffer
dict
except
exec
execfile
exitfunc
filter
funcattrs
future
getcwdu
has_key
idioms
import
imports
imports2
input
intern
isinstance
itertools
itertools_imports
long
map
metaclass
methodattrs
ne
next
nonzero
numliterals
operator
paren
print
raise
raw_input
reduce
renames
repr
set_literal
standarderror
sys_exc
throw
tuple_params
types
unicode
urllib
ws_comma
xrange
xreadlines
zip
--- ./setup.py	(original)
+++ ./setup.py	(refactored)
@@ -141,7 +141,7 @@
         binPath = osTools.findBinPath()
         flagStr = '-p' # create intermediate dirs as required
         dstPath = os.path.join(binPath, name)
-        print _MOD, 'installing launcher script:\n%s' % dstPath
+        print(_MOD, 'installing launcher script:\n%s' % dstPath)
         if not os.path.exists(binPath): # create directory
             if optInstallTool == 1: # use sudo
                 osTools.mkdirSudo(binPath, sudoFound, flagStr)
--- ./athenaCL/athenacl.py	(original)
+++ ./athenaCL/athenacl.py	(refactored)
@@ -12,9 +12,9 @@
 
 #-----------------------------------------------------------------||||||||||||--
 try: 
-    import libATH #assume we are in package dir
+    from . import libATH #assume we are in package dir
 except ImportError:
-    try: from athenaCL import libATH # if sys.path setup right
+    try: from .athenaCL import libATH # if sys.path setup right
     except ImportError: 
         sys.stdout.write('athenaCL package cannot be found.\n')
         sys.exit()
@@ -26,13 +26,13 @@
 if fpPackageDir not in sys.path: sys.path.append(fpPackageDir)
 
 #-----------------------------------------------------------------||||||||||||--
-from athenaCL.libATH import dialog
-from athenaCL.libATH import argTools
-from athenaCL.libATH import language
+from .athenaCL.libATH import dialog
+from .athenaCL.libATH import argTools
+from .athenaCL.libATH import language
 lang = language.LangObj()
-from athenaCL.libATH import drawer
-from athenaCL.libATH import osTools
-from athenaCL.libATH import athenaObj
+from .athenaCL.libATH import drawer
+from .athenaCL.libATH import osTools
+from .athenaCL.libATH import athenaObj
 
 _MOD = 'athenacl.py'
 # check if in idle; this file may call this file again (under idle) and thus
@@ -54,7 +54,7 @@
     msg.append('%s\n' % lang.msgLicenseShort)
     msg.append('%s\n\n%s\n\n' % (lang.msgAthDescLong, lang.msgAthUsage))
     msg.append('Options:\n')
-    for key in flagsRef.keys():
+    for key in list(flagsRef.keys()):
         flagStr = ''
         for entry in key:
             flagStr = flagStr + '%s, ' % entry
--- ./athenaCL/libATH/argTools.py	(original)
+++ ./athenaCL/libATH/argTools.py	(refactored)
@@ -49,9 +49,9 @@
 
     """
     # flags me be ref dict with doc vaules; check type
-    if isinstance(flags, types.DictionaryType):
+    if isinstance(flags, dict):
         flagTemp = []
-        for entry in flags.keys():
+        for entry in list(flags.keys()):
             flagTemp = flagTemp + list(entry) #str, tuple convert to list
         flags = flagTemp
     #for flag in flags:
@@ -94,7 +94,7 @@
                         extraData.append(argv[i+1])
                         i = i + 1
                 else: # already have some data w/ this flag, assume that is all
-                    print 'spaceLimit, no data to add', flagSymbol
+                    print('spaceLimit, no data to add', flagSymbol)
                     pass
 
             flagValue = ' '.join(extraData) # put space between args
--- ./athenaCL/libATH/athenaObj.py	(original)
+++ ./athenaCL/libATH/athenaObj.py	(refactored)
@@ -12,7 +12,7 @@
 # License:       GPL
 #-----------------------------------------------------------------||||||||||||--
 
-import sys, os, time, random, traceback, httplib, urllib
+import sys, os, time, random, traceback, http.client, urllib.request, urllib.parse, urllib.error
 import unittest, doctest
 
 athVersion = '2.0.0a15'
@@ -29,7 +29,7 @@
 # imports if necssary
 #-----------------------------------------------------------------||||||||||||--
 try: 
-    import libTM #assume we are in libATH
+    from . import libTM #assume we are in libATH
 except ImportError:
     try: from athenaCL.libATH import libTM
     except ImportError: 
@@ -202,7 +202,7 @@
             bundle[i].append(line)
         # convert to value pairs
         param = {}
-        for group in bundle.keys(): # order here does not matter
+        for group in list(bundle.keys()): # order here does not matter
             i = 0 # first will be zero
             for field in bundle[group]: # order here matters
                 key = '%s%s%s' % (group, charSep, i)
@@ -224,11 +224,11 @@
         """attempt to submit a log file"""
         paramRaw = self._logParse()
         paramRaw['stateNext'] = '8' # state 8 is bug processing
-        params = urllib.urlencode(paramRaw)
+        params = urllib.parse.urlencode(paramRaw)
         headers = {"Content-type": "application/x-www-form-urlencoded", 
                       "Accept": "text/plain"}
         try:
-            conn = httplib.HTTPConnection(lang.msgCgiDomain)
+            conn = http.client.HTTPConnection(lang.msgCgiDomain)
             conn.request("POST", lang.msgCgiURL, params, headers)
             connect = 1
         except: # no connection active
@@ -237,12 +237,12 @@
             try:
                 response = conn.getresponse()
             except: # some other failure is possible here
-                print 'unknown connection error.'
+                print('unknown connection error.')
                 return None
             if response.status == 200: # good
                 data = response.read()
                 dataLines = data.split('\n')
-                print dataLines[0]
+                print(dataLines[0])
                 self._logDelete() # delete old log
             else:
                 environment.printWarn(['http error:', response.status])
@@ -256,9 +256,9 @@
         """if online, check current version
         returns None if not available"""
         try: # read number of chars lines 1.1.1.1000.10.10
-            webpage = urllib.urlopen(drawer.urlPrep(
+            webpage = urllib.request.urlopen(drawer.urlPrep(
                 lang.msgVersionURL)).read(24)
-        except IOError, e: # cant get online
+        except IOError as e: # cant get online
             webpage = None
         except: # all others
             webpage = None        
@@ -539,9 +539,9 @@
         >>> a.prefixCmdGroup('teCmd')
         (['TEv', 'TEe', 'TEmap', 'TEmidi'], ['view', 'edit', 'map', 'midi'])
         """
-        if prefix not in self.cmdDict.keys():
+        if prefix not in list(self.cmdDict.keys()):
             prefix = prefix.lower() + 'Cmd'
-        if prefix in self.cmdDict.keys():
+        if prefix in list(self.cmdDict.keys()):
             cmdNameList = self.cmdDict[prefix]
             cmdList = []
             nameList = []
@@ -1194,7 +1194,7 @@
 #         1
 
         errorMode = 'exception' # default
-        if 'errorMode' in keywords.keys():
+        if 'errorMode' in list(keywords.keys()):
             errorMode = keywords['errorMode']  
         # separate the command string from the args, which may be a list
         # or a string          
@@ -1312,7 +1312,7 @@
 
     def _emptyline(self):
         """print result if an empty command has been found"""
-        if self._emptyCount >= random.choice(range(7,20)):
+        if self._emptyCount >= random.choice(list(range(7,20))):
             self._emptyCount = 0
             self.out(dialog.getEncouragement())
         self._emptyCount = self._emptyCount + 1 
@@ -1320,7 +1320,7 @@
 
     def _default(self, line):
         """if no command is parsed out of line"""
-        if self._blankCount >= random.choice(range(3,10)):
+        if self._blankCount >= random.choice(list(range(3,10))):
             self._blankCount = 0
             self.out(dialog.getAdmonishment(line))
         else:
@@ -1502,8 +1502,8 @@
         from athenaCL.libATH.libTM import texture
         
         cmdListE = []
-        for i in range(len(texture.tmNames.values())):
-            tmName = texture.tmNames.values()[i]
+        for i in range(len(list(texture.tmNames.values()))):
+            tmName = list(texture.tmNames.values())[i]
 
             if tmName == 'TimeSegment':
                 # TODO: time segment raise an error with
--- ./athenaCL/libATH/audioTools.py	(original)
+++ ./athenaCL/libATH/audioTools.py	(refactored)
@@ -372,7 +372,7 @@
         #totalLen = obj.getnframes()
         totalLen = frames
         if totalLen < (fadeLen * 2):
-            raise ValueError, 'fades are too long'
+            raise ValueError('fades are too long')
         flatLen = totalLen - (fadeLen * 2)
 
         rampIn  = self._ramp(fadeLen, 'in')
@@ -573,7 +573,7 @@
         file exists, channel will be updated to appropriate value
         """
         if not AIF: # check if modules loaded
-            raise ImportError, 'aif modules not available (%s)' % os.name
+            raise ImportError('aif modules not available (%s)' % os.name)
         self.absPath = absPath
         # store an envelope generator for convenience
         self.envlGenObj = EnvelopeGenerator()
@@ -596,7 +596,7 @@
         """
         if self._FILEOPEN == 1: # file is already open:
             self.aObj.close()
-            raise IOError, 'attempt to open open file.'
+            raise IOError('attempt to open open file.')
         if mode == None: # determine by wether file exists or not
             if os.path.exists(self.absPath): mode = 'r'
             else: mode = 'w'
@@ -617,7 +617,7 @@
         
     def _close(self):
         if self._FILEOPEN == 0: # file is already closed
-            raise IOError, 'attempt to close a closed file.'
+            raise IOError('attempt to close a closed file.')
         self._update()
         #print 'closing file: frames %s, channels %s' % (
         #                            self.frames, self.ch)
@@ -703,7 +703,7 @@
             self.aObj.writeframesraw(newData)
             self._close()
         else:
-            raise ValueError, 'incompatible channel conversioin'
+            raise ValueError('incompatible channel conversioin')
             
     def fillNoise(self):
         """pos is start position w/n file"""
@@ -763,7 +763,7 @@
         """insert some noise at a given amp into the file at position
         specified in frames. dur specified in frames
         not: dur applied to stereo channel does seem to last for the proper dur"""
-        if frames + pos > self.frames: raise ValueError, 'bad position size'
+        if frames + pos > self.frames: raise ValueError('bad position size')
         noiseData = self.sampleGenObj.noise(frames, amp)
         srcLead = self.getData(0, pos-1) # get data before noise
         srcPost = self.getData(pos+frames, self.getSize()-(pos+frames))
@@ -866,7 +866,7 @@
         self._open('r') # open to read data
         if start + length > self.frames:
             self._close()
-            raise ValueError, 'bad start and frame length'
+            raise ValueError('bad start and frame length')
         self.aObj.setpos(start)
         data = self.aObj.readframes(length)
         self._close()
@@ -888,7 +888,7 @@
         audio to keep"""
         data = self.getData(pos, frames)
         if len(data) == 0:
-            print 'no data: %s: %s, %s' % (self.frames, pos, frames) 
+            print('no data: %s: %s, %s' % (self.frames, pos, frames)) 
             result = 0 # no data to get
         absMax = byteToInt(self.bytes)
         max = audioop.max(data, self.bytes)
@@ -897,8 +897,8 @@
             result = 1
         else:
             rmsPct = round((rms / float(absMax)), 3)
-            print _MOD, 'lowamp: rms %s max %s (rmsPct %.3f)' % (str(rms).ljust(5), 
-                                                     str(max).ljust(5), rmsPct)
+            print(_MOD, 'lowamp: rms %s max %s (rmsPct %.3f)' % (str(rms).ljust(5), 
+                                                     str(max).ljust(5), rmsPct))
             result = 0
         return result
         
@@ -909,10 +909,10 @@
         frames = self.getSize()
         rangeMax = frames - length
         if rangeMax <= 0: 
-            print _MOD, 'findShard: self.frames, length %s %s' % (
-                                                        self.frames, length)
+            print(_MOD, 'findShard: self.frames, length %s %s' % (
+                                                        self.frames, length))
             return None # skip
-        frameRange = range(0, rangeMax)
+        frameRange = list(range(0, rangeMax))
         for i in range(0, maxAttempt):
             trialStart = random.choice(frameRange)
             if self.testAmp(trialStart, length): # if passes
@@ -949,7 +949,7 @@
         obj = fileTools.AllFiles(self.srcDir, ['aif', 'aiff'])
         self.srcFiles = obj.report()
         # make a list indices to get src files from; will randomize
-        self.srcKeys = range(0, len(self.srcFiles))
+        self.srcKeys = list(range(0, len(self.srcFiles)))
         self.dstFiles = []
 
     def _fileNameStr(self, i):
@@ -972,7 +972,7 @@
         
         for i in range(indexStart, (fragments+indexStart)):
             if i % 10 == 0: # report every ten
-                print _MOD, 'current index: %s' % i
+                print(_MOD, 'current index: %s' % i)
 
             srcPath = self.srcFiles[self.srcKeys[(srcIndex % srcLen)]]
             srcIndex = srcIndex + 1
@@ -980,7 +980,7 @@
             aObj = AudioFile(srcPath)
             start = aObj.findShard(self.audioFrame)
             if start == None:
-                print 'no audio found in %s' % srcPath
+                print('no audio found in %s' % srcPath)
                 continue
 
             dstPath = os.path.join(self.dstDir, self._fileNameStr(i))
@@ -1009,7 +1009,7 @@
     def run(self):
         srcObj = AudioFile(self.src)
         frames = srcObj.getSize()
-        print _MOD, 'length', frames
+        print(_MOD, 'length', frames)
         #refObj = srcObj.extract(self.ref, 0, frames) # store a version 
         #storageObj = srcObj.extract(self.storage, 0, frames)
         #print _MOD, 'duration', storageObj.getDur()
@@ -1056,7 +1056,7 @@
         spotWidth is the segment widht (in sec) in which a wm may occur
         spotDur in seconds"""
         
-        if not os.path.exists(src): raise ValueError, 'no such file'        
+        if not os.path.exists(src): raise ValueError('no such file')        
         af = AudioFile(src)
         
         dur = af.getDur() # dur is in seconds
@@ -1077,13 +1077,13 @@
             min = int(round((.1*spotWidth)))
             max = int(round((.3*spotWidth)))
             
-            secIn = random.choice(range(min, max))
+            secIn = random.choice(list(range(min, max)))
             secOut = spotWidth-secIn
             shift = fps * secIn
             pos = pos + shift
             
             af.insertNoise(pos, spotFrames, spotAmp)
-            print _MOD, af.absPath, '(%s)' % frameToSec(pos)
+            print(_MOD, af.absPath, '(%s)' % frameToSec(pos))
             # shift to end of second
             pos = pos + (fps * secOut)
             
@@ -1139,7 +1139,7 @@
 
 
     # reccomended numbers between 300 and 500 (more for shorter)
-    print a.gather(300, indexStart)
+    print(a.gather(300, indexStart))
 
 
 
--- ./athenaCL/libATH/automata.py	(original)
+++ ./athenaCL/libATH/automata.py	(refactored)
@@ -263,7 +263,7 @@
 
         if key == 'yTotal': # y with skip, for actual generations
             return self.src['y'] + self.src['s']
-        elif key in self.src.keys():
+        elif key in list(self.src.keys()):
             return self.src[key]
         else: raise AttributeError
 
@@ -292,7 +292,7 @@
         """this model is borrowed from markov.py; could be abstracted to
         a common utility"""
         if usrStr.count(self.OPEN) != usrStr.count(self.CLOSE):
-            raise error.AutomataSpecificationError, "all braces not paired"     
+            raise error.AutomataSpecificationError("all braces not paired")     
         post = {}
         groups = usrStr.split(self.CLOSE)
         for double in groups:
@@ -321,8 +321,8 @@
                 }
         
         # src keys have already been formated to single character refs
-        for key in ref.keys():
-            if key not in src.keys():
+        for key in list(ref.keys()):
+            if key not in list(src.keys()):
                 src[key] = ref[key][0]
             else: # keu exists, eval numbers if necessary
                 if drawer.isNum(ref[key][0]): # check numbers                           
@@ -410,7 +410,7 @@
     # totalistic rule count: k = k, len(dstValues)
     if drawer.isNum(dstValues):
         k = dstValues
-        dstValues = range(dstValues)
+        dstValues = list(range(dstValues))
     else: # assume its a list
         k = len(dstValues)
     if srcValues == None: # not totalistic
@@ -476,7 +476,7 @@
         self.size = size # number of cells in one step       
         # may need to prase these values
         self.init = caInitParser(init)
-        if self.init == None: raise ValueError, 'bad init value'
+        if self.init == None: raise ValueError('bad init value')
         if dstValues != None: # can be none for continuous ca
             dstValues.sort()
         self.dstValues = dstValues
@@ -748,7 +748,7 @@
         if end == None:
             end = len(self.stepHistory)         
         for step in range(start, end):
-            print self._fmtStep(self.stepHistory[step])
+            print(self._fmtStep(self.stepHistory[step]))
             #time.sleep(.001)
         
     def getCells(self, fmt='table', norm=1, stepStart=None, stepEnd=None, 
@@ -833,7 +833,7 @@
         size = self.spec.get('x')
         init = self.spec.get('i')
         
-        dstValues = range(k) #[0,1]
+        dstValues = list(range(k)) #[0,1]
         srcSpan = self._rToSrcSpan(r) 
         srcValues = None # same as dst, based on srcSpan
         self.ruleMax = ruleCount(srcSpan, dstValues) # 256 
@@ -866,15 +866,15 @@
         size = self.spec.get('x')
         init = self.spec.get('i')
 
-        if k <= 1: raise ValueError, 'bad k value'
-        if r < 1: raise ValueError, 'bad r value'
-        
-        dstValues = range(k) # if k ==2, k= [0,1]
+        if k <= 1: raise ValueError('bad k value')
+        if r < 1: raise ValueError('bad r value')
+        
+        dstValues = list(range(k)) # if k ==2, k= [0,1]
         srcSpan = self._rToSrcSpan(r) 
         # max of dstValues * srcSpan is max
         # [0,1,2,3] # all sums of two states---
         # also (3*k)-2
-        srcValues = range((dstValues[-1]*srcSpan)+1)     # srcNot e same as dst
+        srcValues = list(range((dstValues[-1]*srcSpan)+1))     # srcNot e same as dst
         
         self.ruleMax = ruleCount(srcSpan,dstValues,srcValues)
         rule = self._ruleFilter(rule)
@@ -1006,7 +1006,7 @@
             end = len(self.stepHistory)         
         for step in range(start, end):
             for row in self.stepHistory[step]:
-                print self._fmtStep(row)
+                print(self._fmtStep(row))
 
 
 #-----------------------------------------------------------------||||||||||||--
@@ -1049,9 +1049,9 @@
                 a.gen(100)
                 #timerTotal.stop()
                 timer.stop()
-                print a
-                print timer('sw')
-            print 'total time', timerTotal('sw')
+                print(a)
+                print(timer('sw'))
+            print('total time', timerTotal('sw'))
 
 
     def testOneDimensionDisplay(self):       
@@ -1078,10 +1078,10 @@
                     a.display()
                     for norm in range(0,2):
                         for out in a.outFmt:
-                            print _MOD, out, norm
-                            print a.getCells(out, norm)
-                    print a
-            print 'total time', timerTotal('sw')
+                            print(_MOD, out, norm)
+                            print(a.getCells(out, norm))
+                    print(a)
+            print('total time', timerTotal('sw'))
 
 
 
--- ./athenaCL/libATH/clone.py	(original)
+++ ./athenaCL/libATH/clone.py	(refactored)
@@ -167,7 +167,7 @@
         if usrStr not in self.cloneLabels:
             # try to match by parameter obj name
             usrStr = drawer.strScrub(usrStr, 'lower')
-            for key in parameter.clonePmtrNames.keys(): # keys are short
+            for key in list(parameter.clonePmtrNames.keys()): # keys are short
                 if usrStr == key: # get long name
                     usrStr = parameter.clonePmtrNames[key]
                     break
@@ -179,7 +179,7 @@
                     found = 1
                     break
             if not found:
-                raise ValueError, 'bad label name for clone pmtr data: %s' % usrStr
+                raise ValueError('bad label name for clone pmtr data: %s' % usrStr)
         return usrStr
 
 
@@ -385,12 +385,12 @@
         oldPmtrDict = copy.deepcopy(self.pmtrQDict)
         
         #print _MOD, 'clone: oldAuxNo, self.AuxNo', oldAuxNo, self.auxNo
-        print lang.WARN, 'new Clone auxiliary value %s' % self.auxNo
+        print(lang.WARN, 'new Clone auxiliary value %s' % self.auxNo)
 
         # remove old aux values 
         for auxLabel in basePmtr.auxLabel(oldAuxNo):
             del self.pmtrQDict[auxLabel]
-            if auxLabel in self.pmtrObjDict.keys(): # remove objects if they exist
+            if auxLabel in list(self.pmtrObjDict.keys()): # remove objects if they exist
                 del self.pmtrObjDict[auxLabel]
         
         # insert new values from defaults
@@ -401,7 +401,7 @@
         """this only supplies names, which wil load defaults"""
         for i, cloneLabel in basePmtr.cloneLabel(self.clonePmtrNo, 1):
             # add arg list default if missing to pmtrQdict
-            if not cloneLabel in self.pmtrQDict.keys():
+            if not cloneLabel in list(self.pmtrQDict.keys()):
                 args = [self.clonePmtrNames[i],]
                 dummyObj = parameter.factory(args, 'clonePmtrObjs', self.refDict)
                 self.pmtrQDict[cloneLabel] = dummyObj.getArgs()
@@ -415,14 +415,14 @@
             try:
                 self.pmtrObjDict[pmtrName] = parameter.factory(args, 
                                                   'clonePmtrObjs', refDict)
-            except error.ParameterObjectSyntaxError, msg: 
+            except error.ParameterObjectSyntaxError as msg: 
                 # initialization errors
                 return 0, 'incorrect arguments: %s' % msg
         else:
             try:
                 self.pmtrObjDict[pmtrName] = parameter.factory(args,
                                            'filterPmtrObjs', refDict)
-            except error.ParameterObjectSyntaxError, msg: 
+            except error.ParameterObjectSyntaxError as msg: 
                 # initialization errors
                 return 0, 'incorrect arguments: %s' % msg
         # check for errors
@@ -454,7 +454,7 @@
         if pmtrName != '':
             ok, msg = self._evalPmtrObj(pmtrName, refDict)
         else: # reinit all paramters, no name given
-            for pmtrName in self.pmtrQDict.keys():
+            for pmtrName in list(self.pmtrQDict.keys()):
                 ok, msg = self._evalPmtrObj(pmtrName, refDict)
                 if ok != 1: break # stop processing on error
         # post update actions:
@@ -464,7 +464,7 @@
         setattr(self, attrName, data)
         ok, msg = self.updatePmtrObj(pmtrName, refDict)
         # this should never fail
-        if not ok: raise ValueError, 'clone edit: original data cannot be restored: %s' % msg
+        if not ok: raise ValueError('clone edit: original data cannot be restored: %s' % msg)
         
     def editPmtrObj(self, pmtrName, pmtrValue, refDict, esObj=None, refresh=1):
         """refresh: turn off score generation
@@ -504,19 +504,19 @@
                 if not ok:
                     self._editRestore(attrName, p, oldData, refDict)
                     return ok, 'score creation returned an error.'
-        except error.ParameterObjectSyntaxError, msg: # standard init errors from pmtr obj
+        except error.ParameterObjectSyntaxError as msg: # standard init errors from pmtr obj
             msg = '%s %s' % (editPhase, msg)
             ok = 0
-        except IndexError, msg:
+        except IndexError as msg:
             msg = '%s incorrect number of arguments. %s.' % (editPhase, msg)
             ok = 0
-        except TypeError, msg:
+        except TypeError as msg:
             msg = '%s incorrect data-type in arguments. %s' % (editPhase, msg)
             ok = 0 
-        except UnboundLocalError, msg:
+        except UnboundLocalError as msg:
             msg = '%s incorrect paramater type in arguments. %s' % (editPhase, msg)
             ok = 0
-        except ValueError, msg:
+        except ValueError as msg:
             msg = '%s value error: an inappropriate data type used.' % editPhase
             ok = 0
         except ZeroDivisionError:
@@ -646,7 +646,7 @@
         if len(self.esObj) == 0:
             raise Exception('no events in EventSequence object')
 
-        for pmtrName in self.pmtrQDict.keys():
+        for pmtrName in list(self.pmtrQDict.keys()):
             if pmtrName[:6] != 'cloneQ': # check texture options
                 # reset all necessary variables before scoring
                 self.pmtrObjDict[pmtrName].reset() 
@@ -764,13 +764,13 @@
 
     def tNames(self):
         """return names of textures that have keys"""
-        return self._tRef.keys()
+        return list(self._tRef.keys())
     
     def cNames(self, tName):
         """return the names of the clone for a named textuire
         if texture does not have clones, returns None"""
         if tName not in self.tNames(): return []
-        names = self._tRef[tName].keys()
+        names = list(self._tRef[tName].keys())
         names.sort()
         return names
 
@@ -802,20 +802,20 @@
     #-----------------------------------------------------------------------||--
     def load(self, tName, cName, pmtrQDict, auxNo, auxFmt, mute=0):
         """initialize a clone object inside the appropriate texture label"""
-        if not tName in self._tRef.keys():
+        if not tName in list(self._tRef.keys()):
             self._tRef[tName] = {}
-        if cName in self._tRef[tName].keys():
-            raise error.CloneError, 'clone name already exists'
+        if cName in list(self._tRef[tName].keys()):
+            raise error.CloneError('clone name already exists')
         self._tRef[tName][cName] = Clone(cName, tName)
         self._tRef[tName][cName].load(pmtrQDict, auxNo, auxFmt, mute)
         self._tRefCurrent[tName] = cName
 
     def loadDefault(self, tName, cName, auxNo, auxFmt):
         """initialize a clone object inside the appropriate texture label"""
-        if not tName in self._tRef.keys():
+        if not tName in list(self._tRef.keys()):
             self._tRef[tName] = {}
-        if cName in self._tRef[tName].keys():
-            raise error.CloneError, 'clone name already exists'
+        if cName in list(self._tRef[tName].keys()):
+            raise error.CloneError('clone name already exists')
         self._tRef[tName][cName] = Clone(cName, tName)
         self._tRef[tName][cName].loadDefault(auxNo, auxFmt)
         self._tRefCurrent[tName] = cName
@@ -839,13 +839,13 @@
 
     def delete(self, tName, cName=None):
         if cName == None: # delete all of a texture's clones
-            if tName in self._tRef.keys():
+            if tName in list(self._tRef.keys()):
                 del self._tRef[tName]
                 del self._tRefCurrent[tName]
             else: # this should not happen
                 environLocal.printDebug['attempting to remove clone from texture %s not stored in tRef' % tName]
         else:
-            if tName in self._tRef.keys():
+            if tName in list(self._tRef.keys()):
                 del self._tRef[tName][cName]
             else: # this should not happen
                 environLocal.printDebug['attempting to remove clone from texture %s not stored in tRef' % tName]
@@ -856,7 +856,7 @@
     def tMove(self, tOld, tNew):
         """change the name of a texture"""
         if tNew in self.tNames():
-            raise error.CloneError, 'texture name already exists'         
+            raise error.CloneError('texture name already exists')         
         self._tRef[tNew] = self._tRef[tOld]
         del self._tRef[tOld]
         self._tRefCurrent[tNew] = self._tRefCurrent[tOld]
@@ -865,7 +865,7 @@
     def cMove(self, tName, cOld, cNew):
         """change the name of a clone"""
         if cNew in self.cNames(tName):
-            raise error.CloneError, 'clone name already exists'
+            raise error.CloneError('clone name already exists')
         self._tRef[tName][cNew] = self._tRef[tName][cOld]
         del self._tRef[tName][cOld]
         if self._tRefCurrent[tName] == cOld: # selected
@@ -874,7 +874,7 @@
     def cCopy(self, tName, cOld, cNew):
         """copy a clone within the same texture"""
         if cNew in self.cNames(tName):
-            raise error.CloneError, 'clone name already exists'
+            raise error.CloneError('clone name already exists')
         self._tRef[tName][cNew] = self._tRef[tName][cOld].copy(cNew, tName)
         if self._tRefCurrent[tName] == cOld: # selected
             self._tRefCurrent[tName] = cNew
@@ -886,7 +886,7 @@
         have clones
         """
         if tNew in self.tNames():
-            raise error.CloneError, 'bad source or destination texture naming'
+            raise error.CloneError('bad source or destination texture naming')
         if tOld not in self.tNames(): # cant do anything with this; no clones
             return None
         self._tRef[tNew] = {}
--- ./athenaCL/libATH/command.py	(original)
+++ ./athenaCL/libATH/command.py	(refactored)
@@ -200,7 +200,7 @@
 
     def _getNoTI(self):
         """returns number of textures"""
-        return len(self.ao.textureLib.keys())
+        return len(list(self.ao.textureLib.keys()))
 
     def _getNoPI(self):
         """returns number of paths"""
@@ -252,13 +252,13 @@
             usrStr = drawer.restringulator(usrStr) # add quotes if necessary
             try:
                 usrDataEval = eval(usrStr)
-            except TypeError, e: 
+            except TypeError as e: 
                 msg = '%s %s' % (errorPreface, e) #'type-error')
                 usrDataEval = None
-            except SyntaxError, e: 
+            except SyntaxError as e: 
                 msg = '%s %s' % (errorPreface, e) #'syntax-error')
                 usrDataEval = None
-            except NameError, e: # if strings given without a quote not converted
+            except NameError as e: # if strings given without a quote not converted
                 msg = '%s %s' % (errorPreface, 'name-error (quote all strings)')
                 usrDataEval = None
 
@@ -632,16 +632,16 @@
             return None
         # check that number is in proper range
         if fmt == basePmtr.AUXQ:
-            if no not in range(0, self.ao.textureLib[tName].auxNo):
+            if no not in list(range(0, self.ao.textureLib[tName].auxNo)):
                 return None
         elif fmt == basePmtr.TEXTQ:
-            if no not in range(0, self.ao.textureLib[tName].textPmtrNo):
+            if no not in list(range(0, self.ao.textureLib[tName].textPmtrNo)):
                 return None
         elif fmt == basePmtr.DYNQ:
-            if no not in range(0, self.ao.textureLib[tName].dynPmtrNo):
+            if no not in list(range(0, self.ao.textureLib[tName].dynPmtrNo)):
                 return None
         elif fmt == basePmtr.CLONEQ:
-            if no not in range(0, self.ao.cloneLib.clonePmtrNo()):
+            if no not in list(range(0, self.ao.cloneLib.clonePmtrNo())):
                 return None
         label = '%s%s' % (fmt, no)
         return label
@@ -707,7 +707,7 @@
         """checks if a path name exists"""
         if name == None:
             name = self.ao.activePath
-        if self.ao.pathLib.has_key(name) != 1:
+        if (name in self.ao.pathLib) != 1:
             return lang.msgPImissingName
         else:
             return None
@@ -738,7 +738,7 @@
         used for default, when a texture has lost its path
         for eventModes that requre a path
         will not overwrite existing paths with the same name"""
-        if name not in self.ao.pathLib.keys():
+        if name not in list(self.ao.pathLib.keys()):
             self.ao.pathLib[name] = pitchPath.PolyPath(name)
             self.ao.pathLib[name].autoFill(psList)
         self.ao.activePath = name
@@ -760,7 +760,7 @@
             name = self._nameReplace(name)
             if self._nameTest(name) != None:
                 dialog.msgOut(self._nameTest(name), self.termObj)
-            elif self.ao.pathLib.has_key(name):
+            elif name in self.ao.pathLib:
                 dialog.msgOut(lang.msgPInameTaken, self.termObj)
             else:
                 return name
@@ -809,7 +809,7 @@
         this is an improved version used for ELn; this allowes for muted
         textures to exist with active clones"""
         activeCount = 0
-        for tName in self.ao.textureLib.keys():
+        for tName in list(self.ao.textureLib.keys()):
             t = self.ao.textureLib[tName]
             # if active and no clonse
             if not t.mute and tName not in self.ao.cloneLib.tNames():
@@ -835,7 +835,7 @@
     def _tiTestNameExists(self, name=None):
         if name == None:
             name = self.ao.activeTexture
-        if self.ao.textureLib.has_key(name) != 1:
+        if (name in self.ao.textureLib) != 1:
             return lang.msgTImissingName
         else:
             return None
@@ -876,7 +876,7 @@
         t = self.ao.textureLib[tName]
         if p == 'path':
             attribute_to_edit = t.path
-            for pair in self.ao.pathLib.items():
+            for pair in list(self.ao.pathLib.items()):
                 if pair[1] == attribute_to_edit:
                     old_name = pair[0]
             path_string = t.path.repr('scPath')     
@@ -937,7 +937,7 @@
         usrDataEval, msg = self._strRawToData(usrStr, lang.msgTIeditArgError)
         # do parameter specific adjustments
         if p == 'path': # given  a string arg, retrurn the reference to e path
-            if usrDataEval not in self.ao.pathLib.keys():
+            if usrDataEval not in list(self.ao.pathLib.keys()):
                 return None, 'no path named %s.\n' % str(usrDataEval)
             usrDataEval = self.ao.pathLib[usrDataEval] # get reference of path
         elif p == 'tRange': # must be a number
@@ -973,7 +973,7 @@
             try: # this may raise a ValueError
                 pmtrName = self.ao.textureLib[textureName].getTextStaticName(p)
                 evalData = tuple([pmtrName,] + list(usrDataEval))
-            except ValueError, e:
+            except ValueError as e:
                 evalData = None
                 msg = e # store error message
         else:# all other parameters return unmodified
@@ -1045,23 +1045,23 @@
             name = self._nameReplace(name)
             if self._nameTest(name) != None:
                 dialog.msgOut(self._nameTest(name), self.termObj)
-            elif self.ao.textureLib.has_key(name):
+            elif name in self.ao.textureLib:
                 dialog.msgOut(lang.msgTInameTaken, self.termObj)
             else:
                 return name
 
     def _tiRemove(self, name): # args is name of texture 
-        if name in self.ao.textureLib.keys():
+        if name in list(self.ao.textureLib.keys()):
             self.ao.textureLib[name].path.refDecr()
             del self.ao.textureLib[name] # del object
             if name in self.ao.cloneLib.tNames():   # del clone dict,if exists
                 self.ao.cloneLib.delete(name) # deletes all clones w/ this text
             if name == self.ao.activeTexture:
-                if len(self.ao.textureLib.keys()) == 0:
+                if len(list(self.ao.textureLib.keys())) == 0:
                     self.ao.activeTexture = ''
                 else:# gets a random texture to replace
                     self.ao.activeTexture = random.choice(
-                                                     self.ao.textureLib.keys()) 
+                                                     list(self.ao.textureLib.keys())) 
             return 'TI %s destroyed.\n' % name
         else:
             return None # error 
@@ -1080,7 +1080,7 @@
         if usrDataEval == None: 
             return 0, msg
         try: obj = parameter.factory(usrDataEval, 'g')
-        except error.ParameterObjectSyntaxError, e:
+        except error.ParameterObjectSyntaxError as e:
             return 0, e
         return 1, obj
     
@@ -1102,7 +1102,7 @@
     def _teGetTimeMapDict(self):
         tiMapDict = {} #clear
         #muteList = self._tiMuteList()
-        for tName in self.ao.textureLib.keys():
+        for tName in list(self.ao.textureLib.keys()):
             t = self.ao.textureLib[tName]
             tiMapDict[tName] = {} # add a dictionary w/ name for key
             tiMapDict[tName]['tRange'] = t.timeRangeAbs # this is abs time
@@ -1123,11 +1123,11 @@
         if tiMapDict == None: tiMapDict = self._teGetTimeMapDict()
         startTime = 0
         endTime = 0
-        for tName in tiMapDict.keys():
+        for tName in list(tiMapDict.keys()):
             s, e = tiMapDict[tName]['tRange']
             if s <= startTime: startTime = s
             if e >= endTime: endTime = e
-            for cName in tiMapDict[tName]['cloneDict'].keys():
+            for cName in list(tiMapDict[tName]['cloneDict'].keys()):
                 s, e = tiMapDict[tName]['cloneDict'][cName]['tRange']
                 # check for a clone that is longer               
                 if s <= startTime: startTime = s
@@ -1751,7 +1751,7 @@
             label = ('TI References (%s): ' %
                         self.ao.pathLib[nameToView].refCount)
             listOfTInames = []
-            for tName in self.ao.textureLib.keys():
+            for tName in list(self.ao.textureLib.keys()):
                 if (self.ao.textureLib[tName].path.name == 
                      self.ao.pathLib[nameToView].name):
                     listOfTInames.append(tName)
@@ -2046,7 +2046,7 @@
         msg = []
         msg.append('PathInstances available:\n')
         entryLines = []
-        pathNames = self.ao.pathLib.keys()
+        pathNames = list(self.ao.pathLib.keys())
         pathNames.sort()
         for name in pathNames:
             pathStr = self.ao.pathLib[name].repr('scPath')
@@ -2087,8 +2087,8 @@
 
     def _piCopy(self, srcName, dstName):
         """copies one path to new path"""
-        if (srcName != dstName and self.ao.pathLib.has_key(srcName) and 
-                                          dstName not in self.ao.pathLib.keys())== 1:
+        if (srcName != dstName and srcName in self.ao.pathLib and 
+                                          dstName not in list(self.ao.pathLib.keys()))== 1:
             # sets name attribute
             self.ao.pathLib[dstName] = self.ao.pathLib[srcName].copy(dstName)
             self.ao.activePath = dstName
@@ -2106,7 +2106,7 @@
         if args != '':
             args = argTools.ArgOps(args, stripComma=True)
             msg = []
-            self.oldName = drawer.inList(args.get(0), self.ao.pathLib.keys())
+            self.oldName = drawer.inList(args.get(0), list(self.ao.pathLib.keys()))
             if self.oldName == None: return self._getUsage()
             if args.list(1, 'end') != None:
                 for newName in args.list(1, 'end'):
@@ -2115,7 +2115,7 @@
 
         if self.cpList == []:
             self.oldName = self._chooseFromList('select a path to copy:',
-                         self.ao.pathLib.keys(), 'case')
+                         list(self.ao.pathLib.keys()), 'case')
             if self.oldName == None: return lang.msgPIbadName
             query = 'name the copy of path %s:' % self.oldName 
             name = self._piGetNewName(query)
@@ -2160,7 +2160,7 @@
         self.cmdStr = 'PIrm'
 
     def _piRemove(self, name): # args is name of path
-        if name in self.ao.pathLib.keys():
+        if name in list(self.ao.pathLib.keys()):
             # this is 0 when there are no longer any TIs that link to this path
             if self.ao.pathLib[name].refCount != 0:  
                 return ('PI %s is being used by %i Textures. either delete Textures ("TIrm") or change their Path ("TIe").\n' % 
@@ -2169,10 +2169,10 @@
                 self.ao.activePath = ''
             del self.ao.pathLib[name]
             if name == self.ao.activePath:
-                if len(self.ao.pathLib.keys()) == 0:
+                if len(list(self.ao.pathLib.keys())) == 0:
                     self.ao.activePath = ''
                 else:
-                    self.ao.activePath = random.choice(self.ao.pathLib.keys())
+                    self.ao.activePath = random.choice(list(self.ao.pathLib.keys()))
             return 'PI %s destroyed.\n' % name
         else:
             return None # error
@@ -2188,13 +2188,13 @@
             msg = []
             if args.list(0, 'end') != None:
                 for name in args.list(0, 'end'):
-                    name = drawer.inList(name, self.ao.pathLib.keys())
+                    name = drawer.inList(name, list(self.ao.pathLib.keys()))
                     if name == None: return self._getUsage()
                     self.rmList.append(name)
             else: return self._getUsage()
         if self.rmList == []:
             name = self._chooseFromList('select a path to delete:', 
-                     self.ao.pathLib.keys(), 'case')
+                     list(self.ao.pathLib.keys()), 'case')
             if name == None: return lang.msgPIbadName
             query = 'are you sure you want to delete path %s?'
             askUsr = dialog.askYesNoCancel((query % name), 1, self.termObj)
@@ -2251,11 +2251,11 @@
         self.name = None
         if args != '':
             args = argTools.ArgOps(args) # no strip
-            self.name = drawer.inList(args.get(0), self.ao.pathLib.keys())
+            self.name = drawer.inList(args.get(0), list(self.ao.pathLib.keys()))
             if self.name == None: return self._getUsage()
         if self.name == None:
             self.name = self._chooseFromList('select a path to activate:', 
-                              self.ao.pathLib.keys(), 'case')
+                              list(self.ao.pathLib.keys()), 'case')
             if self.name == None: return lang.msgPIbadName
 
     def process(self): 
@@ -2303,7 +2303,7 @@
         pathBinRef[newPathName] = pathBinRef[oldPathName]
         #set at init, must change after copy
         pathBinRef[newPathName].name = newPathName 
-        for key in textureBinRef.keys():        
+        for key in list(textureBinRef.keys()):        
             ### change
             if textureBinRef[key].path.name == oldPathName: # had old name
                 # sets attribute obj, name, value 
@@ -2321,7 +2321,7 @@
 
         if args != '':
             args = argTools.ArgOps(args, stripComma=True)
-            oldPathName = drawer.inList(args.get(0), self.ao.pathLib.keys())
+            oldPathName = drawer.inList(args.get(0), list(self.ao.pathLib.keys()))
             if oldPathName == None: return self._getUsage()
             newPathName = args.get(1)
             if newPathName == None: return self._getUsage()
@@ -2670,7 +2670,7 @@
             if name == self.ao.activeTextureModule: activity = lang.ACTIVE
             else: activity = lang.INACTIVE
             refCount = 0
-            for textName in self.ao.textureLib.keys():
+            for textName in list(self.ao.textureLib.keys()):
                 # see if TIs are using this TM
                 if self.ao.textureLib[textName].tmName == name: 
                     refCount = refCount + 1
@@ -2774,7 +2774,7 @@
             usrStr = outFormat.outputExportFormatParser(usrStr)
             if usrStr == None:
                 msgPre = 'format error: select %s:' % drawer.listToStrGrammar(
-                                outFormat.outputExportFormatNames.values(), 'or')
+                                list(outFormat.outputExportFormatNames.values()), 'or')
                 #dialog.msgOut(msg, self.termObj)
             else: return usrStr
                       
@@ -3025,7 +3025,7 @@
                 break
             try:
                 obj = parameter.factory(usrDataEval, subLib)
-            except error.ParameterObjectSyntaxError, msg:
+            except error.ParameterObjectSyntaxError as msg:
                 return '%s\n' % msg
             ok, msg = obj.checkArgs()
             if not ok:
@@ -3108,7 +3108,7 @@
             self.fmt = outFormat.outputExportFormatParser(args.get(0))
             if self.fmt == None: 
                 opts = drawer.listToStrGrammar(
-                       outFormat.outputExportFormatNames.values())
+                       list(outFormat.outputExportFormatNames.values()))
                 return self._getUsage('no format %s; select %s' % (args.get(0),
                             opts))
 
@@ -3158,7 +3158,7 @@
         for subLib, usrDataEval in self.argBundle:
             try:
                 obj = parameter.factory(usrDataEval, subLib)
-            except error.ParameterObjectSyntaxError, msg:
+            except error.ParameterObjectSyntaxError as msg:
                 return '%s\n' % msg
             ok, msg = obj.checkArgs()
             if not ok:
@@ -3245,7 +3245,7 @@
             args = argTools.ArgOps(args)
             self.name = args.get(0)
             if self.name == None: return self._getUsage()
-            if self.name in self.ao.textureLib.keys():
+            if self.name in list(self.ao.textureLib.keys()):
                 return self._getUsage()
             if self._nameTest(self.name) != None:
                 return self._getUsage(self._nameTest(self.name))
@@ -3337,11 +3337,11 @@
         self.name = None
         if args != '':
             args = argTools.ArgOps(args) # no strip
-            self.name = drawer.inList(args.get(0), self.ao.textureLib.keys())
+            self.name = drawer.inList(args.get(0), list(self.ao.textureLib.keys()))
             if self.name == None: return self._getUsage()
         if self.name == None:
             self.name = self._chooseFromList('which TextureInstnace to make active?', 
-                     self.ao.textureLib.keys(), 'case')
+                     list(self.ao.textureLib.keys()), 'case')
             if self.name == None: return lang.msgTIbadName
 
     def process(self): 
@@ -3378,7 +3378,7 @@
         self.cmdStr = 'TImute'
 
     def _tiMute(self, nameToMute):
-        if nameToMute in self.ao.textureLib.keys():
+        if nameToMute in list(self.ao.textureLib.keys()):
             if self.ao.textureLib[nameToMute].mute:
                 self.ao.textureLib[nameToMute].mute = 0
                 return 'TI %s is no longer muted.\n' % nameToMute
@@ -3856,7 +3856,7 @@
             demo, demoAdjust = self._tiGetDemo(tName, p, label, 'edit')
             if demo == None: return demoAdjust # this is the error message
             if p == 'path':
-                usrStr = self._chooseFromList(demo, self.ao.pathLib.keys(), 'case')
+                usrStr = self._chooseFromList(demo, list(self.ao.pathLib.keys()), 'case')
                 if usrStr == None: return lang.msgPIbadName
                 usrDataEval, errorMsg = self._tiEvalUsrStr(usrStr, p, tName)
                 if usrDataEval == None: return errorMsg
@@ -3947,7 +3947,7 @@
     def display(self): 
         msg = []
         msg.append('TextureInstances available:\n')
-        tNames = self.ao.textureLib.keys()
+        tNames = list(self.ao.textureLib.keys())
         tNames.sort()
         entryLines = []
         for name in tNames:
@@ -4001,14 +4001,14 @@
             args = argTools.ArgOps(args, stripComma=True)
             if args.list(0, 'end') != None: # if supplied
                 for name in args.list(0, 'end'):
-                    name = drawer.inList(name, self.ao.textureLib.keys())
+                    name = drawer.inList(name, list(self.ao.textureLib.keys()))
                     if name == None: return self._getUsage()
                     self.rmList.append(name)
             else: return self._getUsage()
 
         if self.rmList == []:
             name = self._chooseFromList('which TextureInstnace to delete?', 
-                     self.ao.textureLib.keys(), 'case')
+                     list(self.ao.textureLib.keys()), 'case')
             if name == None: return lang.msgTIbadName
             query = 'are you sure you want to delete texture %s?' % name
             askUsr = dialog.askYesNoCancel(query, 1, self.termObj)
@@ -4057,7 +4057,7 @@
 
     def _tiCopy(self, srcName, copyName):
         """copies a texture"""
-        if srcName != copyName and self.ao.textureLib.has_key(srcName) == 1:
+        if srcName != copyName and (srcName in self.ao.textureLib) == 1:
             self.ao.textureLib[copyName] = self.ao.textureLib[srcName].copy(
                                                                                       copyName)
             # increment references for this path
@@ -4080,7 +4080,7 @@
         if args != '':
             args = argTools.ArgOps(args, stripComma=True)
             self.oldName = drawer.inList(args.get(0), 
-                                self.ao.textureLib.keys())
+                                list(self.ao.textureLib.keys()))
             if self.oldName == None: return self._getUsage()
             if args.list(1, 'end') != None: # if supplied
                 for newName in args.list(1, 'end'):
@@ -4089,7 +4089,7 @@
 
         if self.cpList == []:
             self.oldName = self._chooseFromList('which TextureInstnace to copy?', 
-                self.ao.textureLib.keys(), 'case')
+                list(self.ao.textureLib.keys()), 'case')
             if self.oldName == None: return lang.msgTIbadName
             query = 'name this copy of TI %s:' % (repr(self.oldName))
             name = self._tiGetNewName(query)
@@ -4162,7 +4162,7 @@
         if args != '':
             args = argTools.ArgOps(args, stripComma=True)
             self.oldTextName = drawer.inList(args.get(0), 
-                                     self.ao.textureLib.keys())
+                                     list(self.ao.textureLib.keys()))
             if self.oldTextName == None: return self._getUsage()
             self.newTextName = args.get(1)
             if self.newTextName == None: return self._getUsage()
@@ -4436,7 +4436,7 @@
             if demo == None: return demoAdjust # this is the error message
     
             if p=='path':
-                usrStr = self._chooseFromList(demo, self.ao.pathLib.keys(), 
+                usrStr = self._chooseFromList(demo, list(self.ao.pathLib.keys()), 
                                  'case')
                 if usrStr == None: return lang.msgPIbadName
             elif p in ('ampQ', 'panQ', 'fieldQ', 'octQ', 'beatT', 'tRange', 
@@ -4466,7 +4466,7 @@
         self.report = []
         refresh = self.ao.aoInfo['refreshMode']
         # no errors: do final changes on ALL TEXTURES
-        for tName in self.ao.textureLib.keys():
+        for tName in list(self.ao.textureLib.keys()):
             # if self.p is not part of this texture (w/ an aux, or text)
             # an errormsg will be returned
             self.ok, msgEdit = self._tiEdit(tName, self.p, 
@@ -4544,7 +4544,7 @@
         p = self.p # this is the name of the texture 'self' variable
         label = self.label
 
-        text_keys = self.ao.textureLib.keys()
+        text_keys = list(self.ao.textureLib.keys())
         text_keys.sort()
         msg = []
         msg.append('compare parameters: ')
@@ -4559,7 +4559,7 @@
             msg.append('path\n')
             for key in text_keys:
                 name = 'unknown'
-                for pair in self.ao.pathLib.items():
+                for pair in list(self.ao.pathLib.items()):
                     if pair[1] == self.ao.textureLib[key].path:
                         name = pair[0]   
                 pathStr = self.ao.textureLib[key]._getPathList('string')
@@ -4616,7 +4616,7 @@
 
     def process(self): 
         if not self.ao.aoInfo['refreshMode']: # if refresh mode is off
-            for tName in self.ao.textureLib.keys():
+            for tName in list(self.ao.textureLib.keys()):
                 ok, msg = self._tiRefresh(tName) # update esObj if refreshmode off
         self.tiMapDict = self._teGetTimeMapDict()
 
@@ -4632,13 +4632,13 @@
         msg = []
         msg.append('TextureEnsemble Map:\n')
         msg.append(ruler)
-        tiNameList = tiMapDict.keys()
+        tiNameList = list(tiMapDict.keys())
         tiNameList.sort()
         for tiName in tiNameList:
             s, e = tiMapDict[tiName]['tRange']
             graph = typeset.graphDuration(totalDur, s, e, graphWidth, '_')
             msg.append('%s%s\n' % (tiName.ljust(lang.LMARGINW), graph))
-            for tcName in tiMapDict[tiName]['cloneDict'].keys():
+            for tcName in list(tiMapDict[tiName]['cloneDict'].keys()):
                 cloneS, cloneE = tiMapDict[tiName]['cloneDict'][tcName]['tRange']
                 graph = typeset.graphDuration(totalDur, cloneS, cloneE, 
                                                       graphWidth, '.')
@@ -5827,7 +5827,7 @@
         msg.append('EventOutput active:\n')
         entryLines = []
         prefList = self._emGetOutputFormats()
-        allEvents = outFormat.outputFormatNames.values()
+        allEvents = list(outFormat.outputFormatNames.values())
         allEvents.sort()
         for entry in allEvents:
             if entry in prefList:  
@@ -5907,7 +5907,7 @@
         msg = []
         msg.append('EventMode modes available:\n')
         entryLines = []
-        names = eventList.eventModeNames.values()
+        names = list(eventList.eventModeNames.values())
         names.sort()
         for entry in names:
             if entry == self.ao.activeEventMode:  
@@ -6355,10 +6355,10 @@
         """clears all ref counts on paths and recounts all uses of a path"""
         # clear all current values
         extantPaths = []
-        for pathName in self.ao.pathLib.keys():
+        for pathName in list(self.ao.pathLib.keys()):
             self.ao.pathLib[pathName].refCount = 0
             extantPaths.append(pathName)
-        for textureName in self.ao.textureLib.keys():
+        for textureName in list(self.ao.textureLib.keys()):
             pathName = self.ao.textureLib[textureName].path.name
             if pathName in extantPaths:
                 self.ao.pathLib[pathName].refIncr()
@@ -6410,8 +6410,8 @@
             self.ao.pathLib = {}     # reinit path bin
         else: # a name check must make sure that no paths with same name exist
             pass # do nothing, and add paths
-        if len(pathData['pathLib'].keys()) > 0: # paths exist
-            for pathName in pathData['pathLib'].keys():
+        if len(list(pathData['pathLib'].keys())) > 0: # paths exist
+            for pathName in list(pathData['pathLib'].keys()):
                 self.ao.pathLib[pathName] = pitchPath.PolyPath(pathName)
                 self.ao.pathLib[pathName].loadDataModel(
                                                   pathData['pathLib'][pathName])
@@ -6423,8 +6423,8 @@
         pathData = {}
         pathData['activePath'] = self.ao.activePath
         pathData['pathLib'] = {}
-        if len(self.ao.pathLib.keys()) > 0: # paths exist
-            for pathName in self.ao.pathLib.keys():
+        if len(list(self.ao.pathLib.keys())) > 0: # paths exist
+            for pathName in list(self.ao.pathLib.keys()):
                 p = self.ao.pathLib[pathName].writeDataModel()
                 pathData['pathLib'][pathName] = p
         else: # no paths exist, create dummy plug
@@ -6443,8 +6443,8 @@
         if replace == 'replace':
             self.ao.activeTexture = copy.deepcopy(textureData['activeTexture'])
             self.ao.textureLib = {}  # reinit path bin
-        if len(textureData['textureLib'].keys()) > 0: # textures exist
-            for textureName in textureData['textureLib'].keys():
+        if len(list(textureData['textureLib'].keys())) > 0: # textures exist
+            for textureName in list(textureData['textureLib'].keys()):
                 t = textureData['textureLib'][textureName]
                 pathName = copy.deepcopy(t['pathName'])
                 tmName = copy.deepcopy(t['tmName'])
@@ -6464,7 +6464,7 @@
                                  silenceMode, orcMapMode)
         if replace == 'replace':
             self.ao.cloneLib = clone.CloneManager()
-        for tag in textureData['cloneLib'].keys():
+        for tag in list(textureData['cloneLib'].keys()):
             post = tag.split(',') # comma separated
             tName, cName = post[0], post[1]
             c = textureData['cloneLib'][tag]
@@ -6489,8 +6489,8 @@
         textureData['activeTextureModule'] = self.ao.activeTextureModule
         textureData['midiTempo'] = self.ao.midiTempo # added 1.1
         textureData['textureLib'] = {}
-        if len(self.ao.textureLib.keys()) > 0: # textures exist
-            for tName in self.ao.textureLib.keys():
+        if len(list(self.ao.textureLib.keys())) > 0: # textures exist
+            for tName in list(self.ao.textureLib.keys()):
                 textureData['textureLib'][tName] = {}
                 t = textureData['textureLib'][tName]
                 t['pathName'] = self.ao.textureLib[tName].path.name
@@ -6532,10 +6532,10 @@
             try: # this may be a w wase of time
                 f = open(path, 'rU') 
                 doc = xml.dom.minidom.parse(f)
-            except IOError, errorMsg:
+            except IOError as errorMsg:
                 f.close()
                 return 'unknown', str(errorMsg) + '\n' + lang.msgAOerrorXML 
-            except xml.parsers.expat.ExpatError, errorMsg:
+            except xml.parsers.expat.ExpatError as errorMsg:
                 f.close()
                 return 'unknown', str(errorMsg) + '\n' + lang.msgAOerrorXML 
             f.close()
@@ -6564,32 +6564,32 @@
         self.ao.pathLib and self.ao.textureLib
         corrects for name conflicts by appending underscore
         """
-        for mgTextureName in tData['textureLib'].keys():
-            if mgTextureName in self.ao.textureLib.keys():
+        for mgTextureName in list(tData['textureLib'].keys()):
+            if mgTextureName in list(self.ao.textureLib.keys()):
                 oldMgTextureName = copy.deepcopy(mgTextureName)
                 while 1:
                     mgTextureName = mgTextureName + '_'
-                    if mgTextureName not in self.ao.textureLib.keys():
+                    if mgTextureName not in list(self.ao.textureLib.keys()):
                         break
                 newData = copy.deepcopy(
                             tData['textureLib'][oldMgTextureName])
                 tData['textureLib'][mgTextureName] = newData
-                if oldMgTextureName in tData['cloneLib'].keys():
+                if oldMgTextureName in list(tData['cloneLib'].keys()):
                      data = copy.deepcopy(
                             tData['cloneLib'][oldMgTextureName])
                      tData['cloneLib'][mgTextureName] = data
                      del tData['cloneLib'][oldMgTextureName]
                 del tData['textureLib'][oldMgTextureName]
-        for mgPathName in pData['pathLib'].keys():
-            if mgPathName in self.ao.pathLib.keys():
+        for mgPathName in list(pData['pathLib'].keys()):
+            if mgPathName in list(self.ao.pathLib.keys()):
                 oldMgPathName = copy.deepcopy(mgPathName)
                 while 1:
                     mgPathName = mgPathName + '_'
-                    if mgPathName not in self.ao.pathLib.keys():
+                    if mgPathName not in list(self.ao.pathLib.keys()):
                         break
                 newData = copy.deepcopy(pData['pathLib'][oldMgPathName])
                 pData['pathLib'][mgPathName] = newData
-                for textureName in tData['textureLib'].keys():
+                for textureName in list(tData['textureLib'].keys()):
                     thisPathName = tData[
                                         'textureLib'][textureName]['pathName']
                     if thisPathName == oldMgPathName:
@@ -7087,13 +7087,13 @@
         # argForce is used here to reduce arg usage when called
         # by other commands, here, the do() method of Command
         # argForce gives a quasi interactive nature
-        if 'argForce' in keywords.keys():
+        if 'argForce' in list(keywords.keys()):
             self.argForce = keywords['argForce']
         else:
             self.argForce = None
 
     def _updateTextureFilePaths(self):
-        for name in self.ao.textureLib.keys():
+        for name in list(self.ao.textureLib.keys()):
             self.ao.textureLib[name].updateFilePaths(
                 self.ao.aoInfo['fpAudioDirs'])
 
@@ -7473,7 +7473,7 @@
         pass
 
     def display(self): 
-        keys = self.ao.aoInfo['history'].keys()
+        keys = list(self.ao.aoInfo['history'].keys())
         keys.sort()
         if len(keys) == 0:
             return 'no history.\n'
@@ -7528,7 +7528,7 @@
         self.subCmd = 1 # if 1, executed within method of interptreter
 
     def gather(self): 
-        self.keys = self.ao.aoInfo['history'].keys()
+        self.keys = list(self.ao.aoInfo['history'].keys())
         self.keys.sort()
         if len(self.keys) == 0:
             return 'no history.\n'
@@ -7835,7 +7835,7 @@
             if tStr == None: return None
             try:
                 self.mObj.loadTransition(tStr)
-            except error.TransitionSyntaxError, e:
+            except error.TransitionSyntaxError as e:
                 dialog.msgOut('%s%s\n' % (lang.TAB, e), self.termObj)
                 continue
             return tStr
@@ -7857,7 +7857,7 @@
             if self.order == None: return self._getUsage()
             try:
                 self.mObj.loadTransition(args.get(2,'end','off','space'))
-            except error.TransitionSyntaxError, e:
+            except error.TransitionSyntaxError as e:
                 return self._getUsage(e)             
         if self.count == None: # get args from user
             self.count = self._getNumber('number of generations:', 'int', 1, 999)
@@ -7950,7 +7950,7 @@
             if spec == None: return None
             try:
                 specObj = automata.AutomataSpecification(spec)
-            except error.AutomataSpecificationError, e:
+            except error.AutomataSpecificationError as e:
                 dialog.msgOut('%s%s\n' % (lang.TAB, e), self.termObj)
                 continue
             return spec # return spec, not object
@@ -7990,7 +7990,7 @@
         mutationStart = self.mutation(0, refDict)
         try:
             self.ca = automata.factory(self.specStr, ruleStart, mutationStart)
-        except error.AutomataSpecificationError, e:
+        except error.AutomataSpecificationError as e:
             return 'error in CA specification: %s\n' % e
         for i in range(1, self.ca.spec.get('yTotal')): # already got zero
             self.ca.gen(1, self.rule(i, refDict), self.mutation(i, refDict))
--- ./athenaCL/libATH/dialog.py	(original)
+++ ./athenaCL/libATH/dialog.py	(refactored)
@@ -98,7 +98,7 @@
         prompt = typeset.wrapText(prompt, w, 0, 'line')
     # line wraping may remove the last space after prompt; make sure it is 
     # still there
-    return raw_input(_fixQuery(prompt))
+    return input(_fixQuery(prompt))
 
 #-----------------------------------------------------------------||||||||||||--
 
@@ -328,20 +328,20 @@
             path, stat = _macGetDirectory(prompt)
             return path, stat
         except:
-            print lang.msgDlgMacError
+            print(lang.msgDlgMacError)
 
     # platform specific file dialogs.
     if dlgVisualMethod[:2] == 'tk':
         try:
-            import Tkinter
-            import tkFileDialog
+            import tkinter
+            import tkinter.filedialog
             TK = 1
         except ImportError:
             TK = 0
-            print lang.msgDlgTkError
+            print(lang.msgDlgTkError)
 
     if dlgVisualMethod[:2] == 'tk' and TK == 1:
-        tkTemp = Tkinter.Tk()
+        tkTemp = tkinter.Tk()
         tkTemp.withdraw()
         ## "dir" only shows directories, but are unable to select 
         options = {'filetypes':[("directory", "*")], 
@@ -351,7 +351,7 @@
         if os.path.isdir(sampleDir):
             options['initialdir'] = sampleDir
             
-        guiTemp = tkFileDialog.Open()
+        guiTemp = tkinter.filedialog.Open()
         guiTemp.options = options
         # filename = apply(tkFileDialog.Open, (), options).show(
         try:
@@ -453,20 +453,20 @@
             path, stat = _macPutFile(prompt, defaultName, defaultDir)
             return path, stat
         except: # will be MacOS.Error but must import MacOS to select?
-            print lang.msgDlgMacError
+            print(lang.msgDlgMacError)
 
     # platform specific file dialogs.
     if dlgVisualMethod[:2] == 'tk':
         try:
-            import Tkinter
-            import tkFileDialog
+            import tkinter
+            import tkinter.filedialog
             TK = 1
         except ImportError:
             TK = 0
-            print lang.msgDlgTkError
+            print(lang.msgDlgTkError)
 
     if dlgVisualMethod[:2] == 'tk' and TK == 1:
-        tkTemp = Tkinter.Tk()
+        tkTemp = tkinter.Tk()
         tkTemp.withdraw()
         # put extension here, but dont know if i need period or not
         options = {'filetypes':[("all files", "*")],    
@@ -476,7 +476,7 @@
         if os.path.isdir(defaultDir):
             options['initialdir'] = defaultDir
                         
-        guiTemp = tkFileDialog.SaveAs()
+        guiTemp = tkinter.filedialog.SaveAs()
         guiTemp.options = options
         # filename = apply(tkFileDialog.Open, (), options).show(
         try:
@@ -626,20 +626,20 @@
             path, stat = _macGetFile(prompt, defaultDir)
             return path, stat
         except:
-            print lang.msgDlgMacError
+            print(lang.msgDlgMacError)
 
     # platform specific file dialogs.
     if dlgVisualMethod[:2] == 'tk':
         try:
-            import Tkinter
-            import tkFileDialog
+            import tkinter
+            import tkinter.filedialog
             TK = 1
         except ImportError:
             TK = 0
-            print lang.msgDlgTkError
+            print(lang.msgDlgTkError)
 
     if dlgVisualMethod[:2] == 'tk' and TK:
-        tkTemp = Tkinter.Tk()
+        tkTemp = tkinter.Tk()
         tkTemp.withdraw()
         options = {'filetypes':[("all files", "*")], 
                         'title'   : prompt,      
@@ -648,7 +648,7 @@
         if os.path.isdir(defaultDir):
             options['initialdir'] = defaultDir
         
-        guiTemp = tkFileDialog.Open()
+        guiTemp = tkinter.filedialog.Open()
         guiTemp.options = options
         # filename = apply(tkFileDialog.Open, (), options).show(
         try:
@@ -746,7 +746,7 @@
         diffs = []
         i = 0
         while 1:
-            c = raw_input('')
+            c = input('')
             when = time.time()
             if c.find("q") >= 0:
                 break
@@ -768,9 +768,9 @@
              sum = sum + d
         avgBeatT = sum / len(diffs)
         avgTempo = 60.0 / avgBeatT
-        print "average tempo %.2f BPM (%.2f s/beat)" % (avgTempo, avgBeatT)
+        print("average tempo %.2f BPM (%.2f s/beat)" % (avgTempo, avgBeatT))
         q_string = "    keep, repeat, or cancel? (k, r, or c): "
-        usrStr = raw_input(q_string)
+        usrStr = input(q_string)
         usrStr = usrStr.lower()
         if usrStr == '' or usrStr == None:
             exit = 1 #keep, dont cancel
@@ -912,7 +912,7 @@
         if newLines == 1 and x % 10 == 1: # once in a while
             msg.append('\n%sNewLine' % i) # show a new line
         else:
-            max = random.choice(range(1,10))# len of word
+            max = random.choice(list(range(1,10)))# len of word
             msg.append(str(i))
             for x in range(0, max):
                 msg.append(random.choice(string.lowercase))
--- ./athenaCL/libATH/dice.py	(original)
+++ ./athenaCL/libATH/dice.py	(refactored)
@@ -167,7 +167,7 @@
         [[0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0], [0, 0, 1, 1], [0, 1, 0, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 1, 1, 1], [1, 0, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 0, 1, 1], [1, 1, 0, 0], [1, 1, 0, 1], [1, 1, 1, 0], [1, 1, 1, 1]]
         """
         self.noVal = noVal # desired number of values
-        if self.noVal <= 0: raise ValueError, 'number of values must be greater than zero'
+        if self.noVal <= 0: raise ValueError('number of values must be greater than zero')
         # find exponent that is greater than or equal to
         self.noDice = self._findNearestExp(self.noVal)
         #environment.printDebug(['final number of dice', self.noDice])
@@ -195,7 +195,7 @@
                 bin.append(1)
             else:
                 bin.append(0)
-            dec = long(dec/2)
+            dec = int(dec/2)
         if bin == []: return [0]
         else: return bin
     
--- ./athenaCL/libATH/drawer.py	(original)
+++ ./athenaCL/libATH/drawer.py	(refactored)
@@ -26,8 +26,8 @@
     >>> isList('')
     False
     """
-    if (isinstance(usrData, types.ListType) or 
-         isinstance(usrData, types.TupleType)):
+    if (isinstance(usrData, list) or 
+         isinstance(usrData, tuple)):
         return True
     else:
         return False
@@ -42,9 +42,9 @@
     >>> isNum(3)
     True
     """
-    if (isinstance(usrData, types.FloatType) or 
-         isinstance(usrData, types.IntType) or 
-         isinstance(usrData, types.LongType)):
+    if (isinstance(usrData, float) or 
+         isinstance(usrData, int) or 
+         isinstance(usrData, int)):
         return True
     else:
         return False
@@ -57,7 +57,7 @@
     >>> isBool(0)
     False
     """
-    if isinstance(usrData, types.BooleanType):
+    if isinstance(usrData, bool):
         return True
     else:
         return False
@@ -70,7 +70,7 @@
     >>> isFloat(3)
     False
     """
-    if isinstance(usrData, types.FloatType):
+    if isinstance(usrData, float):
         return True
     else:
         return False
@@ -84,7 +84,7 @@
     >>> isInt('3')
     False
     """
-    if isinstance(usrData, types.IntType):
+    if isinstance(usrData, int):
         return True
     else:
         return False
@@ -97,7 +97,7 @@
     >>> isStr(3.2)
     False
     """
-    if isinstance(usrData, types.StringType):
+    if isinstance(usrData, bytes):
         return True
     else:
         return False
@@ -110,7 +110,7 @@
     >>> isDict('false')
     False
     """
-    if isinstance(usrData, types.DictType):
+    if isinstance(usrData, dict):
         return True
     else:
         return False
@@ -230,7 +230,7 @@
     elif type == 'dict':
         return isDict(usrData)
     else:
-        raise ValueError, 'bad data type given'
+        raise ValueError('bad data type given')
 
 #-----------------------------------------------------------------||||||||||||--
 # list searching and confirmation
@@ -425,8 +425,8 @@
     """test to see if sudo availabe on unix platforms
     this should be altered to use the command module"""
     if os.name != 'posix': return 0 # no sudo
-    import commands
-    stat, str = commands.getstatusoutput('sudo -V')
+    import subprocess
+    stat, str = subprocess.getstatusoutput('sudo -V')
     if stat == 0: # success if it returns zero
         return 1
     else: return 0
@@ -444,13 +444,13 @@
     except ImportError:
         PIL = 0
     try:
-        import Tkinter
+        import tkinter
         TK = 1
     except ImportError:
         TK = 0  
     if TK:
         try: # tkinter already imported; check creation, as may still fail
-            tkTemp = Tkinter.Tk()
+            tkTemp = tkinter.Tk()
             tkTemp.withdraw()
             tkTemp.destroy()
             del tkTemp
@@ -548,9 +548,9 @@
             # note that reserved strings will be evaluated:
             # 'open' evaluates to a file object
             if not isNum(numEval):
-                raise ValueError, 'bad number format: %s' % numType     
+                raise ValueError('bad number format: %s' % numType)     
         else: # should not happen
-            raise ValueError, 'bad number format: %s' % numType
+            raise ValueError('bad number format: %s' % numType)
     except (SyntaxError, NameError, ValueError, TypeError, ZeroDivisionError):
         return None
     if min != None:  # check for min and max
@@ -612,7 +612,7 @@
         elif case.find('l') >= 0: # lower case
             usrStr = usrStr.lower()
         else:
-            raise ValueError, 'bad case type given'
+            raise ValueError('bad case type given')
     usrStr = usrStr.strip()
     for char in rm:
         usrStr = usrStr.replace(char, '')
@@ -810,7 +810,7 @@
     will raise exception on error
     note: may want to use os.abspath to find abs paths"""
     if not isStr(usrStr):
-        raise ValueError, 'non-string submitted as a path string: %r' % usrStr
+        raise ValueError('non-string submitted as a path string: %r' % usrStr)
 
     if os.name == 'posix':
         # expand user must be done before realpath on posix
@@ -865,7 +865,7 @@
         return os.path.expanduser('~') # get active users dir
     else: # win or other
         dir = None
-        if 'USERPROFILE' in os.environ.keys(): # windows xp and others
+        if 'USERPROFILE' in list(os.environ.keys()): # windows xp and others
             dir = os.environ['USERPROFILE'] #windows NT,2k,XP,etc
             if not os.path.isdir(dir):
                 dir = None
@@ -1176,13 +1176,13 @@
     """
     short = []
     long = []
-    keys = refDict.keys()
+    keys = list(refDict.keys())
     keys.sort()
     for key in keys:
         value = refDict[key]
         short.append(key)
-        long.append(value)
-    return ', '.join(long), ', '.join(short)
+        int.append(value)
+    return ', '.join(int), ', '.join(short)
         
         
 def acronymExtract(usrStr):
@@ -1214,7 +1214,7 @@
     True
     """
     firstChar = []
-    for label in refDict.keys(): # keys are acronymes
+    for label in list(refDict.keys()): # keys are acronymes
         label = label.lower()
         char = label[0] # get firs character
         if char in firstChar:
@@ -1250,7 +1250,7 @@
     # do before changing case
     autoStr = acronymExtract(usrStr)
     usrStr = strScrub(usrStr, 'lower')
-    for key in refDict.keys():
+    for key in list(refDict.keys()):
         # check if key mathces first
         if usrStr == key.lower():
             return refDict[key] # return value, not key
@@ -1259,7 +1259,7 @@
             return refDict[key]
     # if not match, and auto on, search auto extraction
     if autoSearch:
-        for key in refDict.keys():
+        for key in list(refDict.keys()):
             # check if key mathces first; dont check whole string
             if autoStr == key.lower():
                 return refDict[key]
@@ -1298,7 +1298,7 @@
     autoStr = acronymExtract(usrStr)          
     # serach values in dict
     usrStr = strScrub(usrStr, 'lower')
-    for key in refDict.keys():
+    for key in list(refDict.keys()):
         if isStr(key):
             if key.lower() == usrStr:
                 return key
@@ -1311,7 +1311,7 @@
             if val.lower() == usrStr:
                 return key
     if autoSearch:
-        for key in refDict.keys():
+        for key in list(refDict.keys()):
             # may just get first letter
             autoKey = acronymExtract(key)
             if autoStr == autoKey:
@@ -1321,7 +1321,7 @@
 def selectionParseKeyLabel(ref, finalStr='or'):
     """utility to convert a selection parse dictionary to a text label
     that can be presented to users as a help string"""
-    names = ref.keys()
+    names = list(ref.keys())
     if len(names) == 1:
         return names[0] # value alone
     names.sort()
@@ -1494,9 +1494,9 @@
 
         # try to use defined app data directory for preference file
         # this is not available on all windows versions
-        if 'APPDATA' in os.environ.keys():
+        if 'APPDATA' in list(os.environ.keys()):
             dir = os.environ['APPDATA']
-        elif ('USERPROFILE' in os.environ.keys() and
+        elif ('USERPROFILE' in list(os.environ.keys()) and
             os.path.exists(os.path.join(
             os.environ['USERPROFILE'], 'Application Data'))):
             dir = os.path.join(os.environ['USERPROFILE'], 
--- ./athenaCL/libATH/envelope.py	(original)
+++ ./athenaCL/libATH/envelope.py	(refactored)
@@ -49,7 +49,7 @@
     nadir = unit.denorm(0, min, max)
 
     if propAbsSwitch not in ['absolute', 'proportional']:
-        raise error.ParameterObjectSyntaxError, 'incorrect switch'
+        raise error.ParameterObjectSyntaxError('incorrect switch')
 
     if propAbsSwitch == 'absolute':
         timeUnitDenorm = [rampUp, widthMax, rampDown, widthMin]
@@ -98,7 +98,7 @@
     susLevel = (peak-nadir) * unit.limit(susScalar)
 
     if propAbsSwitch not in ['absolute', 'proportional']:
-        raise error.ParameterObjectSyntaxError, 'incorrect switch'
+        raise error.ParameterObjectSyntaxError('incorrect switch')
 
     if propAbsSwitch == 'absolute':
         timeUnitDenorm = [attack, decay, sustain, release]
--- ./athenaCL/libATH/error.py	(original)
+++ ./athenaCL/libATH/error.py	(refactored)
@@ -99,10 +99,10 @@
 
 # was CloneError
 # now error.CloneError
-class CloneError(StandardError):
+class CloneError(Exception):
     def __init__(self, msg=''):
         self._msg = msg
-        StandardError.__init__(self, "%s" % self._msg)
+        Exception.__init__(self, "%s" % self._msg)
     
     def __repr__(self):
         return self._msg
@@ -112,10 +112,10 @@
 
 # was MultisetInitError, BadSetInput
 # now error.MultisetError
-class MultisetError(StandardError):
+class MultisetError(Exception):
     def __init__(self, msg=''):
         self._msg = msg
-        StandardError.__init__(self, "%s" % self._msg)
+        Exception.__init__(self, "%s" % self._msg)
     
     def __repr__(self):
         return self._msg
@@ -124,13 +124,13 @@
 
 # was TestBug
 # now error.TestError
-class TestError(StandardError):
+class TestError(Exception):
     '''
     >>> a = TestError()
     '''
     def __init__(self, msg=''):
         self._msg = msg
-        StandardError.__init__(self, "%s" % self._msg)
+        Exception.__init__(self, "%s" % self._msg)
     
     def __repr__(self):
         return self._msg
--- ./athenaCL/libATH/eventList.py	(original)
+++ ./athenaCL/libATH/eventList.py	(refactored)
@@ -95,7 +95,7 @@
     'superColliderNative'
     """   
     emName = eventModeParser(emName)
-    if emName not in eventModeNames.values() or emName == None:
+    if emName not in list(eventModeNames.values()) or emName == None:
         raise Exception('bad event name obtained: %s' % emName)
 
     if emName == 'csoundNative':
@@ -124,7 +124,7 @@
     >>> selectOutEngineOrc('superColliderNative', 'EngineSuperColliderTask')
     'superColliderNative'
     """
-    if emName not in eventModeNames.values() or emName == None:
+    if emName not in list(eventModeNames.values()) or emName == None:
         raise Exception('bad emName: %s' % emName)
 
     if oeName not in outputEngineNames:
@@ -218,7 +218,7 @@
         
     def keys(self):
         # return event inex positions form 0
-        return range(0, len(self._eventList))
+        return list(range(0, len(self._eventList)))
 
     def __getitem__(self, key):
         """numbers are index keys, return event dict at this location"""
@@ -333,7 +333,7 @@
                 eventFrameIndex.append(i)
         
         if self.__len__() != len(eventFrameIndex):
-            raise ValueError, 'tFrameArray does not contain all events stored: %s, %s' % (self.__len__(), len(eventFrameIndex))
+            raise ValueError('tFrameArray does not contain all events stored: %s, %s' % (self.__len__(), len(eventFrameIndex)))
 
         # iterate over all indexes less 1, as two are done at a time
         for i in range(self.__len__()-1):
@@ -347,7 +347,7 @@
             # prepare list of parameters to clone in a dictionary
             # always include aux list, as some vals may not be numbers
             eventTemplate = {}
-            for key in eStart.keys():
+            for key in list(eStart.keys()):
                 if key not in active or key == 'aux':
                     eventTemplate[key] = copy.deepcopy(eStart[key])
                 
@@ -468,7 +468,7 @@
         src(t,d) 138 3   post(t,d) 138 1
         """
         # creat index arrays
-        iForward = range(self.__len__())
+        iForward = list(range(self.__len__()))
         iReverse = copy.deepcopy(iForward)
         iReverse.reverse()
 
@@ -595,7 +595,7 @@
             self.auxNo = self.srcObj.auxNo # must be clone or texture
             if self.srcFmt == 'c':
                 if len(self.srcObj.esObj) == 0:
-                    raise ValueError, 'clone with empty esObj cannot be graphed' 
+                    raise ValueError('clone with empty esObj cannot be graphed') 
 
         # need to reverse srcObj order 
         #if self.srcFmt in ['pf']:
@@ -650,7 +650,7 @@
         elif self.srcFmt in ['pr']: # parameter rhythm
             self.pmtrOrder = ['dur', 'sus', 'acc']
         else:
-            raise ValueError, 'bad src format'
+            raise ValueError('bad src format')
 
         #environment.printDebug(['EventSequenceSplit splitScore', splitScore, self.pmtrOrder])
 
@@ -670,7 +670,7 @@
         """
         delKey = []
         if self.srcFmt not in ['pg', 'pf', 'pr']: # parameter texture
-            for key in self.srcObj.pmtrObjDict.keys():
+            for key in list(self.srcObj.pmtrObjDict.keys()):
                 pObj = self.srcObj.pmtrObjDict[key]
                 if pObj.outputFmt == 'str' and self.strBypass:
                     delKey.append(key)
@@ -704,7 +704,7 @@
             # if this is a clone, scores needs data from texture
             ok = self.srcObj.score()
             if ok == -1 or self.srcObj.checkScore() == 0:
-                raise ValueError, 'bad score generation' # error        
+                raise ValueError('bad score generation') # error        
             esObj = self.srcObj.getScore()
         # uses esObj method with input obj of split score to update
         # split score may be empty here
@@ -714,7 +714,7 @@
         """suply a srcObj instance and load fresh parameter data
         may overwrite some data obtained w/ loadScoreList
         note: preScore cannot be calculated from a clone"""
-        for key in self.srcObj.pmtrObjDict.keys():
+        for key in list(self.srcObj.pmtrObjDict.keys()):
             if key not in self.pmtrOrder: # only parameters that are here
                 continue
             pObj = self.srcObj.pmtrObjDict[key]
@@ -741,8 +741,8 @@
             refDict['fpAudioDirs'] = self.aoInfo['fpAudioDirs']
         
         # these are the same; why have both?
-        self.splitScore['time'] = range(0, self.nEvent)
-        self.splitScore['event'] = range(0, self.nEvent)
+        self.splitScore['time'] = list(range(0, self.nEvent))
+        self.splitScore['event'] = list(range(0, self.nEvent))
 
         for label, lib, pObj in self.srcObj:
 
@@ -967,9 +967,9 @@
     def sort(self):
         """sort all event lists; only called by EventMode"""
         #print _MOD, 'Performer: sorting all EventSequences' 
-        for t in self.polySeq.keys(): # get texture names
+        for t in list(self.polySeq.keys()): # get texture names
             self.polySeq[t]['esObj'].sort()
-            for c in self.polySeq[t]['TC'].keys():
+            for c in list(self.polySeq[t]['TC'].keys()):
                 self.polySeq[t]['TC'][c]['esObj'].sort()
         
     def _packTexture(self, tName, t):
@@ -1012,7 +1012,7 @@
             if refresh:
                 ok = t.score() #returns -1 if score fails
                 if not ok or t.checkScore() == 0:
-                    print _MOD, 'texture failed to score', tName
+                    print(_MOD, 'texture failed to score', tName)
                     continue
             self._packTexture(tName, t)
 
@@ -1030,7 +1030,7 @@
         textureLib = ao.textureLib
         cloneLib = ao.cloneLib
         self.reset()
-        for tName in textureLib.keys():
+        for tName in list(textureLib.keys()):
             t = textureLib[tName]
             #inst = t.getInst()
             #if inst not in self.instList: self.instList.append(inst)
@@ -1038,7 +1038,7 @@
             if refresh:
                 ok = t.score() #returns -1 if score fails
                 if not ok or t.checkScore() == 0:
-                    print _MOD, 'texture failed to score', tName
+                    print(_MOD, 'texture failed to score', tName)
                     continue
             self._packTexture(tName, t)
             # get necessary inputs for clones
@@ -1051,7 +1051,7 @@
                 if refresh:
                     ok = c.score(esObjTexture, refDict)
                     if not ok:
-                        print _MOD, 'clone failed to score', tName, cName
+                        print(_MOD, 'clone failed to score', tName, cName)
                         continue
                 self._packClone(tName, cName, c)
 
@@ -1185,7 +1185,7 @@
         # only need polySequence here; no longer pass perfObj
         # polySeq = perfObj.polySeq
         
-        for t in polySeq.keys(): # get texture names
+        for t in list(polySeq.keys()): # get texture names
             tOrcObj = polySeq[t]['orcObj']
             inst = polySeq[t]['inst'] # inst number as integer
             if tOrcObj.name == self.orcObj.name: # assume match, full compat
@@ -1348,7 +1348,7 @@
             orderList.append('comment') # always last         
         label = []           
         for key in orderList:
-            if key in name.keys():
+            if key in list(name.keys()):
                 label.append(name[key])
             elif drawer.isInt(key):
                 iStr = str(key).rjust(2)
@@ -1686,7 +1686,7 @@
             esObj = tDict['esObj']
             if not tDict['mute']: # pass object to mix data into
                 self.aObj = self._translateAudioFile(orcMapMode, esObj, self.aObj, self.unitSynthesizerMethod)
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     esObj = tDict['TC'][cName]['esObj'] 
                     self.aObj = self._translateAudioFile(orcMapMode, esObj,
@@ -1862,7 +1862,7 @@
         f.close()       
 
         if os.name == 'posix':        
-            os.chmod(self.fpRef['pathBat'], 0755) #makes executable (744=rwxr--r--) 
+            os.chmod(self.fpRef['pathBat'], 0o755) #makes executable (744=rwxr--r--) 
         else: # win or other
             pass
         self.outComplete.append('csoundBatch')
@@ -2015,7 +2015,7 @@
                 data, label = self._translateCsoundExternalStr(orcMapMode, esObj)
                 msg.append(label)
                 msg.append(data)
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     msg.append(self._fmtHeadClone(className, tName, cName, ';'))
                     esObj = tDict['TC'][cName]['esObj'] 
@@ -2068,7 +2068,7 @@
                 data, label = self._translateCsoundSilenceStr(orcMapMode, esObj)
                 msg.append(label)
                 msg.append(data)
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     msg.append(self._fmtHeadClone(className, tName, cName, ';'))
                     esObj = tDict['TC'][cName]['esObj'] 
@@ -2240,7 +2240,7 @@
                                 dataList, vShift))
                     vShift += 1
 
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     esObj = tDict['TC'][cName]['esObj']
                     for pmtrName in pmtrList:
@@ -2369,7 +2369,7 @@
                 esObj = tDict['esObj']
                 midiSco = self._translateMidiList(orcMapMode, esObj)
                 trackList.append((tName, pgm, ch, midiSco))
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     esObj = tDict['TC'][cName]['esObj']
                     midiSco = self._translateMidiList(orcMapMode, esObj)
@@ -2469,7 +2469,7 @@
                 title = self._fmtTitleTexture(musicName, tName)
                 self.codeList.append(self._acSection(title, dataList, totalDur))
                 sectionList.append(title)
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     esObj = tDict['TC'][cName]['esObj']
                     totalDur = esObj.getTotalDuration()
@@ -2534,7 +2534,7 @@
                                 esObj, delimit)
                 msg.append(label)
                 msg.append(data)
-            for cName in tDict['TC'].keys():
+            for cName in list(tDict['TC'].keys()):
                 if not tDict['TC'][cName]['mute']:
                     msg.append(self._fmtHeadClone(className, tName, cName,))
                     esObj = tDict['TC'][cName]['esObj']  
@@ -2594,7 +2594,7 @@
     def __init__(self, ao, name):
         self.name = eventModeParser(name) # needed to get default orc update
         if self.name == None: 
-            raise ValueError, 'no such EventMode: %s' % name
+            raise ValueError('no such EventMode: %s' % name)
 
         self.ao = ao
         # not necessary to store perfObj, as created only w/ process method
@@ -2606,7 +2606,7 @@
         
         #keep a local copy of all output format objects, keyed by format name
         self.outFormatObjects = {} # a dictionary of stringName/obj pairs
-        for key in outFormat.outputFormatNames.values():
+        for key in list(outFormat.outputFormatNames.values()):
             self.outFormatObjects[key] = outFormat.factory(key)
         
         # all fpRef keys used by engines to write files on process runs                            
@@ -2694,7 +2694,7 @@
         self.fpRef['fpOutputAudio'] = self._buildPathPrime(self.fpRef['audioExt'])
 
         # this automatically loads all paths in output formats
-        for fmtObj in self.outFormatObjects.values():
+        for fmtObj in list(self.outFormatObjects.values()):
             self.fpRef[fmtObj.emKey] = self._buildPathPrime(fmtObj.ext)
 
         # assigned to after processing
@@ -2724,7 +2724,7 @@
         """
         if drawer.isStr(outRequest):
             if outRequest == 'all':
-                outRequest = outFormat.outputFormatNames.values()
+                outRequest = list(outFormat.outputFormatNames.values())
         engineRequest = []
         # do exclusive groups first; cant be two kinds of csound
         # get engines for varuous EventMode Names         
@@ -2848,7 +2848,7 @@
         self._initRefPaths()
         msg = []
         # get all write paths from all possible output formats
-        for fmtObj in self.outFormatObjects.values():
+        for fmtObj in list(self.outFormatObjects.values()):
             # emKey attribute is names used here
             msg.append(self.fpRef[fmtObj.emKey])
         return msg
@@ -2874,7 +2874,7 @@
         else:
             headList.append('%s active OutputEngines:\n' % len(engineLib))
         entryLines = []
-        eNames = engineLib.keys()
+        eNames = list(engineLib.keys())
         eNames.sort()
         for engineName in eNames:
             engine = engineLib[engineName]
@@ -2888,7 +2888,7 @@
         emOrcObj = orc.factory(selectEventModeOrc(self.name))
         engineLib = self._engineAllocate(usrOutRequest)
         msg = []
-        eNames = engineLib.keys()
+        eNames = list(engineLib.keys())
         eNames.sort()
         for engineName in eNames:
             engine = engineLib[engineName]
@@ -2948,13 +2948,13 @@
         msg = []
         # when calling a engine, pass modeOrcObj, process in addition
         # to local texture based texture orcObj
-        for engineName in engineLib.keys():
+        for engineName in list(engineLib.keys()):
             try: # will write orchestra if necessary 
                 # only pass a fpRef to the polySeq to the engine
                 engineLib[engineName].write(perfObj.polySeq, outRequest) 
                 self.outComplete = (self.outComplete + 
                                    engineLib[engineName].outComplete)
-            except (IOError, OSError), e:
+            except (IOError, OSError) as e:
                 ok = 0
                 msg.append(e)
             # get fpRef data from engine
--- ./athenaCL/libATH/faq.py	(original)
+++ ./athenaCL/libATH/faq.py	(refactored)
@@ -20,13 +20,13 @@
         """
         >>> a = FaqDictionary()
         """
-        self.keyList = range(1,30) # increase number for new entries
+        self.keyList = list(range(1,30)) # increase number for new entries
 
         self.groupTitleDict = {'general': 'General Information',
               'install': 'Installing, Starting, and Uninstalling athenaCL',
                                       'usage' : 'Using and Configuring athenaCL',
                                       }
-        self.groupList = self.groupTitleDict.keys()
+        self.groupList = list(self.groupTitleDict.keys())
 
         self.faqDict = {}
         for number in self.keyList:
@@ -36,7 +36,7 @@
 
     def sortKeys(self):
         keyQuaryList = []
-        for entry in self.faqDict.keys():
+        for entry in list(self.faqDict.keys()):
             keyQuaryList.append((self.faqDict[entry].query, entry))
         keyQuaryList.sort()
         keyIds = []
@@ -45,7 +45,7 @@
         return keyIds
 
     def searchQuery(self, query):
-        for entry in self.faqDict.keys():
+        for entry in list(self.faqDict.keys()):
             if query.lower() in self.faqDict[entry].query.lower():
                 return self.faqDict[entry].query, self.faqDict[entry].answer
         return None, None # if nothing found
--- ./athenaCL/libATH/feedback.py	(original)
+++ ./athenaCL/libATH/feedback.py	(refactored)
@@ -333,13 +333,13 @@
         if len(particleArray) == 0: # empty
             return None
 
-        pIndex = random.choice(range(len(particleArray)))
+        pIndex = random.choice(list(range(len(particleArray))))
         p = particleArray[pIndex]
         # only process if state matches current state of this particle
         if p.getState() != self.getState():
             return particleArray # return unaltered reference
         # find transform        
-        if self.getState() not in self.transformMap.keys():
+        if self.getState() not in list(self.transformMap.keys()):
             return None
 
         weights = []
@@ -547,7 +547,7 @@
         20 
         """
         senseLevel = 0
-        for partType in composition.keys(): # keys in a dictionary
+        for partType in list(composition.keys()): # keys in a dictionary
             if self.particleSenseType == partType:
                 senseLevel = composition[self.particleSenseType]
                 break
@@ -589,7 +589,7 @@
         8
         '''
         countRaw = None
-        for key in self.productionCountRange.keys():
+        for key in list(self.productionCountRange.keys()):
             # a None key provides a default value range
             if key == None: 
                 continue
@@ -602,7 +602,7 @@
 
         if not drawer.isList(countRaw): # create an inclusive range
             countRaw = [countRaw, countRaw]
-        count = random.choice(range(countRaw[0], countRaw[1]+1))
+        count = random.choice(list(range(countRaw[0], countRaw[1]+1)))
         return count
 
 
@@ -766,12 +766,12 @@
                 post[state] = 0
             post[state] = post[state] + 1        
         if boundaryMethod != None:
-            for key in post.keys():
+            for key in list(post.keys()):
                 pre = post[key]
                 post[key] = unit.boundaryFit(self.range[0], 
                     self.range[1], pre, boundaryMethod)
         if normalize:
-            for key in post.keys():
+            for key in list(post.keys()):
                 pre = post[key]
                 post[key] = unit.unitNorm(pre, self.range)
         return post
@@ -793,7 +793,7 @@
         """
         post = {}
         for sp in self._sensorProducerArray:
-            if sp.particleSenseType not in post.keys():
+            if sp.particleSenseType not in list(post.keys()):
                 post[sp.particleSenseType] = [0, 0] # count, threshold sum
             # increment count
             post[sp.particleSenseType][0] += 1
@@ -880,7 +880,7 @@
 
     def reprPartcle(self):
         post = self.getComposition()
-        post = post.items()
+        post = list(post.items())
         post.sort()
         return post
         
--- ./athenaCL/libATH/fileTools.py	(original)
+++ ./athenaCL/libATH/fileTools.py	(refactored)
@@ -86,8 +86,8 @@
         # note that this does not work for some raw audio files 
         try:
             audioData = sndhdr.what(self.absPath)
-        except RuntimeError, e:
-            print _MOD, 'bad audio file: %s' % absPath
+        except RuntimeError as e:
+            print(_MOD, 'bad audio file: %s' % absPath)
             audioData = None
 
         if audioData == None:
@@ -292,12 +292,12 @@
         x = self.countLines()
         sum, white, comments, defs, classes, defsTest, classesTest = x
         for entry in self.dirList:
-            print entry
-        print '\n%s lines of code found for %s .py files' % (sum,
-                                                      len(self.fileList))
-        print '(%s white, %s comments)' % (white, comments) 
-        print '%s class, %s def statements' % (classes, defs)
-        print '%s Test classes, %s def test statements\n' % (classesTest, defsTest)
+            print(entry)
+        print('\n%s lines of code found for %s .py files' % (sum,
+                                                      len(self.fileList)))
+        print('(%s white, %s comments)' % (white, comments)) 
+        print('%s class, %s def statements' % (classes, defs))
+        print('%s Test classes, %s def test statements\n' % (classesTest, defsTest))
 
 #-----------------------------------------------------------------||||||||||||--
 class GatherCvs(DirWalk):
@@ -439,11 +439,11 @@
     
         for path in pathList:
             if os.path.isdir(path):
-                print "not a file (dir): %s" % path
+                print("not a file (dir): %s" % path)
                 continue
             data = open(path, "rb").read()
             if '\0' in data:
-                print "not a file (binary): %s" % path
+                print("not a file (binary): %s" % path)
                 continue
 
             newdata = re.sub("\r?\n", newLF, data)
@@ -458,14 +458,14 @@
                                          ['txt', 'py', 'xml'])
         filteredFileList = selPaths
         if len(filteredFileList) == 0:
-            print 'empty directory: %s' % self.searchDir
+            print('empty directory: %s' % self.searchDir)
         else:
             fileNumber = '%i' % len(filteredFileList)
             msg = ('convert to %s: %s files in %s' % 
                                       (self.dstFormat.upper(), 
                                       fileNumber.rjust(4), 
                                       self.searchDir))
-            print msg
+            print(msg)
             self.convert(filteredFileList, self.dstFormat)
 
 
@@ -490,24 +490,24 @@
                 or file[-3:] == 'CH3' or file[-3:] == 'CH4'):
                 newKey = file[:-3] # name, with out period ?
                 newRef = file[-3:] # ext
-                if self.group.has_key(newKey):
+                if newKey in self.group:
                     self.group[newKey].append(newRef)
                 else:
                     self.group[newKey] = []
                     self.group[newKey].append(newRef)
 
     def rename(self):
-        for fileGroup in self.group.keys():
-            print 'renaming %s' % fileGroup
+        for fileGroup in list(self.group.keys()):
+            print('renaming %s' % fileGroup)
             for ext in self.group[fileGroup]:
                 oldName = fileGroup + ext
                 newName = fileGroup + '.' + self.conversion[ext] # . needed
                 oldPath = os.path.join(self.searchDir, oldName)
                 newPath = os.path.join(self.searchDir, newName)
                 cmdStr = 'mv %s %s' % (oldPath, newPath)
-                print cmdStr
+                print(cmdStr)
                 os.system(cmdStr)
-        print ''        
+        print('')        
 
 class RenameStereo:
     """strip L,R extensions from files"""
@@ -529,15 +529,15 @@
             if file[-2:] == '.L' or file[-2:] == '.R':
                 newKey = file[:-2] # name, with out period
                 newRef = file[-2:] # extension
-                if self.group.has_key(newKey):
+                if newKey in self.group:
                     self.group[newKey].append(newRef)
                 else:
                     self.group[newKey] = []
                     self.group[newKey].append(newRef)
 
     def rename(self):
-        for fileGroup in self.group.keys():
-            print 'renaming %s' % fileGroup
+        for fileGroup in list(self.group.keys()):
+            print('renaming %s' % fileGroup)
             for ext in self.group[fileGroup]:
                 oldName = fileGroup + ext
                 if len(self.group[fileGroup]) == 1: # if only one file here
@@ -549,7 +549,7 @@
                 cmdStr = 'mv %s %s' % (oldPath, newPath)
                 #print cmdStr
                 os.system(cmdStr)
-        print ''        
+        print('')        
 
 #-----------------------------------------------------------------||||||||||||--
 class BundleFiles:
@@ -574,18 +574,18 @@
                 if name[-len(ext):] == ext: # if has this ext
                     nameStub = name[:-len(ext)]
                     break
-            if nameStub not in bundleDict.keys():
+            if nameStub not in list(bundleDict.keys()):
                 bundleDict[nameStub] = []
             bundleDict[nameStub].append(path)
 
-        for groupName in bundleDict.keys():
+        for groupName in list(bundleDict.keys()):
             if len(bundleDict[groupName]) > 1: # dont bundle single items
                 groupDir = os.path.join(self.searchDir, groupName)
                 if os.path.isdir(groupDir) != 1: # if doesnt exists
-                    print groupDir # if doesnt exist
+                    print(groupDir) # if doesnt exist
                     os.mkdir(groupDir)
                 else:
-                    print "dir in the way: %s" % groupDir 
+                    print("dir in the way: %s" % groupDir) 
 
                 for path in bundleDict[groupName]:
                     dir, name = os.path.split(path)
@@ -595,7 +595,7 @@
                         #print cmdStr
                         os.system(cmdStr)
                     else:
-                        print "file in the way: %s" % newDst 
+                        print("file in the way: %s" % newDst) 
 
 
 class BundleAudio:
@@ -620,7 +620,7 @@
                 cmdStr = 'mv %s %s' % (path, newDst)
                 os.system(cmdStr)
             else:
-                print "file in the way: %s" % newDst 
+                print("file in the way: %s" % newDst) 
 
 
 
@@ -634,8 +634,8 @@
     "parent class for proof sheets"
     def __init__(self, dirPath):
         if not os.path.isdir(dirPath):
-            print 'got bad dir path', dirPath
-            raise error.ArgumentError, 'bad file path supplied'
+            print('got bad dir path', dirPath)
+            raise error.ArgumentError('bad file path supplied')
         dirPath = drawer.pathScrub(dirPath)
 
         self.dirPath = dirPath
@@ -646,7 +646,7 @@
         self.proofDirPath = os.path.join(self.dirPath, self.proofDirName)
         if os.path.exists(self.proofDirPath) != 1:
             os.mkdir(self.proofDirPath)
-            print 'writing: %s' % self.proofDirPath
+            print('writing: %s' % self.proofDirPath)
         else: pass
         # create index path
         self.indexPath = os.path.join(self.proofDirPath, 'index.html')
@@ -786,12 +786,12 @@
         except:
             return None
         msg = []
-        sortKeys = exifData.keys()
+        sortKeys = list(exifData.keys())
         sortKeys.sort()
         for key in sortKeys:
             #if not drawer.isStr(exifData[key]):
             #    print '%s: %s' % (key, exifData[key].printable)
-            if key in viewKeys.keys():
+            if key in list(viewKeys.keys()):
                 msg.append('%s-%s' % (viewKeys[key], exifData[key]))
         f.close()
         if msg == []:
@@ -1065,7 +1065,7 @@
 
     def process(self):
         # get all file paths (after removing old images dir!)
-        from urllib import urlopen
+        from urllib.request import urlopen
 
         doc = urlopen(self.url).read()
 
@@ -1093,7 +1093,7 @@
         count = 0
 
         if self.filteredLinks == []:
-            print 'no matches'
+            print('no matches')
             return None
             
         for descr, url in self.filteredLinks:
@@ -1176,13 +1176,13 @@
         """count relative subdirs, excluding parent dir
         first method called to gather all file data"""
         self.dirListA = []
-        for file in self.fileDictA.keys():
+        for file in list(self.fileDictA.keys()):
             relDir = self.fileDictA[file].relDir
             if relDir != None:
                 if relDir not in self.dirListA:
                     self.dirListA.append(relDir)
         self.dirListB = []
-        for file in self.fileDictB.keys():
+        for file in list(self.fileDictB.keys()):
             relDir = self.fileDictB[file].relDir
             if relDir != None:
                 if relDir not in self.dirListB:
@@ -1191,38 +1191,38 @@
 
     def _mergeFiles(self):
         "combine files from a, b into a composite"
-        for file in self.fileDictA.keys():
-            if file not in self.mergedFileDict.keys():
+        for file in list(self.fileDictA.keys()):
+            if file not in list(self.mergedFileDict.keys()):
                 self.mergedFileDict[file] = {} #each entry a dictionary
-            if not self.mergedFileDict[file].has_key('found'):
+            if 'found' not in self.mergedFileDict[file]:
                 self.mergedFileDict[file]['found'] = []
             self.mergedFileDict[file]['found'].append('a')
-        for file in self.fileDictB.keys():
-            if file not in self.mergedFileDict.keys():
+        for file in list(self.fileDictB.keys()):
+            if file not in list(self.mergedFileDict.keys()):
                 self.mergedFileDict[file] = {} #each entry a dictionary
-            if not self.mergedFileDict[file].has_key('found'):
+            if 'found' not in self.mergedFileDict[file]:
                 self.mergedFileDict[file]['found'] = []
             self.mergedFileDict[file]['found'].append('b')
         #print self.mergedFileDict
 
     def _mergeDirs(self):
         "combine dirs from a, b into a composite"
-        for file in self.fileDictA.keys():
+        for file in list(self.fileDictA.keys()):
             relDir = self.fileDictA[file].relDir
             if relDir != None: # not toplevel dir
-                if relDir not in self.mergedDirDict.keys():
+                if relDir not in list(self.mergedDirDict.keys()):
                     self.mergedDirDict[relDir] = {}
-                if not self.mergedDirDict[relDir].has_key('found'):
+                if 'found' not in self.mergedDirDict[relDir]:
                     self.mergedDirDict[relDir]['found'] = []
                 # only need one mark for many files in this dir
                 if 'a' not in self.mergedDirDict[relDir]['found']:
                     self.mergedDirDict[relDir]['found'].append('a')
-        for file in self.fileDictB.keys():
+        for file in list(self.fileDictB.keys()):
             relDir = self.fileDictB[file].relDir
             if relDir != None: # not toplevel dir
-                if relDir not in self.mergedDirDict.keys():
+                if relDir not in list(self.mergedDirDict.keys()):
                     self.mergedDirDict[relDir] = {}
-                if not self.mergedDirDict[relDir].has_key('found'):
+                if 'found' not in self.mergedDirDict[relDir]:
                     self.mergedDirDict[relDir]['found'] = []
                 # only need one mark for many files in this dir
                 if 'b' not in self.mergedDirDict[relDir]['found']:
@@ -1232,7 +1232,7 @@
         "find each file in merged that does not have a copy in a, then b"
         self.fileMissListA = []
         self.fileMissListB = []
-        for file in self.mergedFileDict.keys():
+        for file in list(self.mergedFileDict.keys()):
             if len(self.mergedFileDict[file]['found']) == 2:
                 pass # has both
             else:
@@ -1245,7 +1245,7 @@
         "find each dir in merged that does not have a copy in a, then b"
         self.dirMissListA = []
         self.dirMissListB = []
-        for dir in self.mergedDirDict.keys():
+        for dir in list(self.mergedDirDict.keys()):
             if len(self.mergedDirDict[dir]['found']) == 2:
                 pass # has both
             else:
@@ -1301,9 +1301,9 @@
         # must be handled carefully
         if reasonInt > 0 and mostrecent == None:
             mostrecent = 'ERROR'
-            print 'ambiguity with %s' % fileObjA.relPath
-            print 'mTimeA %s mTimeB %s' % (fileObjA.mTime, fileObjB.mTime)
-            print 'cTimeA %s cTimeB %s' % (fileObjA.cTime, fileObjB.cTime)
+            print('ambiguity with %s' % fileObjA.relPath)
+            print('mTimeA %s mTimeB %s' % (fileObjA.mTime, fileObjB.mTime))
+            print('cTimeA %s cTimeB %s' % (fileObjA.cTime, fileObjB.cTime))
 
         return reasonInt, reasonList, mostrecent
 
@@ -1312,7 +1312,7 @@
         self.fileOutdateListA = [] # files outdated on a
         self.fileOutdateListB = [] # files outdated on b
 
-        for file in self.mergedFileDict.keys():
+        for file in list(self.mergedFileDict.keys()):
             if len(self.mergedFileDict[file]['found']) == 2: # has both
                 fileObjA = self.fileDictA[file]
                 fileObjB = self.fileDictB[file]
@@ -1334,7 +1334,7 @@
                 
     def _displayFileDiff(self):
         fileDiffList = [] # temporary
-        for file in self.mergedFileDict.keys():
+        for file in list(self.mergedFileDict.keys()):
             if self.mergedFileDict[file]['diff'][0] > 0: # a 
                 relPathA = self.fileDictA[file].relPath
                 relPathB = self.fileDictB[file].relPath
@@ -1424,58 +1424,58 @@
         if len(list) == 0: pass
         for entry in list:
             if drawer.isStr(entry):
-                print '\t%s' % entry
+                print('\t%s' % entry)
             else:
-                print '\t%s\n\t%s --> \n\t%s' % (entry[0], entry[1], entry[2])
+                print('\t%s\n\t%s --> \n\t%s' % (entry[0], entry[1], entry[2]))
 
     def report(self):
         self.analyze()
 
         # display all files that must be movied
-        print 'A: %s' % self.srcA
-        print 'B: %s' % self.srcB
-
-        print 'AB: (diff)'
+        print('A: %s' % self.srcA)
+        print('B: %s' % self.srcB)
+
+        print('AB: (diff)')
         self._printList(self._displayFileDiff())
 
-        print 'A: (mkdir)'
+        print('A: (mkdir)')
         self._printList(self.mkdirA)
-        print 'B to A: (cp)'
+        print('B to A: (cp)')
         self._printList(self.cpBA)
 
-        print 'B: (mkdir)'
+        print('B: (mkdir)')
         self._printList(self.mkdirB)
-        print 'A to B: (cp)'
+        print('A to B: (cp)')
         self._printList(self.cpAB)
 
         # display statistics of numbers
-        print 'A: %s' % self.srcA
-        print 'B: %s' % self.srcB
-        print '\t\t\tA\tB\tAB'
-        print 'total dirs\t\t%s\t%s\t%s' % (len(self.dirListA), 
+        print('A: %s' % self.srcA)
+        print('B: %s' % self.srcB)
+        print('\t\t\tA\tB\tAB')
+        print('total dirs\t\t%s\t%s\t%s' % (len(self.dirListA), 
                                                   len(self.dirListB),
-                                                  len(self.mergedDirDict.keys()))
-        print 'total files\t\t%s\t%s\t%s' % (len(self.fileDictA.keys()), 
-                                                    len(self.fileDictB.keys()),
-                                                    len(self.mergedFileDict.keys()))
-        print 'missing dirs\t\t%s\t%s'  % (len(self.dirMissListA), 
-                                                      len(self.dirMissListB))
-        print 'missing files\t\t%s\t%s' % (len(self.fileMissListA), 
-                                                      len(self.fileMissListB))
-        print 'outdated files\t\t%s\t%s' % (len(self.fileOutdateListA), 
-                                                            len(self.fileOutdateListB))
+                                                  len(list(self.mergedDirDict.keys()))))
+        print('total files\t\t%s\t%s\t%s' % (len(list(self.fileDictA.keys())), 
+                                                    len(list(self.fileDictB.keys())),
+                                                    len(list(self.mergedFileDict.keys()))))
+        print('missing dirs\t\t%s\t%s'  % (len(self.dirMissListA), 
+                                                      len(self.dirMissListB)))
+        print('missing files\t\t%s\t%s' % (len(self.fileMissListA), 
+                                                      len(self.fileMissListB)))
+        print('outdated files\t\t%s\t%s' % (len(self.fileOutdateListA), 
+                                                            len(self.fileOutdateListB)))
 
     def update(self):
         # self.report() # call separately
         if len(self.cpBA) > 0 or len(self.cpAB) > 0:
             ok = dialog.askYesNo('\nare you sure you want to update these files?')
             if ok != 1:
-                print 'no changes made'
+                print('no changes made')
             else:
                 self._processDir() # create dirs first
                 self._processFile()
         else:
-            print 'files and directories are up to date!'
+            print('files and directories are up to date!')
 
 
 
@@ -1523,7 +1523,7 @@
         for counter in range(numberOfTimes):
             calibrator += p.calibrate(10000)
         calibrator /= numberOfTimes
-        print calibrator
+        print(calibrator)
         return calibrator
     
     def runProfile(self, methodStr=None, statFile=None, recalibrate=1,\
@@ -1582,12 +1582,12 @@
     #-----------------------------------------------------------------------||--
     def _randStr(self):
         txt = '' # to add to files
-        for char in range(0, random.choice(range(10, 500))):
+        for char in range(0, random.choice(list(range(10, 500)))):
             txt = txt + random.choice(['a', 'b', 'c', 'd', 'e', 'f'])
         return txt
 
     def _randMutate(self, path):
-        if random.choice(range(0,99)) % 2 == 0: # if even
+        if random.choice(list(range(0,99))) % 2 == 0: # if even
             if drawer.isDarwin():
                 if random.choice([0,1]) == 1:
                     osTools.rsrcSetCreator(path, 'R*ch')
--- ./athenaCL/libATH/fontLibrary.py	(original)
+++ ./athenaCL/libATH/fontLibrary.py	(refactored)
@@ -2899,9 +2899,9 @@
 
 
 def genCharTemplate(count=2, w=15, h=8):
-    chars = fontMicro.keys()
+    chars = list(fontMicro.keys())
     chars.sort()
-    print chars
+    print(chars)
     msg = []
     for name in chars:
         msg.append('\t\t"%s" : (\n' % name)
@@ -2913,7 +2913,7 @@
                 msg.append('\n')
             else:
                 msg.append('),\n')
-    print ''.join(msg)
+    print(''.join(msg))
 
 
 
@@ -2944,9 +2944,9 @@
         elif font == 'strong':
             self.font = fontStrong
         else:
-            raise ValueError, 'no such font %r' % font
-
-        self.fontChar = fontMicro.keys()
+            raise ValueError('no such font %r' % font)
+
+        self.fontChar = list(fontMicro.keys())
         self.wFont = len(self.font['a'][0])
         self.hFont = len(self.font['a'])
 
@@ -2995,7 +2995,7 @@
         """add equal white space to each side of char"""
         bitTotal = bitWidth - self._findCharWidth(char)
         if bitTotal < 0:
-            raise ValueError, 'bitWidth is too small'
+            raise ValueError('bitWidth is too small')
         if bitTotal == 0: # already is desired width
             return char
         if bitTotal % 2 == 0: # its even
@@ -3028,7 +3028,7 @@
 
     def getChar(self, char):
         char = char.lower()
-        if char in self.font.keys():
+        if char in list(self.font.keys()):
             return self._kernChar(self.font[char])
         elif char == ' ': # get space
             return self._getSpaceChar()
@@ -3068,7 +3068,7 @@
         masterGrid = []
         for rowGrid in bitLines:
             if rowGrid == []:
-                print _MOD, 'error'
+                print(_MOD, 'error')
                 continue
             if len(rowGrid[0]) != bitWidth:
                 bitDif = bitWidth - len(rowGrid[0])
@@ -3111,7 +3111,7 @@
             rowStr = rowStr.replace(' ','')
             rowStr = rowStr.replace('1','.')
             rowStr = rowStr.replace('0',' ')
-            print rowStr
+            print(rowStr)
 
 
 
--- ./athenaCL/libATH/genetic.py	(original)
+++ ./athenaCL/libATH/genetic.py	(refactored)
@@ -354,7 +354,7 @@
                 if ogDiv == 1:
                     value = 1
                 else: # previously, add just one here
-                    value = random.choice(range(1,ogDiv))
+                    value = random.choice(list(range(1,ogDiv)))
                 ogMult = ogMult + value  
             # current value greater than one, choose add or subrtact
             else:   
@@ -362,13 +362,13 @@
                     if ogDiv == 1: # error with random if this value is one
                         value = 1
                     else:# previously, to add just one here
-                        value = random.choice(range(1,ogDiv))   
+                        value = random.choice(list(range(1,ogDiv)))   
                     ogMult = ogMult + value
                 else: # cannot subtract more than the mutliplier
                     if ogMult == 1:
                         value = 1
                     else: # previously, to add just one here
-                        value = random.choice(range(1,ogMult))   
+                        value = random.choice(list(range(1,ogMult)))   
                     ogMult = ogMult - value  # max value is ogMult-1
             self.bitVector[locus] = (ogDiv, ogMult, ogStat) 
             
@@ -482,7 +482,7 @@
         """
         maxFitness = 0 # this is the worst value
         fitnessSum = 0
-        for key in self.population.keys():
+        for key in list(self.population.keys()):
             fitnessSum = fitnessSum + self.population[key].fitness
             if self.population[key].fitness >= maxFitness:
                 maxFitness = self.population[key].fitness
@@ -519,15 +519,15 @@
         maxFitness = maxFitness * 1.5 
         
         adjustedSum = 0
-        for key in self.population.keys():
+        for key in list(self.population.keys()):
             adjustedSum = adjustedSum + int(round((maxFitness - 
                              self.population[key].fitness) * fitScaler))      
 
         #TODO: rewrite with unit.py tools        
         stopPoint = random.randint(0,adjustedSum)
         currentPoint = 0
-        chromoKeys = self.population.keys()
-        for dummykey in self.population.keys(): # keys are randomized
+        chromoKeys = list(self.population.keys())
+        for dummykey in list(self.population.keys()): # keys are randomized
             key = random.choice(chromoKeys)
             keyPosition = chromoKeys.index(key)
             del chromoKeys[keyPosition]
@@ -577,7 +577,7 @@
 
     def _sortPopulation(self):      
         sortList = []
-        for key in self.population.keys():
+        for key in list(self.population.keys()):
             sortList.append((self.population[key].fitness, key))
         sortList.sort()
         #sortList.reverse()
@@ -609,7 +609,7 @@
         j = 0
         while j < maxIndex:
             # there is another offspring avaiable
-            if (j+1) in offspringDict.keys(): 
+            if (j+1) in list(offspringDict.keys()): 
                 chromoA = offspringDict[j]
                 chromoB = offspringDict[j+1]
                 locus = 0
@@ -664,7 +664,7 @@
         for entry in offspringList:
             offspringDict[i] = entry
             i = i + 1
-        for key in offspringDict.keys():
+        for key in list(offspringDict.keys()):
             chromo = offspringDict[key]
             locus = 0
             if (random.randint(0,9999) / 10000.0) < self.crossoverRate:
@@ -880,7 +880,7 @@
         self.ga.crossoverRate = crossoverRate
         
     def clear(self):
-        for key in self.ga.population.keys():
+        for key in list(self.ga.population.keys()):
             self.ga.population[key].randomize()
         self.genCounter = 0
         self.lastBestBitVector = []
--- ./athenaCL/libATH/grammar.py	(original)
+++ ./athenaCL/libATH/grammar.py	(refactored)
@@ -192,7 +192,7 @@
 
         """
         self._rules = {} # this always clears the last rules
-        for key, value in pairRule.items():
+        for key, value in list(pairRule.items()):
             # make value into a src:dst pairs
             ruleList = []
             weights = value.split(self.ASSIGNDELIMIT) # this is the |
@@ -232,7 +232,7 @@
     def _parseAxiom(self, axiomSrc=None):
         """Call this after all symbols have been found
         """
-        knownSym = self._symbols.keys()
+        knownSym = list(self._symbols.keys())
         if axiomSrc != None:
             # NOTE: assumes no delimiters between symbols
             axiomSrc = axiomSrc.strip()
@@ -263,8 +263,7 @@
         """
         for char in symStr:
             if char not in self.SYM:
-                raise error.TransitionSyntaxError,\
-                "symbol definition uses illegal characters (%s)" % char
+                raise error.TransitionSyntaxError("symbol definition uses illegal characters (%s)" % char)
 
     def _checkSymbolFormRuleKey(self, symStr):
         """makes sure that symbol usage is valid for weight label keys
@@ -301,8 +300,8 @@
          """
         self._maxRuleOutputSize = 0
 
-        knownSym = self._symbols.keys()
-        for inRule, outRule in self._rules.items():
+        knownSym = list(self._symbols.keys())
+        for inRule, outRule in list(self._rules.items()):
             #environment.printDebug(['in rule, out rule', inRule, outRule])
             environment.printDebug(['in rule', repr(inRule), 'out rule', outRule])
 
@@ -343,7 +342,7 @@
                 if not match:
                     break
             if not match:
-                raise error.TransitionSyntaxError, "destination rule component (%s) references an undefined symbol" % outRule
+                raise error.TransitionSyntaxError("destination rule component (%s) references an undefined symbol" % outRule)
     
 
     #-----------------------------------------------------------------------||--
@@ -450,7 +449,7 @@
         >>> g._valueToSymbol('4') # everything is a string
         'b'
         """
-        for s, v in self._symbols.items():
+        for s, v in list(self._symbols.items()):
             if str(value) == v:
                 return s
         raise ValueError('value (%s) not known as a symbol' % value)
@@ -481,7 +480,7 @@
         >>> g._symbolToValue('a') # everything is a string
         3.0
         """
-        for s, v in self._symbols.items():
+        for s, v in list(self._symbols.items()):
             if value == s:
                 if drawer.isCharNum(v):
                     return float(v)
@@ -540,11 +539,11 @@
         """
         # do symbol list first
         msg = []
-        syms = self._sortSymbolLabel(self._symbols.items())
+        syms = self._sortSymbolLabel(list(self._symbols.items()))
         for s, data in syms:
             msg.append('%s%s%s%s' % (s, self.OPEN, data, self.CLOSE))
         msg.append(self.SPLIT)
-        for src, dst in self._rules.items():
+        for src, dst in list(self._rules.items()):
             sub = []
             if len(dst) > 1:
                 for part, weight in dst:
@@ -579,7 +578,7 @@
         return '<%s>' % input
         
 
-    def next(self):
+    def __next__(self):
         '''Apply all rules and produce a new self._state
 
         >>> g = Grammar()
@@ -649,7 +648,7 @@
                 if pair not in indexCharPairs:
                     indexCharPairs.append(pair) 
 
-        for inRule, outRule in self._rules.items():
+        for inRule, outRule in list(self._rules.items()):
 
             environment.printDebug(['next(): in/out rule', repr(inRule), outRule])
             # grammar.py: next(): in/out rule '*' [('ab',1)] 
@@ -763,66 +762,66 @@
 
         g = Grammar()
         g.load('a{3}b{4} @ a{bab}b{aab} @ a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'bab')
         g.reset()
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'bab')
         g.setAxiom('b')
         self.assertEqual(g.getState(), 'b')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aab')
 
         g.setAxiom('ab')
         self.assertEqual(g.getState(), 'ab')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'babaab')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aabbabaabbabbabaab')
 
 
         # simple oscillation
         g = Grammar()
         g.load('a{3}b{4} @ a{b}b{a} @ a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'b')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'b')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'a')
 
 
         # simple oscillation
         g = Grammar()
         g.load('a{3}b{4} @ a{b}b{a} @ a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'b')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'b')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'a')
 
 
         # decomposition: can we decompose
         g = Grammar()
         g.load('a{3}b{4} @ a{b}b{}{a} @ a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'b')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), '')
-        g.next()
+        next(g)
         # for now, this replaces with the axiom
         self.assertEqual(g.getState(), 'b')
 
         g = Grammar()
         g.load('a{3}b{4} @ a{bab}b{} @ bbabbabb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'babbab')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'babbab')
 
 
@@ -830,40 +829,40 @@
         # try context matches: can match one to many
         g = Grammar()
         g.load('a{3}b{4} @ aa{bb}bb{aaaa} @ bb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaaa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'bbbb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaaaaaaa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'bbbbbbbb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaaaaaaaaaaaaaaa')
 
         g = Grammar()
         g.load('a{3}b{4} @ aaa{aba}aba{bbb}bbb{aaa} @ bbb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aba')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'bbb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaa')
-        g.next()
+        next(g)
 
         g = Grammar()
         g.load('a{3}b{4} @ aaa{aba}aba{bbb}bbb{aaa} @ bbbbbb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaaaaa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'abaaba')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'bbbbbb')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aaaaaa')
-        g.next()
+        next(g)
 
 
     def testWeighted(self):
@@ -871,11 +870,11 @@
         # can use pipe to define equal probabilistic options
         g = Grammar()
         g.load('a{3}b{4} @ a{b|a}b{a|b} @ a')
-        g.next()
+        next(g)
         self.assertEqual(g.getState() in ['a', 'b'], True)
-        g.next()
+        next(g)
         self.assertEqual(g.getState() in ['a', 'b'], True)
-        g.next()
+        next(g)
         self.assertEqual(g.getState() in ['a', 'b'], True)
 
 
@@ -885,7 +884,7 @@
         post = []
         for x in range(100):
             post.append(g.getState())
-            g.next()
+            next(g)
         # probabilistic weighting favoring b
         self.assertEqual(post.count('b') > 70, True)
 
@@ -901,53 +900,53 @@
         g = Grammar()
         g.load('a{1}b{5}c{10} @ *{ab} @ a')
 
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'ab')
 
 
         # partial matches with *
         g = Grammar()
         g.load('a{1}b{5}c{10} @ a*{ab} @ aa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'ab')
 
         g = Grammar()
         g.load('a{1}b{5}c{10} @ **{ab} @ aa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'ab')
 
         g = Grammar()
         g.load('a{1}b{5}c{10} @ b*{ab} @ ba')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'ab')
 
         g = Grammar()
         g.load('a{1}b{5}c{10} @ *a{cc} @ ba')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'cc')
 
 
         g = Grammar()
         g.load('a{1}b{5}c{10} @ *a{cc} c*{aa} @ cc')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'cc')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'aa')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'cc')
     
 
         g = Grammar()
         g.load('a{1}b{5}c{10} @ a*c{ccc} *c*{abc} @ abc')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'ccc')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'abc')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'ccc')
-        g.next()
+        next(g)
         self.assertEqual(g.getState(), 'abc')
 
 
--- ./athenaCL/libATH/help.py	(original)
+++ ./athenaCL/libATH/help.py	(refactored)
@@ -648,7 +648,7 @@
                 doc = getattr(self, name)
                 filter.append([name, doc]) 
             # if in gloss, search for synonymes
-            elif name in self.__glossIndex.keys():
+            elif name in list(self.__glossIndex.keys()):
                 for altName in self.__glossIndex[name]['syn']:
                     if searchStr in altName or altName in searchStr:
                         doc = getattr(self, name)
@@ -696,7 +696,7 @@
             # this searches all attributes of help, all gloss and synonym entries
             filter = self.searchRef(searchStr)
             for name, doc in filter:
-                if name in self.__glossIndex.keys():
+                if name in list(self.__glossIndex.keys()):
                     title = self.__glossIndex[name]['title']
                 # alter usage attributes with a predictable title
                 # will add usage documentation to command documentation
--- ./athenaCL/libATH/htmlTools.py	(original)
+++ ./athenaCL/libATH/htmlTools.py	(refactored)
@@ -15,7 +15,7 @@
 
 # optional modules
 try:
-    from HTMLParser import HTMLParser
+    from html.parser import HTMLParser
 except ImportError:
     pass
 
@@ -87,7 +87,7 @@
         self.colorDict['hr']        = '#999999'
 
         if colorDict != None: # assign
-            for key in colorDict.keys():
+            for key in list(colorDict.keys()):
                 self.colorDict[key] = colorDict[key] # set new values
 
     def setFontDict(self, fontDict=None):
@@ -100,7 +100,7 @@
         self.fontDict['mon'] = 6
 
         if fontDict != None:
-            for key in fontDict.keys():
+            for key in list(fontDict.keys()):
                 self.fontDict[key] = fontDict[key] # set new values
 
         
@@ -306,7 +306,7 @@
     def __call__(self, parentDir, ext='.gif', group=None, groupMax=None):
         if group == None:
             group = '_'
-        if group not in self.fileNames.keys():
+        if group not in list(self.fileNames.keys()):
             self.fileNames[group] = []
         # seems like this should only happen if groupMax is not
         # None, but not sure
@@ -335,7 +335,7 @@
         appends each time called"""
         group = '_local'
         groupMax = 999
-        if not self.fileNames.has_key(group):
+        if group not in self.fileNames:
             self.fileNames[group] = []
             self.groupMax[group] = groupMax
 
@@ -345,7 +345,7 @@
 
     def report(self):
         allPaths = []
-        for group in self.fileNames.keys():
+        for group in list(self.fileNames.keys()):
             allPaths = allPaths + self.fileNames[group]
         return allPaths
 
@@ -359,7 +359,7 @@
     def script(self):
         headScript = '<script>\n<!--\nif (document.images) {\n'
 
-        sortedKeys = self.imageDict.keys()
+        sortedKeys = list(self.imageDict.keys())
         sortedKeys.sort()
 
         for key in sortedKeys: # key is a number
@@ -389,7 +389,7 @@
         return headScript
 
     def idList(self): # id numbers, with 1 offset
-        return self.imageDict.keys()
+        return list(self.imageDict.keys())
 
     def linkImage(self, id, postBreaks=0):
         imageName = 'image%s' % id 
@@ -944,15 +944,15 @@
     def _updateColData(self, colData):
         """provides backward compat for col data"""
             # backward compat
-        if not colData.has_key('outline'):
+        if 'outline' not in colData:
             colData['outline'] = '' # a string w / chars = 'lrtb'
-        if not colData.has_key('outlineWidth'):
+        if 'outlineWidth' not in colData:
             colData['outlineWidth'] = 1 # a string w / chars = 'lrtb'
-        if not colData.has_key('outlineColor'):
+        if 'outlineColor' not in colData:
             colData['outlineColor'] = '#000000' # a string w / chars = 'lrtb'
-        if not colData.has_key('pad'):
+        if 'pad' not in colData:
             colData['pad'] = 0 # can be vert, horiz, both
-        if not colData.has_key('color'):
+        if 'color' not in colData:
             colData['color'] = None # none
         return colData
 
@@ -1188,9 +1188,9 @@
                      'December':'Dec',
                      }
 
-        for key, value in dayRef.items():
+        for key, value in list(dayRef.items()):
             dateStr = dateStr.replace(key, value)
-        for key, value in monthRef.items():
+        for key, value in list(monthRef.items()):
             dateStr = dateStr.replace(key, value)
 
         # remove empty time designations
@@ -1211,7 +1211,7 @@
 
         msg.append("""<FORM NAME="menu">
  <SELECT NAME="%s" size="1" onChange="if (this.options[selectedIndex].value != '') location.href=this.options[selectedIndex].value" style="width: 110; font-size: 10px">
-""" % ('links' + str(random.choice(range(0,100)))))
+""" % ('links' + str(random.choice(list(range(0,100))))))
         for entry in optionPairs:
             url = entry[0]
             label = entry[1]
@@ -1302,7 +1302,7 @@
                      # '128 kbs' : [128000, 0, ''],
                         '512 kbs' : [512000, 0, ''],
                         }
-        for key in timeDict.keys():
+        for key in list(timeDict.keys()):
             entry = timeDict[key]
             speed = entry[0] # first is speed
             time = size / speed
@@ -1365,7 +1365,7 @@
         b.append(self.BR*2)
         for audioDict in audioRef:
             if titleLinkSwitch == 'name':
-                if 'title' in audioDict.keys():
+                if 'title' in list(audioDict.keys()):
                     titleLink = audioDict['title']
                 else:
                     titleLink = 'Audio File Information'
@@ -1444,7 +1444,7 @@
         msg.append(self.htmlClose)
 
         if htmlPath == None: ## this should be printed
-            print ''.join(msg)
+            print(''.join(msg))
         else:
             f = open(htmlPath, 'w')
             f.writelines(msg)        
@@ -1456,7 +1456,7 @@
         "if no html path (None) prints page to stdout"
         msg = self.refreshPage(dst) # gets a tring
         if htmlPath == None: ## this should be printed
-            print ''.join(msg)
+            print(''.join(msg))
         else:
             f = open(htmlPath, 'w')
             f.write(msg)      
@@ -1467,7 +1467,7 @@
         "if no html path (None) prints page to stdout"
         msg = self.framePage(sizeList, pathList, nameList) # use default
         if htmlPath == None: ## this should be printed
-            print ''.join(msg)
+            print(''.join(msg))
         else:
             f = open(htmlPath, 'w')
             f.write(msg)      
@@ -1479,7 +1479,7 @@
 # various html/online client functions
 def getWeather(displayFmt='print'):
     """display can be print or str"""
-    import urllib   # Library for retrieving files using a URL.
+    import urllib.request, urllib.parse, urllib.error   # Library for retrieving files using a URL.
     import re       # Library for finding patterns in text.
     
     locDict = {
@@ -1492,14 +1492,14 @@
     # Open and read the web page.
     MAX_PAGE_LEN = 20000 
     msg = []
-    keys = locDict.keys()
+    keys = list(locDict.keys())
     keys.sort()
     for locStr in keys:
         url = locDict[locStr]
         try:
-            webpage = urllib.urlopen(url).read(MAX_PAGE_LEN)
+            webpage = urllib.request.urlopen(url).read(MAX_PAGE_LEN)
         # An I/O error occurred; print the error message and exit.
-        except IOError, e: 
+        except IOError as e: 
             msg.append('I/O error (%s): ' % locStr, e.strerror )
             webpage = None
         # Pattern which matches text like '66.9 F'. The last
@@ -1513,7 +1513,7 @@
                                                               matchF.group(1).ljust(4), 
                                                               matchC.group(1).ljust(4)))
     if displayFmt == 'print':
-        print ''.join(msg)
+        print(''.join(msg))
     else:
         return ''.join(msg)
 
@@ -1543,12 +1543,12 @@
             self.hrefOpen = 0
 
 def getLinks(url):
-    import urllib
+    import urllib.request, urllib.parse, urllib.error
     parser = LinkParser()
     try:
-        parser.feed(urllib.urlopen(url).read())
-    except Exception, e:
-        print '%s: %s\n' % (e, url)
+        parser.feed(urllib.request.urlopen(url).read())
+    except Exception as e:
+        print('%s: %s\n' % (e, url))
         return
     parser.close()
     if not parser.hrefs:
--- ./athenaCL/libATH/imageTools.py	(original)
+++ ./athenaCL/libATH/imageTools.py	(refactored)
@@ -32,7 +32,7 @@
 except ImportError:
     PIL = 0
 try:
-    import Tkinter
+    import tkinter
     TK = 1
 except ImportError:
     TK = 0
@@ -75,7 +75,7 @@
     colorstring = colorstring.strip()
     if colorstring[0] == '#': colorstring = colorstring[1:]
     if len(colorstring) != 6:
-        raise ValueError, "input #%s is not in #RRGGBB format" % colorstring
+        raise ValueError("input #%s is not in #RRGGBB format" % colorstring)
     r, g, b = colorstring[:2], colorstring[2:4], colorstring[4:]
     r, g, b = [int(n, 16) for n in (r, g, b)]
     return (r, g, b)
@@ -167,7 +167,8 @@
     'times' : ('timB', 'timBI', 'timI', 'timR'),
     }
 
-def getFontPath((face, style, size)): # dont check for errrs
+def getFontPath(xxx_todo_changeme): # dont check for errrs
+    (face, style, size) = xxx_todo_changeme
     for n in fontLibPil[face]:
         if style in n or style == n:
             group = n
@@ -207,23 +208,23 @@
                 outfile = os.path.splitext(infile)[0] + ".th%s%s" % (
                                                               self.sizeW, self.fmt)
             if infile.endswith('.gif'):
-                print _MOD, 'cannot process gif files: %s' % infile
+                print(_MOD, 'cannot process gif files: %s' % infile)
             elif outfile in nameOutFiles:
-                print _MOD, 'file already generated: %s' % outfile
+                print(_MOD, 'file already generated: %s' % outfile)
             elif infile != outfile:
                 try:
                     im = Image.open(infile)
                     if self.sizeW != None: # only resize if size is not None
-                        print _MOD, 'reducing size to %s' % self.sizeW
+                        print(_MOD, 'reducing size to %s' % self.sizeW)
                         im.thumbnail((self.sizeW, self.sizeH), Image.ANTIALIAS)
                     #im.save(outfile, "JPEG")
                     im.save(outfile)
                     procFiles.append([infile, outfile])
                     nameOutFiles.append(outfile)
-                except IOError, msg:
-                    print _MOD, "cannot create thumbnail: %s" % infile, msg 
+                except IOError as msg:
+                    print(_MOD, "cannot create thumbnail: %s" % infile, msg) 
             else:
-                print _MOD, 'name conflict: %s' % infile
+                print(_MOD, 'name conflict: %s' % infile)
         return procFiles
 
 
@@ -327,7 +328,7 @@
     def __init__(self, src=None, width=120, foreColor='#000000', 
                           backColor='#aaaaaa', xMult=1, yMult=1, horizontal=1):
         if width == None and src == None:
-            raise ValueError, 'not enough arguments'
+            raise ValueError('not enough arguments')
         #foreColor can be a list of colors that are chosen from at random
         if not drawer.isList(foreColor):
             foreColor = [foreColor,]
@@ -541,7 +542,7 @@
                                          4, 4, 1, wrapW)
 
         else:
-            raise KeyError, 'no such style name %r' % style
+            raise KeyError('no such style name %r' % style)
 
     def write(self, filePath):
         self.image.write(filePath)
@@ -645,19 +646,19 @@
 
     def __init__(self, w, h, bg, name, master):
         if not TK:
-            raise ImportError, 'Tkinter not loaded'
+            raise ImportError('Tkinter not loaded')
         _CanvasBase.__init__(self, w, h, bg, 'tk', name)
         if master == None:
-            self.master = Tkinter.Tk()
+            self.master = tkinter.Tk()
         else:
             self.master = master
         # not sure this is needed
         #self.top = Tkinter.Toplevel() # create a top level?
-        self.frame = Tkinter.Frame(self.master, width=self.w, height=self.h, bd=0,
+        self.frame = tkinter.Frame(self.master, width=self.w, height=self.h, bd=0,
                                      bg=self.bg, relief='flat')
         self.frame.pack(fill='both', pady=0, padx=0)
         # create base canvas
-        self.c = Tkinter.Canvas(self.frame, bg=self.bg, bd=0, width=self.w, 
+        self.c = tkinter.Canvas(self.frame, bg=self.bg, bd=0, width=self.w, 
                     height=self.h, highlightthickness=0, 
                     closeenough=1, confine=1)
         self.c.pack(fill='both', pady=0, padx=0) 
@@ -1232,7 +1233,7 @@
     elif fmt == 'eps':
         obj = EpsCanvas(w, h, bg, name)
     else:
-        raise ValueError, 'bad canvas format type: %s' % fmt
+        raise ValueError('bad canvas format type: %s' % fmt)
     return obj
 
 
@@ -1282,7 +1283,7 @@
         """
         self.xRangeLib = {}
         self.yRangeLib = {}
-        for key in self.dataLib.keys():
+        for key in list(self.dataLib.keys()):
             xMax = self.dataLib[key][0][0] # seed w/ values from data
             xMin = self.dataLib[key][0][0]
             yMax = self.dataLib[key][0][1]
@@ -1356,7 +1357,7 @@
     def _findAxis(self):
         self.xAxisLib = {}
         self.yAxisLib = {}
-        for key in self.dataLib.keys():
+        for key in list(self.dataLib.keys()):
             self.xAxisLib[key] = self._genAxis(self.xRangeLib[key][0], 
                                         self.xRangeLib[key][1], self.xRez, 'x')
             self.yAxisLib[key] = self._genAxis(self.yRangeLib[key][0], 
@@ -1390,7 +1391,7 @@
                         return i + 1
                     elif upper == lower: # equal?
                         return i # round to lower?
-                    else: print _MOD, 'x error'
+                    else: print(_MOD, 'x error')
             elif side == 'y': # greater to lesser values
                 if value == axis[i]:
                     return i
@@ -1405,7 +1406,7 @@
                         return i + 1
                     elif upper == lower: # equal?
                         return i # round to lower?
-                    else: print _MOD, 'y error'
+                    else: print(_MOD, 'y error')
 
     def _findPlot(self):
         """create a bit map based on resolution
@@ -1416,7 +1417,7 @@
         method to get values out in old format"""
         self.plotLib = [] # used to be a dictionary
         # each key represents a color/symbol/fill-pattern group
-        for key in self.dataLib.keys():
+        for key in list(self.dataLib.keys()):
             for data in self.dataLib[key]:
                 if self.dataMode == 'point':
                     x, y = data
@@ -1446,7 +1447,7 @@
         """
         self.bitLib = {} # this is like the old plotLib format
         # build empty double array
-        for key in self.dataLib.keys():
+        for key in list(self.dataLib.keys()):
             self.bitLib[key] = []
             for y in range(self.yRez): # replace w/ array?
                 row = array.array('i')
@@ -1476,7 +1477,7 @@
         return self.plotLib
     
     def keys(self):
-        return self.dataLib.keys()
+        return list(self.dataLib.keys())
     
     def gridKey(self, key, side='x', lines=3):
         """returns a grid key for this axis
@@ -2057,7 +2058,7 @@
     this graph is used for TImap and TPmap displays"""
     def __init__(self, dataObj=None, origin=(0,0)):
     
-        groupKey = dataObj.keys()[0] # take first key, will be 1
+        groupKey = list(dataObj.keys())[0] # take first key, will be 1
         # graph base wants a bit-map of enter data to be written
         _GraphBase.__init__(self, dataObj.xRez, dataObj.yRez, 
                                   dataObj.getPlotLib(), origin)
@@ -2137,7 +2138,7 @@
     now; may be real-value x,y pairs or x,y,x,y quads"""
     def __init__(self, dataObj=None, origin=(0,0)):
     
-        groupKey = dataObj.keys()[0] # take first key, will be 1
+        groupKey = list(dataObj.keys())[0] # take first key, will be 1
         # will assign self.plotLib
         _GraphBase.__init__(self, dataObj.xRez, dataObj.yRez, 
                                   dataObj.getPlotLib(), origin)
@@ -2350,7 +2351,7 @@
         fmtList = ['tk', 'png', 'eps']
         import time
         for fmt in fmtList:
-            print _MOD, 'testing format', fmt
+            print(_MOD, 'testing format', fmt)
             a = Canvas(fmt, 200, 200)
             a.rectangle(10, 10, 120, 120, '#333333', '#ffffff', 5)
             a.rectangle(150, 150, 180, 180, None, '#ffffff', 2)
--- ./athenaCL/libATH/info.py	(original)
+++ ./athenaCL/libATH/info.py	(refactored)
@@ -335,7 +335,7 @@
         f = open(self.fpReadme, 'w')
         f.write(''.join(msg))     
         f.close()  
-        print 'info.py: writing %s' % self.fpReadme
+        print('info.py: writing %s' % self.fpReadme)
 
 
     #-----------------------------------------------------------------------||--
@@ -503,7 +503,7 @@
 .Sh OPTIONS
 .Bl -tag -width flag""")
 
-        for key in flagsRef.keys():
+        for key in list(flagsRef.keys()):
             flagStr = ', '.join(key) # key is a list
             msg.append('\n.It Cm %s\n' % flagStr)
             msg.append('%s' % flagsRef[key])
@@ -521,7 +521,7 @@
 .Nm
 is %s <%s>."""    % (lang.msgBugReport, lang.msgAuthor, lang.msgAuthorEmail))
 
-        print 'info.py: writing %s' % self.fpMan
+        print('info.py: writing %s' % self.fpMan)
 
         f = open(self.fpMan, 'w')
         f.writelines(msg)        
--- ./athenaCL/libATH/ioTools.py	(original)
+++ ./athenaCL/libATH/ioTools.py	(refactored)
@@ -55,7 +55,7 @@
 def _evalRecurse(data):
     """recursively evaluate data in dictionaries; if data is a string, 
     dont evaluate if data is a dict, recurse"""
-    keyList = data.keys()
+    keyList = list(data.keys())
     for key in keyList:
         if drawer.isDict(data[key]):
             _evalRecurse(data[key])
@@ -153,8 +153,8 @@
     def _pre140_pmtrObjUpdates(self):
         """minor fixes to old parameterObjects"""
         t = self.tData
-        for tName in t['textureLib'].keys():
-            for pmtrKey in t['textureLib'][tName]['pmtrQDict'].keys():
+        for tName in list(t['textureLib'].keys()):
+            for pmtrKey in list(t['textureLib'][tName]['pmtrQDict'].keys()):
                 arg = t['textureLib'][tName]['pmtrQDict'][pmtrKey]   
                 newArgs = tuple(self._recursiveUpdate(arg))
                 if newArgs != arg: # a change has been made
@@ -180,8 +180,8 @@
     def _pre144_pmtrObjUpdates(self):
         """minor fixes to old parameterObjects"""
         t = self.tData
-        for tName in t['textureLib'].keys():
-            for pmtrKey in t['textureLib'][tName]['pmtrQDict'].keys():
+        for tName in list(t['textureLib'].keys()):
+            for pmtrKey in list(t['textureLib'][tName]['pmtrQDict'].keys()):
                 arg = t['textureLib'][tName]['pmtrQDict'][pmtrKey]   
                 # do alterations to textureStatic
                 replacePairs = [('nonRedundantSwitch', 'pitchSelectorControl'), 
@@ -201,21 +201,21 @@
         this causes errors elsewhere, and his been fixed
         this method looks a the aux and removes any extra aux like things"""
         t = self.tData
-        for tName in t['textureLib'].keys():
+        for tName in list(t['textureLib'].keys()):
             auxNo = t['textureLib'][tName]['auxNo']
             # store all valid
             auxLabelValid = basePmtr.auxLabel(auxNo)
-            for pmtrKey in t['textureLib'][tName]['pmtrQDict'].keys():           
+            for pmtrKey in list(t['textureLib'][tName]['pmtrQDict'].keys()):           
                 if pmtrKey not in auxLabelValid: # not a valid auxq
                     if pmtrKey[:4] == 'auxQ': # if it looks like an auxq
                         del t['textureLib'][tName]['pmtrQDict'][pmtrKey]
                         environment.printDebug(['removed extra auxQ:', pmtrKey])
         # clear extra clone aux as well
-        for cName in t['cloneLib'].keys():
+        for cName in list(t['cloneLib'].keys()):
             auxNo = t['cloneLib'][cName]['auxNo']
             # store all valid
             auxLabelValid = basePmtr.auxLabel(auxNo)
-            for pmtrKey in t['cloneLib'][cName]['pmtrQDict'].keys():              
+            for pmtrKey in list(t['cloneLib'][cName]['pmtrQDict'].keys()):              
                 if pmtrKey not in auxLabelValid: # not a valid auxq
                     if pmtrKey[:4] == 'auxQ': # if it looks like an auxq
                         del t['cloneLib'][cName]['pmtrQDict'][pmtrKey]
@@ -227,10 +227,10 @@
         smaller aux value, extra Q keys exist that should not by the aux count
         this causes errors elsewhere, and his been fixed
         this method looks a the aux and removes any extra aux like things"""
-        if 'nchnls' in self.aData.keys():
+        if 'nchnls' in list(self.aData.keys()):
             self.aData['audioChannels'] = self.aData['nchnls']
             del self.aData['nchnls']
-        if 'audioRate' not in self.aData.keys():
+        if 'audioRate' not in list(self.aData.keys()):
             self.aData['audioRate'] = 44100
 
     #-----------------------------------------------------------------------||--
--- ./athenaCL/libATH/language.py	(original)
+++ ./athenaCL/libATH/language.py	(refactored)
@@ -32,13 +32,13 @@
 
         self.errorStr = 'missing string (%s)'
 
-        if self.language not in self.langDict.keys():
-            raise ValueError, 'no such language'
+        if self.language not in list(self.langDict.keys()):
+            raise ValueError('no such language')
 
     def __getattr__(self, name):
         # language can be dynamically changed.
-        if self.language not in self.langDict.keys():
-            raise ValueError, 'no such language'
+        if self.language not in list(self.langDict.keys()):
+            raise ValueError('no such language')
 
         if self.language == 'en': # en should have all strings
             try:
--- ./athenaCL/libATH/markov.py	(original)
+++ ./athenaCL/libATH/markov.py	(refactored)
@@ -90,7 +90,7 @@
     #-----------------------------------------------------------------------||--
     def _sortWeightKey(self, dict):
         """sort transition keys by size first"""
-        keys = dict.keys()
+        keys = list(dict.keys())
         keys.sort()
         # sort keys by length
         ord = []
@@ -121,7 +121,7 @@
     def _parseValidate(self, usrStr):
         """make sure the the string appears correct"""
         if usrStr.count(self.OPEN) != usrStr.count(self.CLOSE):
-            raise error.TransitionSyntaxError, "all braces not paired"
+            raise error.TransitionSyntaxError("all braces not paired")
 
     def _parseWeightKey(self, key):
         """ make key into a list of symbol strings
@@ -162,7 +162,7 @@
                 keyFinal.append(segment) # make it a tuple before return
             elif len(keyPost) > 1:
                 msg = "only one operator may be used per weight key segment"
-                raise error.TransitionSyntaxError, msg
+                raise error.TransitionSyntaxError(msg)
             # definitial an expression, pack new tuple, leading with expression op
             # if it is an or sym, need to split by this symbol
             else:
@@ -181,7 +181,7 @@
         """read a complete dictionary of transition keys and weights, 
         and load weights as a list"""
         self._weightSrc = {} 
-        for key, value in pairWeight.items():
+        for key, value in list(pairWeight.items()):
             # make key into a list of symbol strings
             key = self._parseWeightKey(key)
             # make value into a list of pairs
@@ -190,8 +190,7 @@
             for assign in weights:
                 if self.ASSIGN not in assign: continue
                 if assign.count(self.ASSIGN) > 1: # bad syntax or other error
-                    raise error.TransitionSyntaxError, \
-                            "incorrect weight specification: %s" % assign
+                    raise error.TransitionSyntaxError("incorrect weight specification: %s" % assign)
                 symbol, w = assign.split(self.ASSIGN)
                 # convert to float or int, may not be less tn zero
                 # will return None on error
@@ -200,8 +199,7 @@
                 # side-effects; need to test in whole
                 # not defining all weights is permitted
                 if w in (None, 0): # no zero weights, or other errors
-                    raise error.TransitionSyntaxError, \
-                            "bad weight value given: %s" % assign
+                    raise error.TransitionSyntaxError("bad weight value given: %s" % assign)
                 weightList.append((symbol, w))
             # assign to weight src
             self._weightSrc[key] = weightList 
@@ -209,8 +207,8 @@
     def _checkSymbolUsage(self):
         """check to see if all symbols used in weight keys are in symbol list
         also update orders; this fills _ordersSrc"""
-        symbols = self._symbols.keys()
-        for key in self._weightSrc.keys():
+        symbols = list(self._symbols.keys())
+        for key in list(self._weightSrc.keys()):
             ord = len(key) # a zero key will be an empty tuple
             if ord not in self._ordersSrc: 
                 self._ordersSrc.append(ord) # len of weight label is order
@@ -219,8 +217,7 @@
             for w in weights:
                 # weights are always symbol, number pairs
                 if w[0] not in symbols:
-                    raise error.TransitionSyntaxError,\
-                            "weight specified for undefined symbol: %s" % w[0]
+                    raise error.TransitionSyntaxError("weight specified for undefined symbol: %s" % w[0])
         # sort order list             
         self._ordersSrc.sort()
                 
@@ -229,8 +226,7 @@
         symbols cannot have spaces, case, or strange characters"""
         for char in symStr:
             if char not in self.SYM:
-                raise error.TransitionSyntaxError,\
-                "symbol definition uses illegal characters (%s)" % char
+                raise error.TransitionSyntaxError("symbol definition uses illegal characters (%s)" % char)
 
     def _checkSymbolFormWeightKey(self, symStr):
         """makes sure that symbol usage is valid for weight label keys
@@ -238,8 +234,7 @@
         valid = self.SYM + self.STEP + ''.join(self.EXPRESS)
         for char in symStr:
             if char not in valid:
-                raise error.TransitionSyntaxError,\
-                "symbol definition uses illegal characters (%s)" % char
+                raise error.TransitionSyntaxError("symbol definition uses illegal characters (%s)" % char)
                 
     def _parseClean(self, usrStr):
         """remove any unusual characters that migth appear"""
@@ -274,7 +269,7 @@
             try:
                 key, value = double.split(self.OPEN)
             except: # possible syntax error in formationi
-                raise error.TransitionSyntaxError, "badly placed delimiters"
+                raise error.TransitionSyntaxError("badly placed delimiters")
             # key is always a symbol def: will change case and remove spaces
             key = drawer.strScrub(key, 'lower', [' ']) # rm spaces from key
             # split into 2 dictionaries, one w/ symbol defs, one w/ weights
@@ -288,11 +283,11 @@
                 pairSymbol[key] = drawer.strScrub(value, None, [' ']) 
         # this initializes symbol table
         if pairSymbol == {}:
-            raise error.TransitionSyntaxError, "no symbols defined"
+            raise error.TransitionSyntaxError("no symbols defined")
         self._symbols = pairSymbol
         # pass the pair dictionary to weight parser
         if pairWeight == {}:
-            raise error.TransitionSyntaxError, "no weights defined"
+            raise error.TransitionSyntaxError("no weights defined")
         self._parseWeightValue(pairWeight)
         # check symbol usage and determine orders
         self._checkSymbolUsage()
@@ -301,9 +296,9 @@
     #-----------------------------------------------------------------------||--         
     def _valueToSymbol(self, value):
         """for a data value, return the defined symbol label"""
-        for s, v in self._symbols.items():
+        for s, v in list(self._symbols.items()):
             if value == v: return s
-        raise ValueError, 'value not known as Transition symbol'
+        raise ValueError('value not known as Transition symbol')
             
     def _valueListToSymbolList(self, valueList):
         """given a list of values (taken from an previous generated values)
@@ -321,7 +316,7 @@
     def _analyzeZero(self, data):
         """assumes symbols are defined"""
         self._weightSrc[()] = [] # key is empty tuple
-        for sym in self._symbols.keys():
+        for sym in list(self._symbols.keys()):
             value = self._symbols[sym]
             self._weightSrc[()].append((sym, data.count(value)))
             
@@ -354,7 +349,7 @@
         if wrap:
             data = data + data[:order]            
             
-        symbols = self._symbols.keys()
+        symbols = list(self._symbols.keys())
         trans = permutate.selections(symbols, order)              
         # go through all transition possibilities for this order          
         for t in trans: 
@@ -483,7 +478,7 @@
         """provide a complete transition string"""
         # do symbol list first
         msg = []
-        syms = self._sortSymbolLabel(self._symbols.items())
+        syms = self._sortSymbolLabel(list(self._symbols.items()))
         for s, data in syms:
             msg.append('%s%s%s%s' % (s, self.OPEN, data, self.CLOSE))
         # determin where to get weight keys, from src or post
@@ -539,11 +534,11 @@
     def getSignified(self):
         """return symbol values as a list; useful for checking type and quality
         of possible outptus"""
-        return self._symbols.values()
+        return list(self._symbols.values())
 
     def getItems(self):
         """get key, value pairs from sybol dict"""
-        return self._symbols.items()
+        return list(self._symbols.items())
 
     def getOrderMax(self):
         """get highest specified order values"""
@@ -558,11 +553,11 @@
         and qual distribution when srubbed)"""
         # for expression compat, need a method here to search weights
         # and determine of there is a direct match, or an expression match
-        if self._weightSrc.has_key(srcSeq): # direct match
+        if srcSeq in self._weightSrc: # direct match
             return self._weightSrc[srcSeq]
         # if no key defined, search for matching expressions
         srcLen = len(srcSeq)
-        for label in self._weightSrc.keys():
+        for label in list(self._weightSrc.keys()):
             if len(label) != srcLen: continue # a def for a different order
             matchCount = 0
             for i in range(srcLen):
@@ -591,7 +586,7 @@
         # if an empty weight list is given, use an equal distribution
         # based onall known symbols
         if wList == None:         
-            symbols = self._symbols.keys() # order does not matter
+            symbols = list(self._symbols.keys()) # order does not matter
             wPost = [1] * len(symbols)
             sDeclared = symbols[:]
         else:
@@ -613,10 +608,10 @@
         next available order, otherwise, will use zero order
         order may be a float; if so it will use weighting from drawer
         """
-        symbols = self._symbols.keys()
+        symbols = list(self._symbols.keys())
         # get appropriate order: if a float, will be dynamically allocated
         order = drawer.floatToInt(order, 'weight')
-        if order not in range(0, self._ordersSrc[-1]+1):
+        if order not in list(range(0, self._ordersSrc[-1]+1)):
             order = self._ordersSrc[-1] # use highest defined
         #print _MOD, 'using order', order
         # get appropriate key of given length of previous
@@ -657,7 +652,7 @@
         
     def testParse(self):
 
-        import rhythm
+        from . import rhythm
         timer = rhythm.Timer() # get a timer to test time
     
         testA = "a{x} b{y} c{z} :{a=3|b=.03|c=5} a:{a=1|b=5|c=4} b{a=2|b=2|c=6} c{a=3|b=1|c=9} a::b::{a=3|b=2} a:c:b{a=1}"
@@ -684,23 +679,23 @@
                          testI, testJ]:
             a = Transition()
             a.loadTransition(test)
-            print a
+            print(a)
             for order in range(0,4):
-                print 'requested order:', order
+                print('requested order:', order)
                 msg = []
                 for x in range(30):
                     val = random.random()
                     msg.append(a.next(val, msg, order))
-                print ' '.join(msg)
-            print
-
-        print '\ntotal time %s' % timer('sw')
+                print(' '.join(msg))
+            print()
+
+        print('\ntotal time %s' % timer('sw'))
 
 
 
     def testAnalysis():
 
-        import rhythm
+        from . import rhythm
         timer = rhythm.Timer() # get a timer to test time
             
         msgA = 'that this is a this that is a a this is that but not this that is a is a that this this that but that but this but is but not'      
@@ -768,19 +763,19 @@
             a = Transition()
             max = 2
             a.loadString(test, max)
-            print a
+            print(a)
             for order in range(0,max+1):
-                print 'requested order: (w/ random upward variation)', order
+                print('requested order: (w/ random upward variation)', order)
                 msg = []
                 for x in range(120):
                     postOrder = order + random.random()
                     val = random.random()
                     msg.append(a.next(val, msg, postOrder))
-                print ' '.join(msg)
-                print
-            
-            
-        print '\ntotal time %s' % timer('sw')
+                print(' '.join(msg))
+                print()
+            
+            
+        print('\ntotal time %s' % timer('sw'))
 
 
 
--- ./athenaCL/libATH/midiTools.py	(original)
+++ ./athenaCL/libATH/midiTools.py	(refactored)
@@ -92,7 +92,7 @@
             Checks for channel duplication, Sets default channel volume.
         """
         self.channel = int(c)
-        if self.mtrks.has_key(self.channel): # if another inst is using channel
+        if self.channel in self.mtrks: # if another inst is using channel
             # find that inst, set it to share, set this inst to share
             pass
         else: # create new instance for this channel
@@ -159,7 +159,7 @@
             Events are stored in creation order.
         """
         if offset < 0: offset = 0
-        if self.miditrk.has_key(offset):
+        if offset in self.miditrk:
             self.miditrk[offset].append(event)
         else:
             self.miditrk[offset]=[event]
@@ -250,7 +250,7 @@
         out.write( intToLong(0) )   # dummy, redo at end
         
         dataPt = out.tell()
-        trkKeys = self.miditrk.keys() # the keys are the midi timing offset
+        trkKeys = list(self.miditrk.keys()) # the keys are the midi timing offset
         trkKeys.sort()
 
         last = 0
@@ -295,7 +295,7 @@
         self.fileName = fileName
 
         self.tnames = {} 
-        chList = range(1, (self.maxCh + 1)) # 1-16
+        chList = list(range(1, (self.maxCh + 1))) # 1-16
         chList.remove(10) # 10 is reserved for drum kit on gm
         chIndex = 0 # position in list
         for name, pgm, ch, score in self.trackList: # passing a ref to dict
@@ -321,14 +321,14 @@
         instPerCh = {}
         for ch in range(1, (self.maxCh+1)): # dotn include 0 meta track
             count = 0
-            for name in self.tnames.keys():
+            for name in list(self.tnames.keys()):
                 if self.tnames[name].channel == ch:
                     count = count + 1
             instPerCh[ch] = count
 
         shiftPos = 0 # start at zero, mult offset base
         # used to randomly shift tracks latter if using the same channel
-        for name in self.tnames.keys():
+        for name in list(self.tnames.keys()):
             instSharingThisCh = instPerCh[self.tnames[name].channel]
             if instSharingThisCh > 1: # if more than 1 inst on this ch
                 self.tnames[name].chShare = 1 # need to share, to pgm changes
@@ -358,7 +358,7 @@
         # this may raise an exception, OSError or IOError
         f = open(filePath, 'wb') # get file obj named f
         # count tracks; needed for header       
-        mtrkKeys = self.mtrks.keys()
+        mtrkKeys = list(self.mtrks.keys())
         mtrkKeys.sort()
         trackCount = 1    # account for meta track
         for n in mtrkKeys[1:]:    # check all but 0 (meta)
--- ./athenaCL/libATH/multiset.py	(original)
+++ ./athenaCL/libATH/multiset.py	(refactored)
@@ -198,7 +198,7 @@
     elif card > 12:
         return None # 'irrational cardinality error'
 
-    rotIndices = range(0, card)
+    rotIndices = list(range(0, card))
     foundIndex = None                #control variable
     for rot in rotIndices:
         r = rot # dont need to add 1? + 1
@@ -432,18 +432,18 @@
     as an int (getting just the values of that int
     or as a range from 1 to 12; if range, last values is inclusif"""
     if cardRange == 'all':
-        gatherCards = range(1,13)
+        gatherCards = list(range(1,13))
     elif drawer.isInt(cardRange):
         gatherCards = [cardRange,] # only get one card
     elif drawer.isList(cardRange):
         if cardRange[1] < cardRange[0]:
-            raise ValueError, 'bad cardinality range given'
+            raise ValueError('bad cardinality range given')
         elif cardRange[0] == cardRange[1]:
             gatherCards = [cardRange[0],] # only get one card
         else:
-            gatherCards = range(cardRange[0], cardRange[1]+1)
+            gatherCards = list(range(cardRange[0], cardRange[1]+1))
     found = []
-    for scTriple in TNREF.keys():
+    for scTriple in list(TNREF.keys()):
         card = scTriple[0]
         inv = scTriple[2]
         if card in gatherCards:
@@ -491,7 +491,7 @@
         scoreDict[setTuple] = 0
         if refDict == None:
             continue
-        if refType in refDict.keys(): # name groups
+        if refType in list(refDict.keys()): # name groups
             nameList = refDict[refType]
             nameWords = []
             for nameStrings in nameList: # list of strings
@@ -503,7 +503,7 @@
                     if nwTemp.find(swTemp) >= 0:
                         scoreDict[setTuple] = scoreDict[setTuple] + 1 # add
     rankList = []
-    for setTuple in scoreDict.keys():
+    for setTuple in list(scoreDict.keys()):
         if scoreDict[setTuple] == 0:
             del scoreDict[setTuple] # remove if 0 score
         else: # add ranks to a list
@@ -636,7 +636,7 @@
             if refDict == None:
                 return None
             else:
-                for key in refDict.keys():
+                for key in list(refDict.keys()):
                     msgLines.append(', '.join(refDict[key]))
                 return msgLines
  
@@ -646,7 +646,7 @@
                 return None
             else:
                 refDict = self.refData()
-                if refDict.has_key('name'):
+                if 'name' in refDict:
                     return ', '.join(refDict['name'])
                 else:
                     return None
@@ -655,7 +655,7 @@
             return '%s' % self.tRef
 
         else:
-            raise ValueError, 'bad representation format'
+            raise ValueError('bad representation format')
 
     def __str__(self):
         """default string representation is as 'psReal'"""
@@ -726,7 +726,7 @@
 
     def get(self, name):
         if name not in self.forms:
-            raise ValueError, 'bad format requested'
+            raise ValueError('bad format requested')
         return self._access(name) # convert to appropriate data and return
 
     # sc analysis measures
@@ -920,7 +920,7 @@
             return 'forte'
         else:
             for char in usrStr.lower(): # check if it has characters
-                if char in pitchTools.REFdiaNameToPc.keys():
+                if char in list(pitchTools.REFdiaNameToPc.keys()):
                     return 'psName'
             return 'psReal' # assume pset numbers
 
@@ -958,7 +958,7 @@
         for elem in usrList: # may be int or float
             elem = drawer.strScrub(elem)
             if elem == '': continue
-            elif elem[0] not in pitchTools.REFdiaNameToPc.keys():
+            elif elem[0] not in list(pitchTools.REFdiaNameToPc.keys()):
                 continue
             else: # this should never raise an error
                 psList.append(pitchTools.psNameToPs(elem))
--- ./athenaCL/libATH/ornament.py	(original)
+++ ./athenaCL/libATH/ornament.py	(refactored)
@@ -178,7 +178,7 @@
         self.pmtrObjDict = pmtrObjDict # reference
         self.temperamentObj = temperamentObj # reference
         self._ornLibrary() # updates self.ornLib w/ new values
-        self.ornKeys = self.ornLib.keys()
+        self.ornKeys = list(self.ornLib.keys())
 
         # mu, sigma, min, max; want a range from -1 to 1
         self.gaussPmtrObj = parameter.factory(('randomGauss', .5, .1, -1, 1))
@@ -374,7 +374,7 @@
         """
         # add additional parameters
         if name not in self.ornKeys:
-            raise AttributeError, 'no such ornament named %s' % name
+            raise AttributeError('no such ornament named %s' % name)
 
         ornDict = self.ornLib[name]
         ornDict['ornPos'] = ornPos
@@ -448,7 +448,7 @@
 
                 psContourRef.append(psReal) # transpose by half steps
         else:
-            raise ValueError, 'no such pitchFormat'
+            raise ValueError('no such pitchFormat')
         # this now returns psReals, not pch values
         return psContourRef, refScales
 
@@ -488,7 +488,7 @@
         if totOrnDur > rhythmBase:
             environment.printDebug(['ERROR: pos: %s, baseT: %s, ornT: %s' % (ornPos, rhythmBase, totOrnDur)])
             # ornament can never be longer than the rhythm base
-            raise ValueError, 'ornament time is longer than base note'
+            raise ValueError('ornament time is longer than base note')
 
         if tCurrent - totOrnDur < 0 and ornPos == 'anticipate':
             environment.printDebug(['anticipate ornament starts at negative time, mangling to attack'])
@@ -517,7 +517,7 @@
         # short; need to check here for a short base note, if too 
         # short, raise an exception
         if durBase < .0001:
-            raise ValueError, 'ornament basDur is very very short'
+            raise ValueError('ornament basDur is very very short')
         return durBase, tBaseStart, tBaseEnd, tOrnStart, tOrnEnd
 
 
@@ -704,7 +704,7 @@
             baseNoteEvent = self._makeEventDict(tBaseStart, durBase, amp, 
                                                             psBase, pan)
         else: # abort ornament, user tempered pitch
-            print lang.WARN, "ornamants aborted" 
+            print(lang.WARN, "ornamants aborted") 
             baseNoteEvent = self._makeEventDict(tCurrent, rhythmBase, amp, 
                                                             psBase, pan)
             eventList.append(baseNoteEvent)
--- ./athenaCL/libATH/osTools.py	(original)
+++ ./athenaCL/libATH/osTools.py	(refactored)
@@ -121,7 +121,7 @@
 # messagge formatting for standard output
 
 def alertMsg(str='', prepend=''):
-    print '%s--||||||||||||-- %s' % (prepend, str)
+    print('%s--||||||||||||-- %s' % (prepend, str))
     
 def cmtAlert(str='', prepend='#'):
     return '%s--||||||||||||-- %s\n' % (prepend, str)
@@ -180,7 +180,7 @@
 
 
 def rm(path):
-    if path == os.sep: raise ValueError, 'macro remove canceled' # safety
+    if path == os.sep: raise ValueError('macro remove canceled') # safety
     if os.name == 'posix': 
         os.system('rm -f -r "%s"' % path)
     else: # mac, windows
@@ -193,15 +193,15 @@
         
 def rmSudo(path, sudoFound=None):
     """sudo is not avail on all plats, so su root on other nixes"""
-    if path == os.sep: raise ValueError, 'macro remove canceled' # safety
+    if path == os.sep: raise ValueError('macro remove canceled') # safety
     if os.name == 'posix': 
         if sudoFound == None: # test
             sudoFound = drawer.isSudo() # 1 if exists
         if drawer.isDarwin() or sudoFound:
-            print PROMPTdarwin % ('removing', path)
+            print(PROMPTdarwin % ('removing', path))
             os.system('sudo rm -f -r "%s"' % path)
         else: # other *nixes
-            print PROMPTposix % ('removing', path)
+            print(PROMPTposix % ('removing', path))
             os.system('su root -c "rm -f -r %s"' % path)
     else: # mac, windows
         for root, dirs, files in os.walk(path, topdown=False):
@@ -235,10 +235,10 @@
         if sudoFound == None: # test
             sudoFound = drawer.isSudo() # 1 if exists
         if drawer.isDarwin() or sudoFound:
-            print PROMPTdarwin % ('writing', dst)
+            print(PROMPTdarwin % ('writing', dst))
             os.system('sudo cp %s %s' % (src, dst))
         else: # other *nixes
-            print PROMPTposix % ('writing', dst)
+            print(PROMPTposix % ('writing', dst))
             os.system('su root -c "cp %s %s"' % (src, dst))
     else: # mac, windows
         if os.path.isdir():
@@ -271,10 +271,10 @@
         if sudoFound == None: # test
             sudoFound = drawer.isSudo() # 1 if exists
         if drawer.isDarwin() or sudoFound:
-            print PROMPTdarwin % ('moving', dst)
+            print(PROMPTdarwin % ('moving', dst))
             os.system('sudo mv %s %s' % (src, dst))
         else: # other *nixes
-            print PROMPTposix % ('moving', dst)
+            print(PROMPTposix % ('moving', dst))
             os.system('su root -c "mv %s %s"' % (src, dst))
     else: # mac, windows
         shutil.move(src, dst)
@@ -292,10 +292,10 @@
         if sudoFound == None: # test
             sudoFound = drawer.isSudo() # 1 if exists
         if drawer.isDarwin() or sudoFound:
-            print PROMPTdarwin %     ('writing directory', path)
+            print(PROMPTdarwin %     ('writing directory', path))
             os.system('sudo mkdir %s %s' % (flagStr, path))
         else: # other *nixes
-            print PROMPTposix % ('writing directory', path)
+            print(PROMPTposix % ('writing directory', path))
             os.system('su root -c "mkdir %s %s"' % (flagStr, path))
     else:
         os.mkdir(path)
@@ -315,10 +315,10 @@
         if sudoFound == None: # test
             sudoFound = drawer.isSudo() # 1 if exists
         if drawer.isDarwin() or sudoFound:
-            print PROMPTdarwin %     ('changing permissions', path)
+            print(PROMPTdarwin %     ('changing permissions', path))
             os.system('sudo chmod %s "%s"' % (value, path))
         else: # other *nixes
-            print PROMPTposix % ('changing permissions', path)
+            print(PROMPTposix % ('changing permissions', path))
             os.system('su root -c "chmod %s %s"' % (value, path))
 
 
@@ -330,12 +330,12 @@
     """
     import md5 # this is depcreated; use hashlib
 
-    print _MOD, 'mpd5 obtained from:', filePath
+    print(_MOD, 'mpd5 obtained from:', filePath)
     f = open(filePath)
     msg = f.read()
     f.close()
     val = md5.new(msg).hexdigest()
-    print _MOD, 'md5:', val
+    print(_MOD, 'md5:', val)
     return val
         
 def man(path):
@@ -496,7 +496,7 @@
                 user, pswd, ip, vol, dirVol)
         os.system(cmdStr)
     else:
-        print '%s already exists.' % dirVol
+        print('%s already exists.' % dirVol)
 
 def unmount(dirVol):
     os.system('umount %s' % dirVol)
@@ -603,7 +603,7 @@
     ditto(tmpDir, '/Volumes/%s/' % (name)) # copy to volume
 
     if dmgRsrc != None:
-        print 'Customize dmg now, then press return'
+        print('Customize dmg now, then press return')
         os.system('read ') # wait for return form user
         ### break to make manual adjustments
     # hide resource files, if around
@@ -778,7 +778,7 @@
         else: # win or other
             pass # rely on system
     elif fileType != None: # get from prefDict
-        for key in prefDict.keys():
+        for key in list(prefDict.keys()):
             # match by filetype string leading key and path string
             if key.startswith(fileType) and 'path' in key.lower(): 
                 app = prefDict[key] # may be a complete file path, or a name
@@ -832,8 +832,8 @@
     retuns None on error: means no fink installation
     """
     if os.name == 'posix': # create launch script
-        import commands
-        msg = commands.getoutput('fink dumpinfo -p %p fink')
+        import subprocess
+        msg = subprocess.getoutput('fink dumpinfo -p %p fink')
         # last line is somethign like: %p: /sw
         msgStr = msg.split('\n')[-1] # get last if more tn 1 line
         if msgStr.find('command not found') >= 0: # cant find fink command
@@ -886,7 +886,7 @@
             dirs = [os.path.join(finkStub, 'share', 'man')]
         else: # use common dirs
             dirs = commonManDirs
-    else: raise ValueError, 'bad system alternate option given'
+    else: raise ValueError('bad system alternate option given')
     found = []
     for path in dirs:
         if os.path.isdir(path):
--- ./athenaCL/libATH/outFormat.py	(original)
+++ ./athenaCL/libATH/outFormat.py	(refactored)
@@ -264,7 +264,7 @@
     if drawer.isStr(request):
         request = drawer.strScrub(request, 'L')
         if request == 'all':
-            request = outputFormatNames.values()
+            request = list(outputFormatNames.values())
         # if other string given, add to a list
         else:
             request = [request]
--- ./athenaCL/libATH/permutate.py	(original)
+++ ./athenaCL/libATH/permutate.py	(refactored)
@@ -7,7 +7,7 @@
 # Copyright:     (c) 2005-2010 Christopher Ariza
 # License:       GPL
 #-----------------------------------------------------------------||||||||||||--
-from __future__ import generators
+
 
 
 import unittest, doctest
@@ -25,21 +25,21 @@
 def xcombinations(items, n):
     if n==0: yield []
     else:
-        for i in xrange(len(items)):
+        for i in range(len(items)):
             for cc in xcombinations(items[:i]+items[i+1:],n-1):
                 yield [items[i]]+cc
     
 def xselections(items, n):
     if n==0: yield []
     else:
-        for i in xrange(len(items)):
+        for i in range(len(items)):
             for ss in xselections(items, n-1):
                 yield [items[i]]+ss
 
 def xuniqueCombinations(items, n):
     if n==0: yield []
     else:
-        for i in xrange(len(items)-n+1):
+        for i in range(len(items)-n+1):
             for cc in xuniqueCombinations(items[i+1:],n-1):
                 yield [items[i]]+cc
 
--- ./athenaCL/libATH/pitchPath.py	(original)
+++ ./athenaCL/libATH/pitchPath.py	(refactored)
@@ -117,7 +117,7 @@
     def t(self, value, key=None):
         """if key == None, all sets are are transposed"""
         if key == None: # if none, do all
-            indexList = range(0,self.len())
+            indexList = list(range(0,self.len()))
         else:
             indexList = []
             indexList.append(key)
@@ -128,7 +128,7 @@
     def i(self, key=None):
         """if key == None, all sets are are inverted"""
         if key == None: # if none, do all
-            indexList = range(0,self.len())
+            indexList = list(range(0,self.len()))
         else:
             indexList = []
             indexList.append(key)
@@ -258,13 +258,13 @@
             field = copy.deepcopy(p['field'])
             # dur fractions added for 1.0.21 
             # if exists, replace: will be updated otherwise
-            if p.has_key('durFraction'): 
+            if 'durFraction' in p: 
                 durFraction = copy.deepcopy(p['durFraction'])
             i = 0
             for set in psPath:
                 setObj = multiset.Multiset(psPath[i], scPath[i])
                 setObj.setT(field[i])
-                if p.has_key('durFraction'): 
+                if 'durFraction' in p: 
                     setObj.setDur(durFraction[i])
                 self.multisetPath.append(setObj)
                 i = i + 1
@@ -345,7 +345,7 @@
         
     def get(self, name):
         if name not in self.forms:
-            raise ValueError, 'bad format name: %s' % name
+            raise ValueError('bad format name: %s' % name)
         return self._access(name)
 
     #-----------------------------------------------------------------------||--
--- ./athenaCL/libATH/pitchTools.py	(original)
+++ ./athenaCL/libATH/pitchTools.py	(refactored)
@@ -432,7 +432,7 @@
     elif micro >= .75 and micro <= 1:
         qStr = ''
         qOffset = 1 # add an extra half step, round up
-    else: raise ValueError, 'micro tone value exceeds range'
+    else: raise ValueError('micro tone value exceeds range')
     # get oct offset for if wraps to ictace
     if (pc + qOffset) > 11:
         octOffset = 1
@@ -464,7 +464,7 @@
     elif micro >= .75 and micro <= 1:
         qVal = 0
         qOffset = 1 # add an extra half step, round up
-    else: raise ValueError, 'micro tone value exceeds range'
+    else: raise ValueError('micro tone value exceeds range')
     # get oct offset for if wraps to ictace
     if (pc + qOffset) > 11:
         octOffset = 1
@@ -778,7 +778,7 @@
         """use of the get method should replace all direct attribute
         access. """
         if name not in self.forms:
-            raise ValueError, 'bad format name'
+            raise ValueError('bad format name')
         return self._convert(name) # convert to appropriate data and return
 
     def _procStrFloat(self, realVal, sigDigControl):
@@ -835,7 +835,7 @@
         elif format == 'pc': # 6 sig digits
             return '%i' % self._convert(format)           
         else:
-            raise ValueError, 'no such format string: %s' % format
+            raise ValueError('no such format string: %s' % format)
 
     def __str__(self):
         return self.repr()
--- ./athenaCL/libATH/prefTools.py	(original)
+++ ./athenaCL/libATH/prefTools.py	(refactored)
@@ -169,20 +169,20 @@
     categories = ['external', 'athena', 'gui']
 
     # if missing a category:
-    if len(oldPrefDict.keys()) != len(defaultPrefDict.keys()):
-        for category in defaultPrefDict.keys():
-            if category not in oldPrefDict.keys():
+    if len(list(oldPrefDict.keys())) != len(list(defaultPrefDict.keys())):
+        for category in list(defaultPrefDict.keys()):
+            if category not in list(oldPrefDict.keys()):
                 oldPrefDict[category] = defaultPrefDict[category]
 
     for catName in categories: # check each key
         # provide backwards compat for changed category names 
-        if catName not in oldPrefDict.keys():
+        if catName not in list(oldPrefDict.keys()):
             if catName == 'external': 
                 oldPrefDict[catName] = oldPrefDict['csound'] 
                 del oldPrefDict['csound']
-        oldCatKeys = oldPrefDict[catName].keys()
+        oldCatKeys = list(oldPrefDict[catName].keys())
         oldCatKeys.sort() # sort keys and compare
-        newCatKeys = defaultPrefDict[catName].keys()
+        newCatKeys = list(defaultPrefDict[catName].keys())
         newCatKeys.sort()
         if not oldCatKeys == newCatKeys:
             for key in newCatKeys:
--- ./athenaCL/libATH/quantize.py	(original)
+++ ./athenaCL/libATH/quantize.py	(refactored)
@@ -80,14 +80,14 @@
             stepLast.append(copy.copy(step)) # add previous step
         
             if n >= self.LOOPLIMIT: # around 1000 
-                print _MOD, 'failed to find boundray neighbors'
+                print(_MOD, 'failed to find boundray neighbors')
                 return None, None
         
     def updateGrid(self, grid):
         """can be called each time attract is called for dynamic grid
         can be called once for static grid"""
         if len(grid) <= 0: # need more values
-            raise ValueError, 'grid must have more than 1 value'
+            raise ValueError('grid must have more than 1 value')
         self.grid = grid
         self.gridRetro = grid[:]
         self.gridRetro.reverse()
--- ./athenaCL/libATH/rhythm.py	(original)
+++ ./athenaCL/libATH/rhythm.py	(refactored)
@@ -59,7 +59,7 @@
 # replace with function from below
 def dynStrToAcc(sym):
     """convert dynStr to accent value; ints will be ints, otherwise floats"""
-    if sym not in REFdynStr.keys():
+    if sym not in list(REFdynStr.keys()):
         raise ValueError
     # return median of min/max
     if REFdynStr[sym][0] == REFdynStr[sym][1]:
@@ -72,7 +72,7 @@
     elif num < .0001: return 'o'
     # no integers beyond this
     num = round(num, 4) # four sig digits
-    for sym in REFdynStr.keys():
+    for sym in list(REFdynStr.keys()):
         if num >= REFdynStr[sym][0] and num < REFdynStr[sym][1]:
             return sym
     raise ValueError # should not happen
@@ -154,9 +154,9 @@
             if len(data) == 0:
                 return None # no data found
             if data[0].islower(): # if has chars
-                if data in REFdurStr.keys():
+                if data in list(REFdurStr.keys()):
                     return 'str'
-                elif data in REFdynStr.keys(): # maybe its a dynmaic
+                elif data in list(REFdynStr.keys()): # maybe its a dynmaic
                     return 'acc' # acc string value alone
                 else:
                     raise error.PulseSyntaxError
@@ -178,7 +178,7 @@
         """
         data = copy.copy(self.srcData)
         if self.format == 'str':
-            if drawer.isStr(data) and data in REFdurStr.keys():
+            if drawer.isStr(data) and data in list(REFdurStr.keys()):
                 data = data.strip()
                 data = data.lower()
                 return self._expandRawTriple(REFdurStr[data]) # return None on error
@@ -196,7 +196,7 @@
                 return self._expandRawTriple(data) # return None on error
         elif self.format == 'acc': # a list of amps
             if drawer.isStr(data):
-                if data in REFdynStr.keys(): # its a string
+                if data in list(REFdynStr.keys()): # its a string
                     data = self._dynStrToVal(data) # convert to number
                 else: # its a string number like '3'
                     try:
@@ -269,7 +269,7 @@
         """
         usrStr = usrStr.lower()
         # provide keys to match other possible symbols (just need + really)
-        chars = drawer.strExtractAlpha(usrStr, REFdynStr.keys())
+        chars = drawer.strExtractAlpha(usrStr, list(REFdynStr.keys()))
         if chars not in usrStr: # chars are not all contiguous, bad arg
             raise error.PulseSyntaxError
         elif chars == '': # no chars at all, just numbers, return
@@ -280,7 +280,7 @@
         # need to always have longest strings firts
         # to avoid f, vs fff confusions
         sortItems = []
-        for sym in REFdynStr.keys(): # will retain class, int or float
+        for sym in list(REFdynStr.keys()): # will retain class, int or float
             sortItems.append((len(sym), sym, dynStrToAcc(sym)))
         sortItems.sort()
         sortItems.reverse() # largest lengths first
@@ -386,7 +386,7 @@
 
     def get(self, format='triple'):
         if format not in self.forms:
-            raise ValueError, 'bad format requested: %s' % format
+            raise ValueError('bad format requested: %s' % format)
         return self._access(format)
 
     def __eq__(self, other):
@@ -428,7 +428,7 @@
         divisor is not altered
         """
         if not drawer.isInt(value):
-            raise ValueError, 'value must be an integer'
+            raise ValueError('value must be an integer')
         self.triple[1] = self.triple[1] * value
         
 
@@ -438,7 +438,7 @@
         raising ot a higher terms
         duratin remains the same"""
         if not drawer.isInt(value):
-            raise ValueError, 'value must be an integer'
+            raise ValueError('value must be an integer')
         self.triple[0] = self.triple[0] * value
         self.triple[1] = self.triple[1] * value
 
@@ -447,9 +447,9 @@
         div and mult
         must be sure that value is alreaduy a proper multiple"""
         if not drawer.isInt(div):
-            raise ValueError, 'value must be an integer'
+            raise ValueError('value must be an integer')
         if   float(div) / self.triple[0] != float(div) // self.triple[0]:
-            raise ValueError, 'target divisor does not divide evenly into pulse triple divisor'
+            raise ValueError('target divisor does not divide evenly into pulse triple divisor')
         # divide goal divisor by current divisor to get necessary mutltiple
         m = div // self.triple[0] 
         self.ratioRaise(m)
@@ -461,11 +461,11 @@
         if 4, 5 is provided, denominatorided into 4/5 adn 1/5, return 4/5 first"""
 
         if not drawer.isInt(numerator):
-            raise ValueError, 'numerator must be an integer'
+            raise ValueError('numerator must be an integer')
         if not drawer.isInt(denominator):
-            raise ValueError, 'denominator must be an integer'
+            raise ValueError('denominator must be an integer')
         if numerator > denominator:
-            raise ValueError, 'fraction must be less than 1'
+            raise ValueError('fraction must be less than 1')
 
         a = self.copy()
         b = self.copy()
@@ -487,9 +487,9 @@
         where the multipliers sum to the current multiplier"""
 
         if not drawer.isInt(multiplier):
-            raise ValueError, 'multiplier must be an integer'
+            raise ValueError('multiplier must be an integer')
         if multiplier > self.triple[1]:
-            raise ValueError, 'new multiplier must be less than current'
+            raise ValueError('new multiplier must be less than current')
 
         a = self.copy()
         b = self.copy()
@@ -651,7 +651,7 @@
 
     def get(self, name):
         if name not in self.forms:
-            raise ValueError, 'bad format requested: %s' % name
+            raise ValueError('bad format requested: %s' % name)
         return self._access(name)
 
     def __contains__(self, item):
@@ -752,27 +752,27 @@
 
 
     def _diagnostic(self, post):
-        print 
-        print _MOD, 'measure partition diagnostic'
-        print 'dst rhtyhm:', self.dstRhythm
+        print() 
+        print(_MOD, 'measure partition diagnostic')
+        print('dst rhtyhm:', self.dstRhythm)
         sumTotal = 0
         mCount = 1
         for measure in post:
-            print 'measure %s' % mCount
-            print measure
+            print('measure %s' % mCount)
+            print(measure)
             sum = 0
             for pulse, tie in measure:
                 sum = sum + pulse.triple[1]
             sumTotal = sumTotal + sum
-            print 'sum', sum
+            print('sum', sum)
             mCount = mCount + 1
-        print
-        print 'sum measure', sumTotal
+        print()
+        print('sum measure', sumTotal)
         
         sumDst = 0
         for pulse in self.dstRhythm:
             sumDst = sumDst + pulse.triple[1]
-        print 'sum dst rhythm', sumDst
+        print('sum dst rhythm', sumDst)
 
 
     def partition(self):
@@ -812,7 +812,7 @@
 
                 # mSum should always be less than the target before adding dur
                 if mSum >= target:
-                    raise ValueError, 'mSum has exceeded target before check'
+                    raise ValueError('mSum has exceeded target before check')
                 # find out how much space is left
                 mEmpty = target - mSum 
                 # this sum is conditional; it may exceed measure after this point
@@ -923,7 +923,7 @@
         elif drawer.isNum(data): # assume seconds
             self.time['s'] = data # keep floating point values
         else:
-            raise ValueError, 'unsupported data type'
+            raise ValueError('unsupported data type')
         self._updateTime() # update and shifts all values
         
 
@@ -965,7 +965,7 @@
                 self.time['h'] = int(usrList[1])
                 self.time['d'] = int(usrList[0])
             else:
-                raise ValueError, 'unsupported time string'
+                raise ValueError('unsupported time string')
         # order does not matter for labeled data
         # label must follow value
         elif format == 'label':
@@ -983,7 +983,7 @@
             if valList[-1] == '': # last label, no comma, causes last val to be ''
                 del valList[-1]
             if len(labelList) != len(valList):
-                raise ValueError, 'bad time string labels'
+                raise ValueError('bad time string labels')
             for i in range(0, len(labelList)):
                 val = valList[i]
                 label = labelList[i]
@@ -1040,7 +1040,7 @@
 
     def __getattr__(self, name):
         if name not in self.timeLabels:
-            print 'missing', name
+            print('missing', name)
             raise AttributeError
         s = self._seconds() # geet seconds
         if name == 's' or name == 'f':
@@ -1171,13 +1171,13 @@
         for triple in ([4,1], [3,1], [1,1], [5,3]):
             a = Pulse(triple)
             for fraction in ([1,4], [3,4], [5,8], [2,3], [6,21]):
-                print 'source:', a, a()
-                print 'fraction:', str(fraction)
+                print('source:', a, a())
+                print('fraction:', str(fraction))
                 # split into a quarter and three quarters
                 x, y = a.fracture(fraction[0], fraction[1]) 
-                print 'result:', x, x(), y, y()
-                print 'sum:', x()[0] + y()[0]
-                print
+                print('result:', x, x(), y, y())
+                print('sum:', x()[0] + y()[0])
+                print()
 
 
     def testRhythm(self):
@@ -1187,34 +1187,34 @@
         # the list of chars / floats gets converted to 3 pulses
         for val in testVals:
             a = Rhythm(val)
-            print '\ninput', val, len(a)
+            print('\ninput', val, len(a))
             for type in a.forms:
-                print a.repr(type), a.get(type)
+                print(a.repr(type), a.get(type))
 
     def testTimer(self):
         obj = Timer()
-        print 'print:', obj
+        print('print:', obj)
         time.sleep(2.2)
-        print 'print:', obj
+        print('print:', obj)
         time.sleep(2.8)
-        print 'call:', obj()
+        print('call:', obj())
         time.sleep(3.1)
-        print 'call:', obj()
+        print('call:', obj())
         time.sleep(1.1)
         obj.stop()
-        print obj
-        print 
+        print(obj)
+        print() 
 
     def testTimeValue(self):
         for testStr in ['3:2', '25h.2s', '1d 4h 64m 2.4s',
                              '3:2:4.3', 1201, 30.2, 234234]:
-            print testStr
+            print(testStr)
             tObj = TimeValue(testStr)
-            print tObj.repr('label')
-            print tObj.repr('watch')
+            print(tObj.repr('label'))
+            print(tObj.repr('watch'))
             for label in tObj.timeLabels:
-                print '%s:' % label, getattr(tObj, label) 
-            print
+                print('%s:' % label, getattr(tObj, label)) 
+            print()
 
 
 
--- ./athenaCL/libATH/setTables.py	(original)
+++ ./athenaCL/libATH/setTables.py	(refactored)
@@ -2507,36 +2507,36 @@
         self.assertEqual(True, True)
 
     def testScRef(self):
-        for key, value in SCREF.items():
+        for key, value in list(SCREF.items()):
             self.assertEqual(len(key), 3)
-            if value.keys() != []:
+            if list(value.keys()) != []:
                 # if we have keys, make sure that name is one of them
-                self.assertEqual('name' in value.keys(), True)
+                self.assertEqual('name' in list(value.keys()), True)
 
     def testTnRef(self):
         partition = {}
-        for key, value in TNREF.items():
+        for key, value in list(TNREF.items()):
             self.assertEqual(len(key), 3)
             # the third value of the key should be -1, 1, or 0
             self.assertEqual(key[2] in [-1, 0, 1], True)
-            if key[0] not in partition.keys():
+            if key[0] not in list(partition.keys()):
                 partition[key[0]] = []
                 partition[key[0]].append(value) # append unique ids
             else:
                 partition[key[0]].append(value) # append unique ids
 
-        for key, value in partition.items():
+        for key, value in list(partition.items()):
             # the length of the list should be the max value stored
             self.assertEqual(max(value), len(partition[key]))    
 
     def testScDict(self):
-        for key, value in SCDICT.items():
+        for key, value in list(SCDICT.items()):
             max = TNMAX[key]
             # make sure the max value is the length of all keys for each size
-            self.assertEqual(max, len(value.keys()))
+            self.assertEqual(max, len(list(value.keys())))
 
     def testForte(self):
-        for setSize, setCount in TNIMAX.items(): # look at tni structures
+        for setSize, setCount in list(TNIMAX.items()): # look at tni structures
             if setSize == 0: continue
             for i in range(1, setCount+1):
                 self.assertEqual(len(FORTE[setSize][1]), 4)
--- ./athenaCL/libATH/sieve.py	(original)
+++ ./athenaCL/libATH/sieve.py	(refactored)
@@ -9,7 +9,7 @@
 #-----------------------------------------------------------------||||||||||||--
 
 # not sure this import is necessary
-from __future__ import generators
+
 # standarind importas
 import copy, string, random
 import unittest, doctest
@@ -89,7 +89,7 @@
             # in dicitionary
             # print 'p,q', p, q
             nextMult = p + q # prime prime plus the candidate; next multiple
-            while nextMult in D.keys(): # incr x by p until it is a unique key
+            while nextMult in list(D.keys()): # incr x by p until it is a unique key
                 nextMult = nextMult + p
             # re-store the prime under a key of the next multiple
             D[nextMult] = p # x is now the next unique multple to be found
@@ -272,7 +272,7 @@
     timer.start()
     for i in range(len(filter)):
         if timer() >= 60: # 1.5 minute
-            print 'lcm timed out.'
+            print('lcm timed out.')
             lcmVal = None
             break
         lcmVal = _lcm(lcmVal, filter[i])
@@ -289,7 +289,7 @@
     while 1:
         lcmVal = upper * x # get next multiple
         if lcmVal >= MAX:
-            print 'no lcm up to %s' % MAX
+            print('no lcm up to %s' % MAX)
             return None
         match = 0
         for q in lower:
@@ -343,12 +343,12 @@
         # is an actual range and not start/end points b/c when producing a not (-)
         # it is easy to remove the mod,n from the range
         if z == None: # supply default if necessary
-            z = range(0, 100) 
+            z = list(range(0, 100)) 
         self.z = z
         #print 'residual init self.z', self.z
         self.m = m
         if neg not in [0, 1]:
-            raise TypeError, 'negative value must be 0, 1, or a Boolean'
+            raise TypeError('negative value must be 0, 1, or a Boolean')
         self.neg = neg # negative, complement boolean
         if self.m == 0: # 0 mode causes ZeroDivisionError
             self.shift = shift
@@ -367,7 +367,7 @@
         """z is the range of integers to use when generating a list
         convenience functiont that fixes max
         """
-        self.z = range(min, max+1)
+        self.z = list(range(min, max+1))
 
     def segFmtSet(self, fmt):
         fmt = drawer.strScrub(fmt, 'l')
@@ -419,7 +419,7 @@
         elif format in ['int', 'integer']: # int, integer
             return seg
         else:
-            raise TypeError, '%s not a valid sieve format string.' % format
+            raise TypeError('%s not a valid sieve format string.' % format)
 
     def period(self):
         """period is M; obvious, but nice for completeness
@@ -530,7 +530,7 @@
         '15@11'
         """
         if other.neg or self.neg:
-            raise TypeError, 'complented Residual objects cannot be intersected'
+            raise TypeError('complented Residual objects cannot be intersected')
         m, n = self._cmpIntersection(self.m, other.m, self.shift, other.shift)
         # get the union of both z
         zSet = setConstruct(self.z) | setConstruct(other.z) 
@@ -609,7 +609,7 @@
             if num not in self.match:
                 self.match.append(num)
         if len(self.match) <= 1:
-            raise ValueError, 'segment must have more than one element'
+            raise ValueError('segment must have more than one element')
         self._zUpdate(z) # sets self.z
         # max mod should always be the max of z; this is b/c at for any segment
         # if the mod == max of seg, at least one point can be found in the segment
@@ -619,20 +619,20 @@
         try:
             self._process()
         except AssertionError:
-            raise ValueError, 'no Residual classes found for this z range'
+            raise ValueError('no Residual classes found for this z range')
 
     def _zUpdate(self, z=None):
         # z must at least be a superset of match
         if z != None: # its a list
             if not self._subset(self.match, z):
-                raise ValueError, 'z range must be a superset of desired segment'
+                raise ValueError('z range must be a superset of desired segment')
             else: # okay, assign
                 self.z = z
             zMin, zMax = self.z[0], self.z[-1]
         # z is range from max to min, unless provided at init     
         else: # range from min, max; add 1 for range() to max
             zMin, zMax = self.match[0], self.match[-1] 
-            self.z = range(zMin, (zMax + 1)) 
+            self.z = list(range(zMin, (zMax + 1))) 
 
 
     #-----------------------------------------------------------------------||--
@@ -767,7 +767,7 @@
                 
         # note: this z should only be used if usrStr is a str, and not a list
         if z == None and drawer.isStr(usrStr):
-            z = range(0, 100)
+            z = list(range(0, 100))
         elif z == None and drawer.isList(usrStr): # if a list, keep as None
             pass
         self.z = z # may be none; will be handled in self._load
@@ -853,7 +853,7 @@
             self._resClear('cmp') # clear compressed residuals
             self._initCompression() # may update self.nonCompressible
         if self.nonCompressible: # do not changes set
-            print 'no compression availabile at this z.'
+            print('no compression availabile at this z.')
         else:
             self.state = 'cmp'
 
@@ -862,7 +862,7 @@
     def dataLoad(self, data):
         """load reinit an existing object"""
         self.usrStr = data['logStr']
-        if data.has_key('z'):
+        if 'z' in data:
             self.z = data['z']
         self._load()
 
@@ -885,7 +885,7 @@
         """z is the range of integers to use when generating a list
         convenience functiont that fixes max
         """
-        self.z = range(min, max+1)
+        self.z = list(range(min, max+1))
 
     def segFmtSet(self, fmt):
         fmt = drawer.strScrub(fmt, 'l')
@@ -1064,13 +1064,13 @@
         assert state in ['cmp', 'exp']
         if state == 'cmp':
             libKeys = []
-            for key in self.resLib.keys():
+            for key in list(self.resLib.keys()):
                 if key in self.cmpTree:
                     libKeys.append(key)
             return libKeys
         elif state == 'exp':
             libKeys = []
-            for key in self.resLib.keys():
+            for key in list(self.resLib.keys()):
                 if key in self.expTree:
                     libKeys.append(key)
             return libKeys
@@ -1093,7 +1093,7 @@
         resDict = self._parseResidual(''.join(resStr))
         if resDict == None:
             msg = 'cannot parse %s' % ''.join(resStr)
-            raise SyntaxError, 'bad residual class notation: (%r)' % msg
+            raise SyntaxError('bad residual class notation: (%r)' % msg)
         resObj = Residual(resDict['m'],resDict['shift'],
                     resDict['neg'], self.z)
         #print 'created', resDict, self.z
@@ -1112,7 +1112,7 @@
             z = self.z 
         # z is valid, gets default from residual class
         if not drawer.isList(z) and z != None:
-            raise TypeError, 'z must be a list of integers.'
+            raise TypeError('z must be a list of integers.')
         valList = self.resLib[id](n, z) # call residual object
         return self._setInstantiateStr(valList)
 
@@ -1124,13 +1124,13 @@
         """reset self.resId to the next available number
         may need to re-label some residual classes if gaps develop
         ids should be coniguous integer sequence"""
-        iVals = range(0, len(self.resLib.keys()))
+        iVals = list(range(0, len(list(self.resLib.keys()))))
         for i in iVals:
             testKey = self._resKeyStr(i)
             if testKey not in self.cmpTree and testKey not in self.expTree:
-                raise KeyError, 'gap in residual keys'
+                raise KeyError('gap in residual keys')
         # set resId to next availabe index, the length of the keys
-        self.resId = len(self.resLib.keys())
+        self.resId = len(list(self.resLib.keys()))
 
     def _resClear(self, state=None):
         if state == None: # clear all
@@ -1143,7 +1143,7 @@
             # reset id to reflect deleted classes
             self._resResetId()
         elif state == 'exp':
-            raise ValueError, 'expanded residual classes shold never be cleared'
+            raise ValueError('expanded residual classes shold never be cleared')
 
     #-----------------------------------------------------------------------||--
     # expansion methods
@@ -1195,12 +1195,12 @@
             # if NEG is last char this is always an error
             elif char == self.NEG and charNext == None:
                 msg = 'negation cannot be used without operands'
-                raise SyntaxError, 'badly formed logical string (a): (%s)' % msg
+                raise SyntaxError('badly formed logical string (a): (%s)' % msg)
             # attempting to use negationg as a binary operators
             elif (char == self.NEG and charPrevious != None and 
                 charPrevious in self.RESIDUAL): # digit, or @ sign
                 msg = 'negation cannot be used as a binary operator'
-                raise SyntaxError, 'badly formed logical string (b): (%s)' % msg
+                raise SyntaxError('badly formed logical string (b): (%s)' % msg)
             # check if self.NEG is not folloed by a digit;
             # special case of self.NEG; need to convert into a binary operator
             elif (char == self.NEG and charNext != None and 
@@ -1210,7 +1210,7 @@
                 if (charPrevious != None and charPrevious not 
                     in [self.LGROUP, self.AND, self.OR, self.XOR]):
                     msg = 'negation must be of a group and isolated by delimiters'
-                    raise SyntaxError, 'badly formed logical string (c): (%s)' % msg
+                    raise SyntaxError('badly formed logical string (c): (%s)' % msg)
                 # add a set of z, or 1@0
                 else: # maintain representation until evaluation
                     self.expTree.append(char)
@@ -1245,7 +1245,7 @@
                 i = i + 1
         # do some checks 
         if len(self.resLib) == 0:
-            raise SyntaxError, 'no residual classes defined'
+            raise SyntaxError('no residual classes defined')
         self.expTree = ''.join(self.expTree)
 
 
@@ -1288,7 +1288,7 @@
         # will use z if set elsewheres
         seg = self.segment('exp')
         if seg == []: # empty set
-            raise IndexError, 'empty segment; segment compression not possible'
+            raise IndexError('empty segment; segment compression not possible')
         else:
             segObj = CompressionSeg(seg, self.z)
             for resObj in segObj():
@@ -1423,9 +1423,9 @@
 
             # must collect non width formats as integer values; then convert
             if format in ['wid', 'width']:
-                segmentPartial = self.segment(self.state, n, range(zMin, zMax), format)
+                segmentPartial = self.segment(self.state, n, list(range(zMin, zMax)), format)
             else: # if a unit, need to start with integers
-                segmentPartial = self.segment(self.state, n, range(zMin, zMax), 'int')
+                segmentPartial = self.segment(self.state, n, list(range(zMin, zMax)), 'int')
 
             found = found + segmentPartial[:]
             p = p + zStep # increment start value
@@ -1437,16 +1437,16 @@
         # trim any extra
         seg = found[:length] 
         if len(seg) != length:
-            raise ValueError, 'desired length of sieve segment cannot be found'
+            raise ValueError('desired length of sieve segment cannot be found')
 
         # only width format comes out correct after concatenation
         # for unit and binary, derive new z based on min and max
         if format in ['unit']:
             # make z to minimum and max value found
-            return unit.unitNormRange(seg, range(seg[0], seg[-1]+1))
+            return unit.unitNormRange(seg, list(range(seg[0], seg[-1]+1)))
         elif format in ['bin', 'binary']:
             # make to minimum and max value found
-            return unit.discreteBinaryPad(seg, range(seg[0], seg[-1]+1))
+            return unit.discreteBinaryPad(seg, list(range(seg[0], seg[-1]+1)))
         else:
             return seg
 
@@ -1580,7 +1580,7 @@
         """
         min = self.psLower.get('psReal')
         max = self.psUpper.get('psReal')
-        z = range(int(min), int(max+1))
+        z = list(range(int(min), int(max+1)))
         n = self.psOrigin.get('psReal') # shift origin
 
         # get integer range
@@ -1594,7 +1594,7 @@
 
             # this z will not be shifted
             # need to get list of apropriate size
-            z = range(0, len(valList)) 
+            z = list(range(0, len(valList))) 
             
             # get a binary segment
             binSeg = self.sieveObj(n, z, 'bin')
@@ -1628,7 +1628,7 @@
         may be notated, for subset F, as F' or F w/ line over top
         """
         if z == None:
-            z = range(0,100)
+            z = list(range(0,100))
         ab = []
         for value in z:
             if value not in set: # dont do anything
@@ -1682,7 +1682,7 @@
                     ]
         for arg in testArgs:
             testObj = Sieve(arg)
-            post = testObj(0, range(0, 30))
+            post = testObj(0, list(range(0, 30)))
 
 
     def testSievePitch(self):
@@ -1708,7 +1708,7 @@
 
 
     def testSieve(self):
-        z = range(0,100)
+        z = list(range(0,100))
         usrStr = '3@2 & 4@1 | 2@0 & 3@1 | 3@3 | -4@2'
         a = Sieve(usrStr, z)
         self.assertEqual(str(a), '3@2&4@1|2@0&3@1|3@0|-4@2')
--- ./athenaCL/libATH/spectral.py	(original)
+++ ./athenaCL/libATH/spectral.py	(refactored)
@@ -31,7 +31,7 @@
         the number of values to read; can also be set below
         w/ getPitch method"""
         if usrStr == None:
-            raise ValueError, 'bad file path given'
+            raise ValueError('bad file path given')
         if usrStr.find(',') >= 0:
             filePath, maxCount = usrStr.split(',')[:2]
             maxCount = drawer.strToNum(maxCount, 'int')
@@ -45,12 +45,12 @@
         # file path shuold always exists
         filePath = drawer.pathScrub(filePath)
         if not os.path.exists(filePath) or os.path.isdir(filePath): 
-            raise ValueError, 'bad file path given'
+            raise ValueError('bad file path given')
         self.filePath = filePath
         self.forms = ['audacity.spectrum', 'audacity.autocorrelation']
         ok = self._parseFormat()
         if ok == None:
-            raise ValueError, 'bad file path given'
+            raise ValueError('bad file path given')
         self.dataEval, self.fmt = ok
     
     def _parseFormat(self):
@@ -116,10 +116,10 @@
         maxLen = len(self.dataEval)
         if maxCount > 0: # get top portion of sorted list
             if maxCount > maxLen: maxCount = maxLen
-            posList = range(maxCount)
+            posList = list(range(maxCount))
         elif maxCount < 0: # get bottom portion of sorted list
             if maxCount < -maxLen: maxCount = -maxLen
-            posList = range(len(self.dataEval) + maxCount, len(self.dataEval))
+            posList = list(range(len(self.dataEval) + maxCount, len(self.dataEval)))
         else: return [] # empty range
         pitchList = []
         assert format in ['fq', 'psReal']
@@ -220,7 +220,7 @@
 
     def readAvg(self, bin):
         # for a given bin, get the average of all values for all frmaes
-        if bin > self.binCount - 1: raise ValueError, 'bin out of range'
+        if bin > self.binCount - 1: raise ValueError('bin out of range')
         a = 0
         f = 0
 
@@ -415,11 +415,11 @@
     def run(self):
         t = 0
         for step in self.signal:
-            print 'step:', step, 'time:', t
+            print('step:', step, 'time:', t)
             for part in self.components:
                 part.postTime(t, step)
 
-            print self._repr()
+            print(self._repr())
             t = t + 1
 
     def _repr(self, style=''):
--- ./athenaCL/libATH/table.py	(original)
+++ ./athenaCL/libATH/table.py	(refactored)
@@ -142,7 +142,7 @@
         self.outFmt = ['table', 
             'flatRowPair','flatColumnPair',
             'flatRowReflectPair', 'flatColumnReflectPair', 
-                            ] + tableMonoFormatRef.keys()
+                            ] + list(tableMonoFormatRef.keys())
 
     def _rotate(self, data):
         """given data in a table, need to get
--- ./athenaCL/libATH/temperament.py	(original)
+++ ./athenaCL/libATH/temperament.py	(refactored)
@@ -277,7 +277,7 @@
 def factory(rawArgs):
     name = temperamentNameParser(rawArgs)
     if name == None: 
-        raise ValueError, 'bad temperament name given: %s' % rawArgs # failure
+        raise ValueError('bad temperament name given: %s' % rawArgs) # failure
     modAttr = globals()[name]
     return modAttr()
     
--- ./athenaCL/libATH/typeset.py	(original)
+++ ./athenaCL/libATH/typeset.py	(refactored)
@@ -752,8 +752,8 @@
             
     def testFormatEqCol(self):
         material = [['test'], ['a', 'b']]
-        minColWidth = range(0, 20, 5)
-        charWidth = range(0, 20, 5)
+        minColWidth = list(range(0, 20, 5))
+        charWidth = list(range(0, 20, 5))
 
         for m in material:
             for mcw in minColWidth:
--- ./athenaCL/libATH/unit.py	(original)
+++ ./athenaCL/libATH/unit.py	(refactored)
@@ -36,7 +36,7 @@
     if seriesLen == 1:
         return series[0], series[0]
     elif seriesLen == 0:
-        raise ValueError, 'series with no values given'
+        raise ValueError('series with no values given')
     q = []
     for val in series:
         q.append(val)
@@ -215,7 +215,7 @@
     # note: negative values should be shifted to positive region first
     sum = 0
     for x in series:
-        if x < 0: raise ValueError, 'series members should be positive'
+        if x < 0: raise ValueError('series members should be positive')
         sum = sum + x
     assert sum != 0
     unit = [] # weights on the unit interval; sum == 1
@@ -695,7 +695,7 @@
                 posUpper = i
                 break
         # get lower
-        posArray = range(0, pos)
+        posArray = list(range(0, pos))
         posArray.reverse()
         for i in posArray:
             if self.binaryMap[i] == 1:
--- ./athenaCL/libATH/xmlTools.py	(original)
+++ ./athenaCL/libATH/xmlTools.py	(refactored)
@@ -55,8 +55,8 @@
     try:
         unicodeData = usrStr.decode('utf-8')
         msg = unicodeData.encode(encoding, 'xmlcharrefreplace')
-    except UnicodeDecodeError, e:
-        print _MOD, 'utf problem', usrStr
+    except UnicodeDecodeError as e:
+        print(_MOD, 'utf problem', usrStr)
         #raise ValueError, '%s: %s' % (e, usrStr)
         msg = usrStr
     # for some reason, some characters return strange results: 
@@ -76,7 +76,7 @@
 def paraToSgml(str):
     "convert text with \n marks into separate paragraphs"
     if str == None:
-        print _MOD, 'got None for a sgml para conversion'
+        print(_MOD, 'got None for a sgml para conversion')
         str = 'none: missing data.'
     lines = str.split('\n')
     newStr = ''
@@ -92,14 +92,14 @@
 def _dictionaryStrKey(data):
     """check to see this is a dictionary, and all keys are strings"""
     if drawer.isDict(data):# recurse into dictionary, use key as name
-        for key in data.keys():
+        for key in list(data.keys()):
             if not drawer.isStr(key):
                 return 0 # dictionary, but a key is not a string
         return 1 # all keys are strings, a dictionary
     return 0 # not a dictionary
 
 def _resolveOuterName(orient, tab, levelMatch, parentName, name):
-    matchKeys = levelMatch.keys()
+    matchKeys = list(levelMatch.keys())
     if 'all' in matchKeys or parentName in matchKeys:
         if parentName in matchKeys:
             levelName = levelMatch[parentName]
@@ -142,7 +142,7 @@
     tab = '\t' * indent
     msg.append(_resolveOuterName('open', tab, levelMatch, parentName, name))
 
-    keyList = dict.keys()
+    keyList = list(dict.keys())
     keyList.sort()
     for key in keyList:
         tab = '\t' * (indent + 1)
@@ -225,10 +225,10 @@
         temp = {}
         for xKey, (xValue, xFmt) in self.parameterList:
             temp[xKey] = xValue, xFmt
-        if key in temp.keys():
+        if key in list(temp.keys()):
             del temp[key]
         temp[key] = (value, fmt)
-        self.parameterList = temp.items() # restore as list
+        self.parameterList = list(temp.items()) # restore as list
         #print self.variableList
 
     def _getEntity(self):
@@ -237,7 +237,7 @@
         for fmt, group, url in self.entityList:
             dataStr.append('<!ENTITY %s %s "%s" CDATA DSSSL>\n' % (fmt, 
                                 group, url))
-            print 'xmlTools.py: dsl importing', url
+            print('xmlTools.py: dsl importing', url)
         return dataStr
 
     def _writeParameter(self):
@@ -314,10 +314,10 @@
         temp = {}
         for xKey, xValue in self.variableList:
             temp[xKey] = xValue
-        if key in temp.keys():
+        if key in list(temp.keys()):
             del temp[key]
         temp[key] = value
-        self.variableList = temp.items() # restore as list
+        self.variableList = list(temp.items()) # restore as list
         #print self.variableList
 
     def addParameter(self, key, value):
@@ -326,15 +326,15 @@
         temp = {}
         for xKey, xValue in self.parameterList:
             temp[xKey] = xValue
-        if key in temp.keys():
+        if key in list(temp.keys()):
             del temp[key]
         temp[key] = value
-        self.parameterList = temp.items() # restore as list
+        self.parameterList = list(temp.items()) # restore as list
         #print self.variableList
 
     def _writeImport(self):
         for url in self.importList:
-            print 'xmlTools.py: xsl importing', url
+            print('xmlTools.py: xsl importing', url)
             self.msg.append('''\
     <xsl:import href="%s"/>\n''' % url) # import base
 
--- ./athenaCL/libATH/libGfx/graphCellular.py	(original)
+++ ./athenaCL/libATH/libGfx/graphCellular.py	(refactored)
@@ -139,7 +139,7 @@
     if ca == None: return _MOD, 'error, no such ca available'
     
     ca.gen(ca.spec.get('y'))
-    print _MOD, 'values generated, drawing...\n%s' % ca.repr('full') 
+    print(_MOD, 'values generated, drawing...\n%s' % ca.repr('full')) 
     
     # more pixels causes more time
     obj = CAmapCanvas(None, ca.getCells('table', 0, ca.spec.get('s'), None, 
--- ./athenaCL/libATH/libGfx/graphEnsemble.py	(original)
+++ ./athenaCL/libATH/libGfx/graphEnsemble.py	(refactored)
@@ -69,10 +69,10 @@
 
         self.maxTime = self._findMaxTime(self.tiMapDict)
 
-        self.noEntries = len(self.tiMapDict.keys())
-        for textName in self.tiMapDict.keys(): #count clones
-            self.noEntries = self.noEntries + len(self.tiMapDict[       
-                                    textName]['cloneDict'].keys())
+        self.noEntries = len(list(self.tiMapDict.keys()))
+        for textName in list(self.tiMapDict.keys()): #count clones
+            self.noEntries = self.noEntries + len(list(self.tiMapDict[       
+                                    textName]['cloneDict'].keys()))
         self.noGutters = self.noEntries + 1
         self.mapGUTTER = 3 # in pixels
         self.headHeight = 2 # band at top of entry blocks
@@ -151,7 +151,7 @@
 
         # draw textures
         yPosition = self.tMarginSize + self.mapGUTTER # initial space
-        tNameList = self.tiMapDict.keys()
+        tNameList = list(self.tiMapDict.keys())
         tNameList.sort()
         for tName in tNameList:
             yEndPos = yPosition + self.widthEntry
@@ -188,7 +188,7 @@
             # shift down
             yPosition = yEndPos + self.mapGUTTER
             # clones
-            cNameList = self.tiMapDict[tName]['cloneDict'].keys()
+            cNameList = list(self.tiMapDict[tName]['cloneDict'].keys())
             cNameList.sort()
             for cName in cNameList:
                 yEndPos = yPosition + self.widthEntry
@@ -235,11 +235,11 @@
     # not on actual duration...
     def _findMaxTime(self, tiMapDict):
         maxTime = 0.0
-        for tiName in tiMapDict.keys():
+        for tiName in list(tiMapDict.keys()):
             s, e = tiMapDict[tiName]['tRange']
             if maxTime <= e:
                 maxTime = e
-            for cloneName in tiMapDict[tiName]['cloneDict'].keys():
+            for cloneName in list(tiMapDict[tiName]['cloneDict'].keys()):
                 s, e = tiMapDict[tiName]['cloneDict'][cloneName]['tRange']
                 if maxTime <= e:
                     maxTime = e
--- ./athenaCL/libATH/libGfx/graphPmtr.py	(original)
+++ ./athenaCL/libATH/libGfx/graphPmtr.py	(refactored)
@@ -309,7 +309,7 @@
 #-----------------------------------------------------------------||||||||||||--
 
 if __name__ == '__main__':
-    print 'test code must be re-done'
+    print('test code must be re-done')
     #TImap = TImapCanvas(None, None, None, 'pil')
     #TImap.show()
     #TImap2 = TImapCanvas(None, None, 'tk')
--- ./athenaCL/libATH/libOrc/baseOrc.py	(original)
+++ ./athenaCL/libATH/libOrc/baseOrc.py	(refactored)
@@ -94,7 +94,7 @@
         elif pmtr == 'ps': # ALWAYS map psReal values, regardless of orcMapMode
             val = self._postMapPs(iNo, val)
         else: # this shoudl never happen
-            raise ValueError, 'bad parameter name in orchestra'
+            raise ValueError('bad parameter name in orchestra')
         return val
         
     #-----------------------------------------------------------------------||--
@@ -148,7 +148,7 @@
         starting at auxQ0"""
         presetDict = {} # default values are set in TMclass.loadDefault
         # this corrects the labeling of aux fields to reflext that used later on
-        for key in self.pmtrDefault.keys(): # isolate pmtr fields
+        for key in list(self.pmtrDefault.keys()): # isolate pmtr fields
             if key[:4] == 'pmtr': # rename pmtr keys to a single auxQ
                 adjNum = int(key[4:]) - (self.pmtrCountDefault + 1)  # 7 = 0
                 newKey  = 'auxQ%i' % adjNum
--- ./athenaCL/libATH/libOrc/csoundNative.py	(original)
+++ ./athenaCL/libATH/libOrc/csoundNative.py	(refactored)
@@ -157,10 +157,10 @@
         return ''.join(msg)
 
     def getInstObj(self, iNo):
-        if iNo in self._instrObjDict.keys(): # already loaded
+        if iNo in list(self._instrObjDict.keys()): # already loaded
             return self._instrObjDict[iNo] # call attribute of module to get object
         else:
-            raise ValueError, 'bad insturment number given: %s' % iNo
+            raise ValueError('bad insturment number given: %s' % iNo)
             
     def getScoFtables(self):
         """public method as needed in score
@@ -192,7 +192,7 @@
             instList = self.instNoList()
         for number in instList:
             if not self.instNoValid(number):
-                print lang.WARN, 'instrument %i not available.' % number
+                print(lang.WARN, 'instrument %i not available.' % number)
                 continue
             instrObj = self.getInstObj(number)
             msg.append(instrObj.buildInstrDef(noChannels))
--- ./athenaCL/libATH/libOrc/generalMidi.py	(original)
+++ ./athenaCL/libATH/libOrc/generalMidi.py	(refactored)
@@ -69,7 +69,7 @@
     if pgmNum > 127:
         pgmName = 'unknown'
     else:
-        for name, num in gmProgramNames.items():
+        for name, num in list(gmProgramNames.items()):
             if num == pgmNum:
                 pgmName = name
                 break
@@ -86,12 +86,12 @@
     # its a string
     usrStr = drawer.strScrub(usrStr, 'L')
     scoreDict = {}
-    for name in gmProgramNames.keys():
+    for name in list(gmProgramNames.keys()):
         nameTest = name.lower()
         scoreDict[name] = nameTest.count(usrStr) # counts instances
     best = ('', 0) # name, score
     # go basck over items; name does have case
-    for name, score in scoreDict.items():
+    for name, score in list(scoreDict.items()):
         if score > best[1]:
             best = (name, score)
     if best[0] == '': # nothing found
@@ -113,7 +113,7 @@
     if midiInt < 35: midiInt = 35
     if midiInt > 81: midiInt = 81
     else:
-        for name, num in gmPercussionNames.items():
+        for name, num in list(gmPercussionNames.items()):
             if num == midiInt:
                 percName = name
                 break
@@ -123,18 +123,18 @@
     "for a given percussion name, find what note name is needed"
     foundName = None
     percStr = drawer.strScrub(percStr, 'L')
-    for name in gmPercussionNames.keys():
+    for name in list(gmPercussionNames.keys()):
         if percStr == name.lower():
             foundName = name
             break
     if foundName == None: # check again for partial matches
-        for name in gmPercussionNames.keys():
+        for name in list(gmPercussionNames.keys()):
             name = name.lower()
             if name.find(percStr) >= 0:
                 foundName = name
                 break
     if foundName == None:
-        print _MOD, 'cant find:', percStr
+        print(_MOD, 'cant find:', percStr)
     midiInt = gmPercussionNames[foundName]
     noteName = pitchTools.midiToNoteName(midiInt)
     return noteName # may be None on error
@@ -155,7 +155,7 @@
         baseOrc.Orchestra.__init__(self)
         self.name = 'generalMidi'
         self._dummyInst = InstrumentMidi()
-        self._instrNumbers = range(0, 128) # 127 program numbers
+        self._instrNumbers = list(range(0, 128)) # 127 program numbers
 
     def instNoValid(self, iNo):
         """test if an instrument number is valid"""
@@ -250,7 +250,7 @@
         self.name = 'generalMidiPercussion'
         self._dummyInst = InstrumentMidi()
         # instrument numbers are the pitch values
-        self._instrNumbers = range(35, 82) # 35-81 program numbers
+        self._instrNumbers = list(range(35, 82)) # 35-81 program numbers
 
     def getInstName(self, iNo):
         """over-ride from gm, as gotten from different dictionary"""
--- ./athenaCL/libATH/libOrc/orc.py	(original)
+++ ./athenaCL/libATH/libOrc/orc.py	(refactored)
@@ -62,7 +62,7 @@
     elif orcName == 'superColliderNative':
         return superColliderNative.SuperColliderNative()
     else:
-        raise ValueError, 'bad orchestra name: %s' % orcName
+        raise ValueError('bad orchestra name: %s' % orcName)
 
 #-----------------------------------------------------------------||||||||||||--
 
@@ -70,15 +70,15 @@
 class Test:
     def __init__(self):
         # call test methods
-        for orcName in orcNames.keys():
+        for orcName in list(orcNames.keys()):
             a = factory(orcName)
-            print
-            print a.name
+            print()
+            print(a.name)
             a.getInstInfo()
     
             if a.instNoList() != None:
                 for iNo in a.instNoList():
-                    print str(iNo).ljust(4), a.getInstName(iNo)
+                    print(str(iNo).ljust(4), a.getInstName(iNo))
                     a.getInstPreset(iNo)
     
             a.constructOrc()
@@ -93,7 +93,7 @@
         self.assertEqual(True, True)
 
     def testBuild(self):
-        for orcName in orcNames.keys():
+        for orcName in list(orcNames.keys()):
             a = factory(orcName)
             post = a.name
             post = a.getInstInfo()
--- ./athenaCL/libATH/libOrc/superColliderNative.py	(original)
+++ ./athenaCL/libATH/libOrc/superColliderNative.py	(refactored)
@@ -62,10 +62,10 @@
 
 
     def getInstObj(self, iNo):
-        if iNo in self._instrObjDict.keys(): # already loaded
+        if iNo in list(self._instrObjDict.keys()): # already loaded
             return self._instrObjDict[iNo] # call attribute of module to get object
         else:
-            raise ValueError, 'bad insturment number given: %s' % iNo
+            raise ValueError('bad insturment number given: %s' % iNo)
             
 
     def constructOrc(self, noChannels=2, instList=None):
@@ -246,9 +246,9 @@
           'pmtr8'   : ('bg', 'rc', [.1, .2, .3, .4]),
           'pmtr9'   : ('ru', 60, 120),
           }
-        self.auxNo = len(self.pmtrInfo.keys())
+        self.auxNo = len(list(self.pmtrInfo.keys()))
         self.pmtrFields = self.pmtrCountDefault + self.auxNo
-        self.pmtrFieldNames = ['sus', 'amp', 'pan'] + self.pmtrInfo.keys()
+        self.pmtrFieldNames = ['sus', 'amp', 'pan'] + list(self.pmtrInfo.keys())
 
         self.author = 'athenaCL native' # attribution
 
@@ -303,9 +303,9 @@
           'pmtr7'   : ('bg', 'rc', [3, 2, 1]),
           'pmtr8'   : ('bg', 'rc', [.02, .05]),
           }
-        self.auxNo = len(self.pmtrInfo.keys())
+        self.auxNo = len(list(self.pmtrInfo.keys()))
         self.pmtrFields = self.pmtrCountDefault + self.auxNo
-        self.pmtrFieldNames = ['sus', 'amp', 'pan', 'ps'] + self.pmtrInfo.keys()
+        self.pmtrFieldNames = ['sus', 'amp', 'pan', 'ps'] + list(self.pmtrInfo.keys())
 
         self.author = 'athenaCL native' # attribution
 
--- ./athenaCL/libATH/libPmtr/basePmtr.py	(original)
+++ ./athenaCL/libATH/libPmtr/basePmtr.py	(refactored)
@@ -143,8 +143,8 @@
         elif len(self.ref) == 1: self._direction = [0]
         elif len(self.ref) == 2: self._direction = [0,1]
         else:
-            self._direction = range(0, len(self.ref)) # 0,1,2
-            post = range(1, (len(self.ref)-1)) # 1,
+            self._direction = list(range(0, len(self.ref))) # 0,1,2
+            post = list(range(1, (len(self.ref)-1))) # 1,
             post.reverse() # second half of range
             self._direction = self._direction + post
             
@@ -244,7 +244,7 @@
         """
         # emergency check
         if len(self.ref) == 0:
-            raise IndexError, 'selector has no values'
+            raise IndexError('selector has no values')
         if self.control == 'randomChoice':
             return self._randomChoice()
         elif self.control == 'randomWalk':
@@ -258,7 +258,7 @@
         elif self.control == 'orderedOscillate':
             return self._orderedOscillate()
         else:
-            raise ValueError, 'no control for %s' % self.control
+            raise ValueError('no control for %s' % self.control)
 
 
 #-----------------------------------------------------------------||||||||||||--
@@ -310,7 +310,7 @@
         self.MARKOVLIMIT = 9 # limit order of markov analysis
         # store commonly used argument names and their extra documentation
         # may need to gather lists of options from other modules
-        _optListTable = table.tableMonoFormatRef.keys()
+        _optListTable = list(table.tableMonoFormatRef.keys())
         _optListTable.sort()
 
         # note: some of these values should be obtained from the parsers
@@ -386,7 +386,7 @@
                 count = count + 1
                 argSub.append('(%s) %s' % (count, argStr))
                 # see if more info is avail for this arg name
-                if argStr in self._argNameRef.keys():
+                if argStr in list(self._argNameRef.keys()):
                     argChoice = self._argNameRef[argStr]
                 if argChoice != None:
                     docSub = []
@@ -457,11 +457,11 @@
         from athenaCL.libATH.libPmtr import parameter
         try:
             obj = parameter.factory(arg, lib)
-        except error.ParameterObjectSyntaxError, msg:
+        except error.ParameterObjectSyntaxError as msg:
             if idStr == '':
-                raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+                raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
             else:
-                raise error.ParameterObjectSyntaxError, 'failed %s sub-parameter: %s' % (idStr, msg)            
+                raise error.ParameterObjectSyntaxError('failed %s sub-parameter: %s' % (idStr, msg))            
         return obj
         
     def _loadAutoConstant(self, arg, lib='genPmtrObjs'):
@@ -484,8 +484,8 @@
         from athenaCL.libATH.libPmtr import parameter
         try:
             obj = parameter.factory(pmtrArgs, lib)
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
         return obj
     
     def _loadAutoConstantStr(self, arg, ref, lib='genPmtrObjs'):
@@ -498,7 +498,7 @@
         elif drawer.isStr(arg):
             post = drawer.selectionParse(arg, ref, 0) # autosearch off
             if post == None:
-                raise error.ParameterObjectSyntaxError, 'no such preset name known.'
+                raise error.ParameterObjectSyntaxError('no such preset name known.')
             pmtrArgs = ('c', post) # a constant pmtr obj
         else: # its a list to create a ParameterObject
             pmtrArgs = arg
@@ -506,8 +506,8 @@
         from athenaCL.libATH.libPmtr import parameter
         try:
             obj = parameter.factory(pmtrArgs, lib)
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
         return obj   
     
     def _loadMinMax(self, min, max):
@@ -537,12 +537,12 @@
         from athenaCL.libATH.libPmtr import parameter
         try:
             minObj = parameter.factory(minArgs)
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
         try:
             maxObj = parameter.factory(maxArgs)
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
         return minObj, maxObj
 
 
@@ -580,7 +580,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad direction name: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad direction name: enter %s.' % selStr)
         return usrStr
     
     def _selectorParser(self, usrStr):
@@ -601,7 +601,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad selectionString: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad selectionString: enter %s.' % selStr)
         return usrStr
 
     def _loopControlParser(self, usrStr):
@@ -618,7 +618,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, "loop control is either %s." % selStr
+            raise error.ParameterObjectSyntaxError("loop control is either %s." % selStr)
         return usrStr # may be None
 
     def _stepControlParser(self, usrStr):
@@ -636,7 +636,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, "bad step control. enter %s." % selStr
+            raise error.ParameterObjectSyntaxError("bad step control. enter %s." % selStr)
         return usrStr # may be None
         
 
@@ -653,7 +653,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, "bad frame level control. enter %s." % selStr
+            raise error.ParameterObjectSyntaxError("bad frame level control. enter %s." % selStr)
         return usrStr # may be None
 
 
@@ -672,7 +672,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)      
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, "bad boundary method. enter %s." % selStr         
+            raise error.ParameterObjectSyntaxError("bad boundary method. enter %s." % selStr)         
         return usrStr # may be None
     
     def _onOffParser(self, usrStr):
@@ -689,7 +689,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def _anchorParser(self, usrStr):
@@ -707,7 +707,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def _scaleSwitchParser(self, usrStr):
@@ -724,7 +724,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, "bad step control. enter %s." % selStr
+            raise error.ParameterObjectSyntaxError("bad step control. enter %s." % selStr)
         return usrStr # may be None
         
 
@@ -742,7 +742,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
 
@@ -761,7 +761,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def _valueSelectTriParser(self, usrStr):
@@ -786,7 +786,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
         
@@ -804,7 +804,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def _typeFormatParser(self, usrStr):
@@ -816,7 +816,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
         
@@ -831,7 +831,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr        
         
 
@@ -852,7 +852,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr        
 
     def _selectLevelMonophonicParser(self, usrStr):
@@ -864,7 +864,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def _selectLevelPolyphonicParser(self, usrStr):
@@ -882,7 +882,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     # filter po converters needed here for backwards compat
@@ -896,7 +896,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def _selectTimeRefParser(self, usrStr):
@@ -913,7 +913,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
         
 
--- ./athenaCL/libATH/libPmtr/cloneFilter.py	(original)
+++ ./athenaCL/libATH/libPmtr/cloneFilter.py	(refactored)
@@ -145,8 +145,8 @@
         for argList in self.args[0]:
             try:
                 pmtrObj = parameter.factory(argList, 'filterPmtrObjs')
-            except error.ParameterObjectSyntaxError, msg:
-                raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+            except error.ParameterObjectSyntaxError as msg:
+                raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
             self.objArray.append(pmtrObj)
 
     def checkArgs(self):
@@ -254,7 +254,7 @@
             grid.append(abs(q))
         # accept redundant values, always take in order
         if grid == []: # this is a problem
-            print lang.WARN, self.type, 'supplying grid with default values'
+            print(lang.WARN, self.type, 'supplying grid with default values')
             grid.append(1) # give it something
         return grid
 
@@ -487,8 +487,8 @@
         from athenaCL.libATH.libPmtr import parameter
         try:
             self.pmtrObj = parameter.factory(self.args[0])
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
 
     def checkArgs(self):
         ok, msg = self.pmtrObj.checkArgs()
@@ -539,8 +539,8 @@
         try: # note: can be eithe gen or filter parameter object
             self.pmtrObj = parameter.factory(self.args[0], 
                                             [ 'genPmtrObjs','rthmPmtrObjs'])
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
 
     def checkArgs(self):
         ok, msg = self.pmtrObj.checkArgs()
@@ -672,8 +672,8 @@
         try:
             self.pmtrObj = parameter.factory(self.args[1], 
                                             ['genPmtrObjs', 'rthmPmtrObjs'])
-        except error.ParameterObjectSyntaxError, msg:
-            raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+        except error.ParameterObjectSyntaxError as msg:
+            raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
 
     def checkArgs(self):
         ok, msg = self.pmtrObj.checkArgs()
--- ./athenaCL/libATH/libPmtr/parameter.py	(original)
+++ ./athenaCL/libATH/libPmtr/parameter.py	(refactored)
@@ -261,11 +261,11 @@
 
 
 #-----------------------------------------------------------------||||||||||||--
-genPmtrObjs = genPmtrNames.values() # values are class names
-rthmPmtrObjs = rthmPmtrNames.values()
-textPmtrObjs = textPmtrNames.values()
-clonePmtrObjs = clonePmtrNames.values()
-filterPmtrObjs = filterPmtrNames.values()
+genPmtrObjs = list(genPmtrNames.values()) # values are class names
+rthmPmtrObjs = list(rthmPmtrNames.values())
+textPmtrObjs = list(textPmtrNames.values())
+clonePmtrObjs = list(clonePmtrNames.values())
+filterPmtrObjs = list(filterPmtrNames.values())
 
 # all parameter objects; juts the full names, as a list (no clashes)
 allPmtrObjs = (rthmPmtrObjs + genPmtrObjs + 
@@ -274,8 +274,8 @@
 allPmtrNames = {}
 for subDict in [genPmtrNames, rthmPmtrNames, textPmtrNames,
                 clonePmtrNames, filterPmtrNames]:
-    for key, value in subDict.items():
-        if key in allPmtrNames.keys():
+    for key, value in list(subDict.items()):
+        if key in list(allPmtrNames.keys()):
             raise Exception('found duplicated key: %s' % key)
         allPmtrNames[key] = value
 
@@ -315,7 +315,7 @@
     """
     parsed = drawer.acronymExpand(usrStr, pmtrLibNames)
     if parsed == None:
-        raise ValueError, 'bad parameter library provided: %s' % usrStr
+        raise ValueError('bad parameter library provided: %s' % usrStr)
     return parsed
     
 def pmtrLibTitle(libName):
@@ -337,7 +337,7 @@
     elif libName == None:
         name = 'All'
     else:
-        raise ValueError, 'bad parameter library provided: %s' % libName
+        raise ValueError('bad parameter library provided: %s' % libName)
     return '%s %s' % (name, 'ParameterObject')
 
 
@@ -359,7 +359,7 @@
     elif libName == 'filterPmtrObjs':
         data = filterPmtrNames
     else:
-        raise ValueError, 'bad parameter library provided: %s' % libName
+        raise ValueError('bad parameter library provided: %s' % libName)
 
     return data
 
@@ -380,7 +380,7 @@
     elif libName == 'filterPmtrObjs':
         data = filterPmtrObjs
     else:
-        raise ValueError, 'bad parameter library provided: %s' % libName
+        raise ValueError('bad parameter library provided: %s' % libName)
 
     data = list(data)
     data.sort()
@@ -405,9 +405,9 @@
     if ',' in pmtrName: # if a comma
         pmtrName = pmtrName.split(',')[0] # just get first, strip args
     found = None
-    for libName in pmtrLibNames.values():
+    for libName in list(pmtrLibNames.values()):
         pmtrNamesDict = pmtrLibNameToDict(libName)
-        for key, value in pmtrNamesDict.items():
+        for key, value in list(pmtrNamesDict.items()):
             if pmtrName == key.lower() or pmtrName == value.lower():
                 found = libName
                 break
@@ -451,16 +451,16 @@
         pmtrNames = allPmtrNames
 
     else:
-        raise error.ParameterObjectSyntaxError, 'no parameter library named: %r' % libName
-
-    for key in pmtrNames.keys():
+        raise error.ParameterObjectSyntaxError('no parameter library named: %r' % libName)
+
+    for key in list(pmtrNames.keys()):
         className = pmtrNames[key]
         if usrStr == key:
             return className
         elif usrStr == className.lower():
             return className
     # if not mattched, raise an error
-    raise error.ParameterObjectSyntaxError, 'no parameter named %r in %s' % (usrStr, pmtrLibTitle(libName)) 
+    raise error.ParameterObjectSyntaxError('no parameter named %r in %s' % (usrStr, pmtrLibTitle(libName))) 
 
 #-----------------------------------------------------------------||||||||||||--
 # arguments for parameter objects are assigned at creation of object
@@ -484,7 +484,7 @@
     objType = pmtrTypeParser(usrStr, libName) #check type string
     # fix case, capitalize lead character:
     if objType == None: 
-        raise error.ParameterObjectSyntaxError, 'name error: no parameter named %r' % usrStr 
+        raise error.ParameterObjectSyntaxError('name error: no parameter named %r' % usrStr) 
     objType = objType[0].upper() + objType[1:]
     modFound = None
     # this actually looks through external module files
@@ -495,7 +495,7 @@
             modFound = mod
             break
     if modFound == None:# failure
-        raise error.ParameterObjectSyntaxError, 'name error: no parameter named %r' % usrStr
+        raise error.ParameterObjectSyntaxError('name error: no parameter named %r' % usrStr)
     # return reference to object, and string name of object
     # may want to retrun objType first char to lower case?
     return modFound, objType
@@ -537,12 +537,12 @@
 
         try: # will raise exception on error
             mod, modStr = locator(objType, name) #check type string
-        except error.ParameterObjectSyntaxError, e: modStr = None
+        except error.ParameterObjectSyntaxError as e: modStr = None
         if modStr == None:
             if i != len(libOpt) - 1:
                 continue # if not the last one to try
             else:
-                raise error.ParameterObjectSyntaxError, 'parameter lib error (%s: %s, %s, %s)' % (name, objType, modStr, rawArgs) 
+                raise error.ParameterObjectSyntaxError('parameter lib error (%s: %s, %s, %s)' % (name, objType, modStr, rawArgs)) 
         else: # got a good object
             break
             # failure
@@ -585,11 +585,11 @@
 
 
     def testLocator(self):
-        for key, value in allPmtrNames.items():
+        for key, value in list(allPmtrNames.items()):
             self.assertEqual(locator(key)[1].lower(), value.lower())
 
     def testFactory(self):
-        for key, value in allPmtrNames.items():
+        for key, value in list(allPmtrNames.items()):
             post = factory(key)
 
 
--- ./athenaCL/libATH/libPmtr/rhythmSingle.py	(original)
+++ ./athenaCL/libATH/libPmtr/rhythmSingle.py	(refactored)
@@ -45,10 +45,10 @@
         try:
             self.rObj = rhythm.Rhythm(self.args[0])  # first arg list of rhtyhms
         except error.PulseSyntaxError:
-            raise error.ParameterObjectSyntaxError, "enter a list of two pulse objects."
+            raise error.ParameterObjectSyntaxError("enter a list of two pulse objects.")
         #self.rObj = self._expandRhythm(self.rObj)
         if len(self.rObj) != 2:
-            raise error.ParameterObjectSyntaxError, "enter a list of two pulse objects."
+            raise error.ParameterObjectSyntaxError("enter a list of two pulse objects.")
         # set sustain mults for each pulse
         self.rObj[0].setSus(1.4)
         self.rObj[1].setSus(1.6)
@@ -129,7 +129,7 @@
         except ValueError:
             self.genome = None # this will return error when args checked
         if self.genome == None:
-            raise error.ParameterObjectSyntaxError, 'genome failed to be populated.'
+            raise error.ParameterObjectSyntaxError('genome failed to be populated.')
 
         self.rObjBundle = [] # stores list of rhythms, by family
         self.pulseBundle = [] # stores all pulses as one list
@@ -205,7 +205,7 @@
         try:
             self.rObj = rhythm.Rhythm(self.args[0])
         except error.PulseSyntaxError:
-            raise error.ParameterObjectSyntaxError, "enter a list of pulse objects."
+            raise error.ParameterObjectSyntaxError("enter a list of pulse objects.")
         for r in range(0, len(self.rObj)):
             self.rObj[r].setSus(.94) # set constant sustain, was 98, but still cut
 
@@ -451,16 +451,16 @@
         
         self.currentPulse = None # init value, used in getCurrentRhythm     
         self.length = abs(int(round(self.args[1])))
-        self.z = range(0, self.length)
+        self.z = list(range(0, self.length))
         try:
             self.sieveObj = sieve.Sieve(self.args[0], self.z)
         except AttributeError: 
-            raise error.ParameterObjectSyntaxError, "incorrect sieve syntax."
+            raise error.ParameterObjectSyntaxError("incorrect sieve syntax.")
 
         try:
             self.pulseObj = rhythm.Pulse(self.args[2])
         except error.PulseSyntaxError:
-            raise error.ParameterObjectSyntaxError, "incorrect sieve syntax."
+            raise error.ParameterObjectSyntaxError("incorrect sieve syntax.")
         self.pulseObj.setSus(.94) # no sustain
 
         self.pulseOn = self.pulseObj.copy()
@@ -542,11 +542,11 @@
         
         self.currentPulse = None # init value, used in getCurrentRhythm     
         self.length = abs(int(round(self.args[1])))
-        self.z = range(0, self.length)
+        self.z = list(range(0, self.length))
         try:
             self.sieveObj = sieve.Sieve(self.args[0], self.z)
         except AttributeError: 
-            raise error.ParameterObjectSyntaxError, "incorrect sieve syntax."
+            raise error.ParameterObjectSyntaxError("incorrect sieve syntax.")
 
         # NOTE: update this to use binary segment
         # gets a binary representawtion
@@ -626,8 +626,8 @@
         self.markovObj = markov.Transition() # creat obj w/o loading
         try:
             self.markovObj.loadTransition(self.args[0])
-        except error.TransitionSyntaxError, e: 
-            raise error.ParameterObjectSyntaxError, 'Markov transition creation failed: %s' % e
+        except error.TransitionSyntaxError as e: 
+            raise error.ParameterObjectSyntaxError('Markov transition creation failed: %s' % e)
         # will raise error
         self.orderObj = self._loadSub(self.args[1], 'genPmtrObjs')
         # need to store accumulated values
@@ -639,8 +639,8 @@
         for key in self.markovObj.getSignified():
             try:
                 pulseObj = rhythm.Pulse(key) # let guess pulse type
-            except error.PulseSyntaxError, e:
-                raise error.ParameterObjectSyntaxError, 'failed pulse object definition: %s' % e
+            except error.PulseSyntaxError as e:
+                raise error.ParameterObjectSyntaxError('failed pulse object definition: %s' % e)
             self.pulseRef[key] = pulseObj # store objs
 
     def checkArgs(self):
@@ -832,7 +832,7 @@
                 # force the selection of a new value, examin results
                 failCount = failCount + 1        
                 if failCount > self.FAILLIMIT and self.valueBuffer == []:
-                    print lang.WARN, self.type, 'no values obtained; supplying value'
+                    print(lang.WARN, self.type, 'no values obtained; supplying value')
                     valTriple = self.rthmObj(t, refDict)
                     valObj = self.rthmObj.currentPulse
                     self.valueBuffer.append((valTriple, valObj))
@@ -880,15 +880,15 @@
         for argList in self.args[0]:
             try:
                 pmtrObj = parameter.factory(argList, 'rthmPmtrObjs')
-            except error.ParameterObjectSyntaxError, msg:
-                raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+            except error.ParameterObjectSyntaxError as msg:
+                raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
             self.objArray.append(pmtrObj)
         
         self.countObj = self._loadSub(self.args[1], 'genPmtrObjs')   
         # check control string
         self.control = self._selectorParser(self.args[2]) 
         # create a selector that returns indix values for objArray
-        self.selector = basePmtr.Selector(range(len(self.objArray)), self.control)
+        self.selector = basePmtr.Selector(list(range(len(self.objArray))), self.control)
 
 
     def checkArgs(self):
@@ -940,7 +940,7 @@
                 # force the selection of a new value, examine results
                 failCount = failCount + 1        
                 if failCount > self.FAILLIMIT and self.valueBuffer == []:
-                    print lang.WARN, self.type, 'no values obtained; supplying value'
+                    print(lang.WARN, self.type, 'no values obtained; supplying value')
                     valTriple = self.objArray[pos](t, refDict)
                     valObj = self.objArray[pos].currentPulse
                     self.valueBuffer.append((valTriple, valObj))
--- ./athenaCL/libATH/libPmtr/textureStatic.py	(original)
+++ ./athenaCL/libATH/libPmtr/textureStatic.py	(refactored)
@@ -393,7 +393,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def checkArgs(self):
@@ -428,7 +428,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def checkArgs(self):
@@ -463,7 +463,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def checkArgs(self):
@@ -522,7 +522,7 @@
         usrStr = drawer.selectionParse(usrStr, ref)
         if usrStr == None:
             selStr = drawer.selectionParseKeyLabel(ref)
-            raise error.ParameterObjectSyntaxError, 'bad control value: enter %s.' % selStr
+            raise error.ParameterObjectSyntaxError('bad control value: enter %s.' % selStr)
         return usrStr
 
     def checkArgs(self):
--- ./athenaCL/libATH/libPmtr/valueFile.py	(original)
+++ ./athenaCL/libATH/libPmtr/valueFile.py	(refactored)
@@ -132,13 +132,13 @@
             path = self._findFile(self.filePathList, fileName)
             if path == None:
                 if fileName not in missingReport:
-                    print lang.WARN, 'missing file %s' % fileName
+                    print(lang.WARN, 'missing file %s' % fileName)
                 missingReport.append(fileName)
                 #path = os.path.join(self.dirList[0], 'error') # defualt error!
                 count = count + 1 
                 if count > self.FAILLIMIT:
                     path = 'error.aif'
-                    print lang.WARN, 'supplying default: %s' % path
+                    print(lang.WARN, 'supplying default: %s' % path)
                     break
                 else:
                     continue
--- ./athenaCL/libATH/libPmtr/valueSingle.py	(original)
+++ ./athenaCL/libATH/libPmtr/valueSingle.py	(refactored)
@@ -103,7 +103,7 @@
         self.tEnd   = self.args[0][1]
 
         if not drawer.isNum(self.tStart) or not drawer.isNum(self.tEnd):
-            raise error.ParameterObjectSyntaxError, 'time range values must be numbers.'
+            raise error.ParameterObjectSyntaxError('time range values must be numbers.')
 
     def checkArgs(self):
         if self.tStart == self.tEnd:
@@ -473,7 +473,7 @@
         if ok == 0: raise error.ParameterObjectSyntaxError(msg) # report error
 
         try: self.sieveObj = sieve.Sieve(self.args[0])
-        except AttributeError: raise error.ParameterObjectSyntaxError, 'sieve creation failed'
+        except AttributeError: raise error.ParameterObjectSyntaxError('sieve creation failed')
 
         a = self.args[1]
         b = self.args[2]
@@ -483,8 +483,8 @@
         elif a < b:
             self.zMin = a
             self.zMax = b
-        else: raise error.ParameterObjectSyntaxError, 'zMin must not be equal to zMax'
-        self.z = range(self.zMin, self.zMax+1)
+        else: raise error.ParameterObjectSyntaxError('zMin must not be equal to zMax')
+        self.z = list(range(self.zMin, self.zMax+1))
         self.length = len(self.z)
         
         self.format = self._sieveFormatParser(self.args[3])     
@@ -542,10 +542,10 @@
         if ok == 0: raise error.ParameterObjectSyntaxError(msg) # report error
 
         try: self.sieveObj = sieve.Sieve(self.args[0])
-        except AttributeError: raise error.ParameterObjectSyntaxError, 'sieve creation failed'
+        except AttributeError: raise error.ParameterObjectSyntaxError('sieve creation failed')
 
         self.length = int(self.args[1])
-        self.z = range(0, abs(self.length))
+        self.z = list(range(0, abs(self.length)))
         self.normSeries = self.sieveObj(0, self.z, 'unit')
         #self.normSeries = unit.unitNormRange(self.sieveSeg)
         if self.args[1] < 0: # a negative length reverses the series
@@ -614,10 +614,10 @@
         if ok == 0: raise error.ParameterObjectSyntaxError(msg) # report error
 
         try: self.sieveObj = sieve.Sieve(self.args[0])
-        except AttributeError: raise error.ParameterObjectSyntaxError, 'sieve creation failed'
+        except AttributeError: raise error.ParameterObjectSyntaxError('sieve creation failed')
 
         self.length = int(self.args[1])
-        self.z = range(0, abs(self.length))
+        self.z = list(range(0, abs(self.length)))
         # NOTE: this needs to be updated to use a unit sieve segment
         self.sieveSeg = self.sieveObj(0, self.z)
         self.normSeries = unit.unitNormRange(self.sieveSeg)
@@ -693,7 +693,7 @@
         self.format = self._sieveFormatParser(self.args[2])
 
         if self.length > 999999: # a million values is too many!     
-            raise error.ParameterObjectSyntaxError, 'length value exceeds a practical range'
+            raise error.ParameterObjectSyntaxError('length value exceeds a practical range')
         
         # process prime segment
         self.obj = sieve.PrimeSegment(self.start, abs(self.length))
@@ -751,7 +751,7 @@
         self.length = self.args[1]
 
         if self.length > 999999: # a million values is too many!     
-            raise error.ParameterObjectSyntaxError, 'length value exceeds a practical range'
+            raise error.ParameterObjectSyntaxError('length value exceeds a practical range')
 
         # process prime segment
         self.obj = sieve.PrimeSegment(self.start, abs(self.length))
@@ -832,7 +832,7 @@
         self.mutation = self._loadSub(mutation, 'genPmtrObjs')
         
         self.tableFormat = table.monoFormatParser(self.args[3]) # raises exception
-        if self.tableFormat == None: raise error.ParameterObjectSyntaxError, 'bad table format'
+        if self.tableFormat == None: raise error.ParameterObjectSyntaxError('bad table format')
     
         # run ca only on init
         ruleStart = self.rule(0, self._refDictSim)
@@ -840,8 +840,8 @@
 
         try:
             self.ca = automata.factory(self.args[0], ruleStart, mutationStart)
-        except error.AutomataSpecificationError, e:
-            raise error.ParameterObjectSyntaxError, 'error in CA specification: %s' % e
+        except error.AutomataSpecificationError as e:
+            raise error.ParameterObjectSyntaxError('error in CA specification: %s' % e)
 
         # must supply yTotal here to get generations w/ skip
         for i in range(1, self.ca.spec.get('yTotal')): # already got zero
@@ -910,7 +910,7 @@
         self.mutation = self._loadSub(mutation, 'genPmtrObjs')
         
         self.tableFormat = table.monoFormatParser(self.args[3]) # raises exception
-        if self.tableFormat == None: raise error.ParameterObjectSyntaxError, 'bad table format'
+        if self.tableFormat == None: raise error.ParameterObjectSyntaxError('bad table format')
     
         # run ca only on init
         ruleStart = self.rule(0, self._refDictSim)
@@ -918,8 +918,8 @@
 
         try:
             self.ca = automata.factory(self.args[0], ruleStart, mutationStart)
-        except error.AutomataSpecificationError, e:
-            raise error.ParameterObjectSyntaxError, 'error in CA specification: %s' % e
+        except error.AutomataSpecificationError as e:
+            raise error.ParameterObjectSyntaxError('error in CA specification: %s' % e)
 
         # must supply yTotal here to get generations w/ skip
         for i in range(1, self.ca.spec.get('yTotal')): # already got zero
@@ -1442,7 +1442,7 @@
         elif self.format == 'string':
             self.outputFmt = 'str' # declare outputFmt as string
         else:
-            raise AttributeError, 'bad typeFormat given: %s', self.format   
+            raise AttributeError('bad typeFormat given: %s').with_traceback(self.format)   
 
     def checkArgs(self):
         ok, msg = self.pmtrObj.checkArgs()
@@ -1464,7 +1464,7 @@
         elif self.format == 'string':
             self.currentValue = '%s' % src
         else:
-            raise AttributeError, 'bad typeFormat given: %s', self.format                
+            raise AttributeError('bad typeFormat given: %s').with_traceback(self.format)                
 
         return self.currentValue
 
@@ -1751,15 +1751,15 @@
         for argList in self.args[0]:
             try:
                 pmtrObj = parameter.factory(argList, 'genPmtrObjs')
-            except error.ParameterObjectSyntaxError, msg:
-                raise error.ParameterObjectSyntaxError, 'failed sub-parameter: %s' % msg
+            except error.ParameterObjectSyntaxError as msg:
+                raise error.ParameterObjectSyntaxError('failed sub-parameter: %s' % msg)
             self.objArray.append(pmtrObj)
             
         self.countObj = self._loadSub(self.args[1], 'genPmtrObjs')   
         # check control string
         self.control = self._selectorParser(self.args[2]) 
         # create a selector that returns indix values for objArray
-        self.selector = basePmtr.Selector(range(len(self.objArray)), self.control)
+        self.selector = basePmtr.Selector(list(range(len(self.objArray))), self.control)
 
     def checkArgs(self):
         ok, msg = self.countObj.checkArgs()
@@ -1806,7 +1806,7 @@
                 # force the selection of a new value, examine results
                 failCount = failCount + 1        
                 if failCount > self.FAILLIMIT and self.valueBuffer == []:
-                    print lang.WARN, self.type, 'no values obtained; supplying value'
+                    print(lang.WARN, self.type, 'no values obtained; supplying value')
                     self.valueBuffer.append(self.objArray[pos](t, refDict))
                 # leave loop if values in buffer
                 if self.valueBuffer != []: break
@@ -1871,7 +1871,7 @@
                 # force the selection of a new value, examin results
                 failCount = failCount + 1        
                 if failCount > self.FAILLIMIT and self.valueBuffer == []:
-                    print lang.WARN, self.type, 'no values obtained; supplying value'
+                    print(lang.WARN, self.type, 'no values obtained; supplying value')
                     self.valueBuffer.append(self.genObj(t, refDict))
                 # leave loop of values in buffer
                 if self.valueBuffer != []: break
@@ -2295,7 +2295,7 @@
             grid.append(abs(q))
         # accept redundant values, always take in order
         if grid == []: # this is a problem
-            print lang.WARN, self.type, 'supplying grid with default values'
+            print(lang.WARN, self.type, 'supplying grid with default values')
             grid.append(1) # give it something
         return grid
         
@@ -2327,8 +2327,8 @@
         self.markovObj = markov.Transition() # creat obj w/o loading
         try:
             self.markovObj.loadTransition(self.args[0])
-        except error.TransitionSyntaxError, e: 
-            raise error.ParameterObjectSyntaxError, 'Markov transition creation failed: %s' % e
+        except error.TransitionSyntaxError as e: 
+            raise error.ParameterObjectSyntaxError('Markov transition creation failed: %s' % e)
         self.orderObj = self._loadSub(self.args[1], 'genPmtrObjs')
         # need to store accumulated values
         self.accum = []
@@ -2485,7 +2485,7 @@
         self.grammarObj = grammar.Grammar() # creat obj w/o loading
         try:
             self.grammarObj.load(self.args[0])
-        except error.TransitionSyntaxError, e: 
+        except error.TransitionSyntaxError as e: 
             raise error.ParameterObjectSyntaxError('Grammar creation failed: %s' % e)
 
         self.valueCount = int(self.args[1])
@@ -2493,7 +2493,7 @@
 
         # perform generations
         for i in range(self.valueCount):
-            self.grammarObj.next()
+            next(self.grammarObj)
 
         self.selector = basePmtr.Selector(
                         self.grammarObj.getState(values=True), self.control)
@@ -2536,7 +2536,7 @@
             self.feedbackType = feedback.libraryParser(self.args[0])
             self.feedbackObj = feedback.factory(self.feedbackType)
             self.feedbackObj.fillSensorProducer()
-        except feedback.FeedbackError, e: 
+        except feedback.FeedbackError as e: 
             raise error.ParameterObjectSyntaxError('Feedback object creation failed: %s' % e)
 
         self.ageObj = self._loadSub(self.args[1], 'genPmtrObjs') 
--- ./athenaCL/libATH/libPmtr/valueSingleOmde.py	(original)
+++ ./athenaCL/libATH/libPmtr/valueSingleOmde.py	(refactored)
@@ -45,7 +45,7 @@
         
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
                 
         self.step = self._stepControlParser(self.args[0]) # raises exception 
         self.spcObj = self._loadAutoConstant(self.args[1])
@@ -251,7 +251,7 @@
 
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
         
         self.step = self._stepControlParser(self.args[0]) # raises except on error
         self.spcObj = self._loadAutoConstant(self.args[1])
@@ -341,7 +341,7 @@
         self.argDefaults = [0, 1]
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
         self.minObj, self.maxObj = self._loadMinMax(self.args[0], self.args[1])
         self.obj = None #assigned in subclass
 
@@ -419,7 +419,7 @@
         self.argDefaults = [.5, 0, 1]
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
         self.lambd = float(self.args[0]) # needs to be a float
         self.minObj, self.maxObj = self._loadMinMax(self.args[1], self.args[2])
         self.obj = None #assigned in subclass
@@ -492,7 +492,7 @@
         self.argDefaults = [.5, .5, 0, 1]
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         self.argA = float(self.args[0]) # needs to be a float
         self.argB = float(self.args[1]) # needs to be a float
@@ -564,7 +564,7 @@
                              ]
         if self.argA >= 20 or self.argB >= 20:
             msg = 'alpha and beta should not be greater than 20.'
-            raise(error.ParameterObjectSyntaxError(msg))      
+            raise error      
         self.obj = rand.WeibullRandom(self.argA, self.argB) #omde object
 
 
@@ -581,7 +581,7 @@
                                   ((0,1),(6,.3),(12,.3),(18,0),(24,.6)), -1.5]
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         # raises except on error
         self.step = self._stepControlParser(self.args[0]) 
@@ -590,7 +590,7 @@
         self.points = self.args[2]
         ok, msg = self._scrubPoints() # not sure what to do if it fails
         if ok != 1:
-            raise(error.ParameterObjectSyntaxError(msg))
+            raise error
 
         self.exp = 1 # only used in power
         if len(self.args) >= 4:
@@ -766,7 +766,7 @@
                                               ['bg','rc',(0,.25,.5,.75,1)], 60, -1.5]
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         self.step = self._stepControlParser(self.args[0]) # raises except on error
         self.loop = self._loopControlParser(self.args[1]) # raises except on error
@@ -779,9 +779,9 @@
 
         # gen points, scrub, and sort
         ok, msg = self._genPoints(refDict)
-        if ok != 1: raise(error.ParameterObjectSyntaxError(msg))
+        if ok != 1: raise error
         ok, msg = self._scrubPoints() # not sure what to do if it fails
-        if ok != 1: raise(error.ParameterObjectSyntaxError(msg))
+        if ok != 1: raise error
 
         self.exp = 1 # only used in power
         if len(self.args) >= 6:
@@ -972,7 +972,7 @@
 
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         # raises except on error
         self.step = self._stepControlParser(self.args[0]) 
@@ -991,7 +991,7 @@
         if lineSpan == 0: # try  another point
             lineSpan = self.spcObj(i, refDict)
         if lineSpan == 0:
-            raise(error.ParameterObjectSyntaxError('seconds per cycle parameter object returns zero.'))
+            raise error
 
         self.xEnd = self.xStart + lineSpan
         yStart = self.minObj(i, refDict)
@@ -1099,7 +1099,7 @@
 
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         # proportional absolute switch
         self.propAbsSwitch = self._scaleSwitchParser(self.args[0]) 
@@ -1117,7 +1117,7 @@
         self.points = None
         # gen points, scrub, and sort
         ok, msg = self._genPoints(refDict)
-        if ok != 1: raise(error.ParameterObjectSyntaxError(msg))
+        if ok != 1: raise error
         self.obj = None #assigned in subclass
         self._setObj()
 
@@ -1228,7 +1228,7 @@
 
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         # proportional absolute switch
         self.loop = self._loopControlParser(self.args[0]) # raises except on error
@@ -1243,7 +1243,7 @@
         self.points = None
         # gen points, scrub, and sort
         ok, msg = self._genPoints(refDict)
-        if ok != 1: raise(error.ParameterObjectSyntaxError(msg))
+        if ok != 1: raise error
         self.obj = None #assigned in subclass
         self._setObj()
 
@@ -1347,7 +1347,7 @@
 
         # check raw arguments for number, type
         ok, msg = self._checkRawArgs()
-        if ok == 0: raise(error.ParameterObjectSyntaxError(msg)) # report error
+        if ok == 0: raise error # report error
 
         # proportional absolute switch
         self.propAbsSwitch = self._scaleSwitchParser(self.args[0]) 
@@ -1366,7 +1366,7 @@
         self.points = None
         # gen points, scrub, and sort
         ok, msg = self._genPoints(refDict)
-        if ok != 1: raise(error.ParameterObjectSyntaxError(msg))
+        if ok != 1: raise error
         self.obj = None #assigned in subclass
         self._setObj()
 
--- ./athenaCL/libATH/libTM/HarmonicShuffle.py	(original)
+++ ./athenaCL/libATH/libTM/HarmonicShuffle.py	(refactored)
@@ -75,7 +75,7 @@
         textOctaveLevel = self.getTextStatic('lop', 'level')     
   
         pLen = self.getPathLen()
-        selectorMultisetPos = basePmtr.Selector(range(pLen),
+        selectorMultisetPos = basePmtr.Selector(list(range(pLen)),
                                                          textMultisetSelectorControl)
 
         # random generator for creating offset in vetical attacks
@@ -106,7 +106,7 @@
 
                 # create a selector to get pitches from chord as index values
                 # only need to create one for each chord
-                selectorChordPos = basePmtr.Selector(range(len(chordCurrent)),
+                selectorChordPos = basePmtr.Selector(list(range(len(chordCurrent))),
                                                                  textPitchSelectorControl)
 
                 # determine how many pitches in this simultaneity
--- ./athenaCL/libATH/libTM/InterpolateFill.py	(original)
+++ ./athenaCL/libATH/libTM/InterpolateFill.py	(refactored)
@@ -144,7 +144,7 @@
                 tStartSet, tEndSet = self.getTimeRange() # value relative to start
 
             # create a generator to get pitches from chord as index values
-            selectorChordPos = basePmtr.Selector(range(len(chordCurrent)),
+            selectorChordPos = basePmtr.Selector(list(range(len(chordCurrent))),
                                                              textPitchSelectorControl)
             # real set start is always the formal start time here
             tCurrent = copy.deepcopy(tStartSet)
--- ./athenaCL/libATH/libTM/InterpolateLine.py	(original)
+++ ./athenaCL/libATH/libTM/InterpolateLine.py	(refactored)
@@ -118,7 +118,7 @@
             multisetCurrent = self.getMultiset(pathPos)
 
             tStartSet, tEndSet = self.clockPoints()
-            selectorChordPos = basePmtr.Selector(range(len(chordCurrent)),
+            selectorChordPos = basePmtr.Selector(list(range(len(chordCurrent))),
                                                              textPitchSelectorControl)
             tStartSetReal = copy.deepcopy(tCurrent)
             self.stateUpdate(tCurrent, chordCurrent, None, 
--- ./athenaCL/libATH/libTM/IntervalExpansion.py	(original)
+++ ./athenaCL/libATH/libTM/IntervalExpansion.py	(refactored)
@@ -143,7 +143,7 @@
                                 }
 
     def _ornGroupNames(self):
-        ornList = self.ornGroupLib.keys() 
+        ornList = list(self.ornGroupLib.keys()) 
         ornList.append('off') # add off option
         return ornList
 
--- ./athenaCL/libATH/libTM/LineCluster.py	(original)
+++ ./athenaCL/libATH/libTM/LineCluster.py	(refactored)
@@ -71,7 +71,7 @@
             tStartSet, tEndSet = self.clockPoints() 
 #             if textNonRedundantSwitch == 'on': selectorControl = 'randomPermutate'
 #             else: selectorControl = 'randomChoice'
-            selectorChordPos = basePmtr.Selector(range(len(chordCurrent)),
+            selectorChordPos = basePmtr.Selector(list(range(len(chordCurrent))),
                                                              textPitchSelectorControl)
             tStartSetReal = copy.deepcopy(tCurrent)
             self.stateUpdate(tCurrent, chordCurrent, None, 
--- ./athenaCL/libATH/libTM/LineGroove.py	(original)
+++ ./athenaCL/libATH/libTM/LineGroove.py	(refactored)
@@ -62,7 +62,7 @@
             multisetCurrent = self.getMultiset(pathPos)
 
             tStartSet, tEndSet = self.clockPoints()
-            selectorChordPos = basePmtr.Selector(range(len(chordCurrent)),
+            selectorChordPos = basePmtr.Selector(list(range(len(chordCurrent))),
                                                              textPitchSelectorControl)
             tStartSetReal = copy.deepcopy(tCurrent)
             self.stateUpdate(tCurrent, chordCurrent, None, 
--- ./athenaCL/libATH/libTM/MonophonicOrnament.py	(original)
+++ ./athenaCL/libATH/libTM/MonophonicOrnament.py	(refactored)
@@ -101,7 +101,7 @@
                                 }
 
     def _ornGroupNames(self):
-        ornList = self.ornGroupLib.keys() 
+        ornList = list(self.ornGroupLib.keys()) 
         ornList.append('off') # add off option
         return ornList
 
--- ./athenaCL/libATH/libTM/TimeFill.py	(original)
+++ ./athenaCL/libATH/libTM/TimeFill.py	(refactored)
@@ -94,7 +94,7 @@
                 tStartSet, tEndSet = self.getTimeRange() # value relative to path
 
             # create a generator to get pitches from chord as index values
-            selectorChordPos = basePmtr.Selector(range(len(chordCurrent)),
+            selectorChordPos = basePmtr.Selector(list(range(len(chordCurrent))),
                                               textPitchSelectorControl)
             # real set start is always the formal start time here
             tCurrent = copy.deepcopy(tStartSet)
--- ./athenaCL/libATH/libTM/TimeSegment.py	(original)
+++ ./athenaCL/libATH/libTM/TimeSegment.py	(refactored)
@@ -198,7 +198,7 @@
                 tCurrent = unit.denorm(tUnit, tStartSeg, tEndSeg)
                 pathPos = self.clockFindPos(tCurrent) # get pos for current time
                 if pathPos == None: 
-                    raise ValueError, 'tCurrent out of all time ranges'
+                    raise ValueError('tCurrent out of all time ranges')
     
                 #print _MOD, 'pp, tc', pathPos, tCurrent
                 #print _MOD, 'tss, tes', tStartSeg, tEndSeg
@@ -208,7 +208,7 @@
                 multisetCurrent = self.getMultiset(pathPos)
     
                 # create a generator to get pitches from chord as index values
-                selectorChordPos = basePmtr.Selector(range(0,len(chordCurrent)),
+                selectorChordPos = basePmtr.Selector(list(range(0,len(chordCurrent))),
                                                                  textPitchSelectorControl)
     
                 # choose pc from chord
--- ./athenaCL/libATH/libTM/baseTexture.py	(original)
+++ ./athenaCL/libATH/libTM/baseTexture.py	(refactored)
@@ -216,7 +216,7 @@
         if usrStr not in self.textLabels:
             # try to match by parameter obj name
             usrStr = drawer.strScrub(usrStr, 'lower')
-            for key in parameter.textPmtrNames.keys():
+            for key in list(parameter.textPmtrNames.keys()):
                 if usrStr == key: # get long name
                     usrStr = parameter.textPmtrNames[key]
                     break
@@ -228,7 +228,7 @@
                     found = 1
                     break
             if not found:
-                raise ValueError, 'unknown label name for static parameter'
+                raise ValueError('unknown label name for static parameter')
         return usrStr
 
     def findTextDynamicLabel(self, usrStr):
@@ -266,7 +266,7 @@
         """this only supplies names, which wil load defaults"""
         for i, textLabel in basePmtr.textLabel(self.textPmtrNo, 1):
             # add arg list default if missing to pmtrQdict
-            if not self.pmtrQDict.has_key(textLabel):
+            if textLabel not in self.pmtrQDict:
                 args = [self.textPmtrNames[i],]
                 dummyObj = parameter.factory(args, 'textPmtrObjs', self.refDict)
                 self.pmtrQDict[textLabel] = dummyObj.getArgs()
@@ -283,7 +283,7 @@
     def _updateDynPmtrDefaults(self):
         """must supply complete arguments to create dynamic parameter objects"""
         for i, dynLabel in basePmtr.dynLabel(self.dynPmtrNo, 1):
-            if not self.pmtrQDict.has_key(dynLabel):
+            if dynLabel not in self.pmtrQDict:
                 args = self.dynPmtrManifest[i]['default']
                 self.pmtrQDict[dynLabel] = args
     
@@ -339,7 +339,7 @@
         """
         #temperamentObj = temperament.Temperament() # generic
         name = temperament.temperamentNameParser(name) # for backward compat
-        if name == None: raise ValueError, 'bad temperament name error'
+        if name == None: raise ValueError('bad temperament name error')
         self.temperamentName = name
         self.temperamentObj = temperament.factory(self.temperamentName)
 
@@ -466,15 +466,15 @@
         auxNo, pmtrQDict = self._getInstInfo(inst, orcName, auxNo)
             
         # often defined with orc but not required
-        if not pmtrQDict.has_key('ampQ'): # if missing amp
+        if 'ampQ' not in pmtrQDict: # if missing amp
             pmtrQDict['ampQ'] = 'rb,.4,.4,.7,.9'
-        if not pmtrQDict.has_key('panQ'): # if missing
+        if 'panQ' not in pmtrQDict: # if missing
             pmtrQDict['panQ'] = ('constant', .5)
-        if not pmtrQDict.has_key('octQ'): # if missing
+        if 'octQ' not in pmtrQDict: # if missing
             pmtrQDict['octQ'] = ('constant', 0) # no shift
-        if not pmtrQDict.has_key('fieldQ'): # if missing
+        if 'fieldQ' not in pmtrQDict: # if missing
             pmtrQDict['fieldQ'] = ('constant', 0)
-        if not pmtrQDict.has_key('rhythmQ'): # if missing
+        if 'rhythmQ' not in pmtrQDict: # if missing
             pmtrQDict['rhythmQ'] = 'pt,(c,4),(bg,rp,(1,1,2,3)),(c,1),(c,.75)'
 
         pmtrQDict['inst']     = ('staticInst', inst, orcName) # default value
@@ -790,7 +790,7 @@
 
     def getPathPos(self):
         """gets a list of path positions, from 0 to len-1"""
-        return range(0, len(self.path))
+        return list(range(0, len(self.path)))
 
     def getPathLen(self):
         """gets a list of path positions"""
@@ -903,7 +903,7 @@
         # remove old aux values 
         for auxLabel in basePmtr.auxLabel(oldAuxNo):
             del self.pmtrQDict[auxLabel]
-            if auxLabel in self.pmtrObjDict.keys(): # remove objects if they exist
+            if auxLabel in list(self.pmtrObjDict.keys()): # remove objects if they exist
                 del self.pmtrObjDict[auxLabel]
 
         # insert new aux values, from preset dict
@@ -926,7 +926,7 @@
             try:
                 self.pmtrObjDict[pmtrName] = parameter.factory(args, 
                                                   'textPmtrObjs', self.refDict)
-            except error.ParameterObjectSyntaxError, msg: # initialization errors
+            except error.ParameterObjectSyntaxError as msg: # initialization errors
                 return 0, 'incorrect arguments: %s' % msg
         else:
             # get appropriate library
@@ -936,7 +936,7 @@
                 lib = 'genPmtrObjs'
             try:
                 self.pmtrObjDict[pmtrName] = parameter.factory(args, lib)
-            except error.ParameterObjectSyntaxError, msg: # initialization errors
+            except error.ParameterObjectSyntaxError as msg: # initialization errors
                 return 0, 'incorrect arguments: %s' % msg
         # check for errors
         if self.pmtrObjDict[pmtrName] == None: # failure to match object type
@@ -973,7 +973,7 @@
         elif pmtrName != '':
             ok, msg = self._evalPmtrObj(pmtrName)
         else: # reinit all paramters, no name given
-            for pmtrName in self.pmtrQDict.keys():
+            for pmtrName in list(self.pmtrQDict.keys()):
                 ok, msg = self._evalPmtrObj(pmtrName)
                 if ok != 1: break # stop processing on error
         # post update actions
@@ -987,7 +987,7 @@
         setattr(self, attrName, data)
         ok, msg = self.updatePmtrObj(pmtrName)
         # this should never fail
-        if not ok: raise ValueError, 'texture edit: original data cannot be restored: %s' % msg
+        if not ok: raise ValueError('texture edit: original data cannot be restored: %s' % msg)
 
     def editPmtrObj(self, pmtrName, pmtrValue, refresh=1):
         """Edits a Texture's Parameter object
@@ -1045,19 +1045,19 @@
                 if not ok:
                     self._editRestore(attrName, p, oldData)
                     return ok, 'score creation returned an error.'
-        except error.ParameterObjectSyntaxError, msg: # standard init errors from pmtr obj
+        except error.ParameterObjectSyntaxError as msg: # standard init errors from pmtr obj
             msg = '%s %s' % (editPhase, msg)
             ok = 0
-        except IndexError, msg:
+        except IndexError as msg:
             msg = '%s incorrect number of arguments. %s.' % (editPhase, msg)
             ok = 0
-        except TypeError, msg:
+        except TypeError as msg:
             msg = '%s incorrect data-type in arguments. %s' % (editPhase, msg)
             ok = 0 
-        except UnboundLocalError, msg:
+        except UnboundLocalError as msg:
             msg = '%s incorrect paramater type in arguments. %s' % (editPhase, msg)
             ok = 0
-        except ValueError, msg:
+        except ValueError as msg:
             msg = '%s value error: an inappropriate data type used.' % editPhase
             ok = 0
         except ZeroDivisionError:
@@ -1223,7 +1223,7 @@
         nameSort = []
         nameList = []
         highest = 0
-        for name in self.pmtrObjDict.keys():
+        for name in list(self.pmtrObjDict.keys()):
             pri = self.pmtrObjDict[name].priority
             if pri < 0: # turns off post event processing
                 continue
@@ -1272,8 +1272,8 @@
         self.esObj.append(eventDict)
 
     def _mergeEventDict(self, parent, child):
-        for key in parent.keys():
-            if not child.has_key(key): # if child does not have value, copy
+        for key in list(parent.keys()):
+            if key not in child: # if child does not have value, copy
                 child[key] = copy.deepcopy(parent[key])
         return child
 
@@ -1307,7 +1307,7 @@
     def _scorePre(self): # called w/n score method
         self.stateClear() # resets
         self.esObj.clear() # clear event sequence
-        for pmtrName in self.pmtrQDict.keys():
+        for pmtrName in list(self.pmtrQDict.keys()):
             if pmtrName[:5] != 'textQ': #dont update texture options
                 # reset all necessary variables before scoring
                 # do update dyn parameters
--- ./athenaCL/libATH/libTM/texture.py	(original)
+++ ./athenaCL/libATH/libTM/texture.py	(refactored)
@@ -55,7 +55,7 @@
     'if' : 'InterpolateFill', 
     }
 
-tmObjs = tmNames.values()
+tmObjs = list(tmNames.values())
 
 
 
@@ -82,7 +82,7 @@
             modFound = mod
             break
     if modFound == None:
-        raise ValueError, 'parameter type error: %s' % usrStr # failure
+        raise ValueError('parameter type error: %s' % usrStr) # failure
     return modFound, objType
 
 
@@ -99,9 +99,9 @@
     reload(baseTexture) # reload base classs
     mod, objType = locator(tmName) #check type string
     if objType == None:
-        raise ValueError, 'texture module type error' # failure
+        raise ValueError('texture module type error') # failure
     if objType not in tmObjs:
-        raise ValueError, 'texture module type error' # failure
+        raise ValueError('texture module type error') # failure
 
     tmObjAttr = getattr(mod, objType)
     tmObj = tmObjAttr(name)
@@ -129,7 +129,7 @@
         self.assertEqual(True, True)
 
     def testFactory(self):
-        for key, name in tmNames.items():
+        for key, name in list(tmNames.items()):
             post = factory(name)
 
 #-----------------------------------------------------------------||||||||||||--
--- ./athenaCL/libATH/omde/bpf.py	(original)
+++ ./athenaCL/libATH/omde/bpf.py	(refactored)
@@ -146,7 +146,7 @@
       time0 = None
       for time1, value1 in self.pairs:
             if time0 is not None and time1 < time0:
-                raise ValueError, 'pairs are not in temporal sequence'
+                raise ValueError('pairs are not in temporal sequence')
             time0 = time1
             
 
@@ -170,11 +170,11 @@
         (time, value)
         like PowerSegment((0, 1), (5, 3), (20, 1))
         """
-        if dict.has_key('exp'):
+        if 'exp' in dict:
             self.exponent = dict['exp']
         else: self.exponent = 1.0
         
-        if dict.has_key('periodic'):
+        if 'periodic' in dict:
             periodic = dict['periodic']
         else: periodic = 0
         
@@ -217,7 +217,7 @@
         (time, value)
         like LineSegment((0, 1), (5, 3), (20, 1))
         """
-        if dict.has_key('periodic'):
+        if 'periodic' in dict:
             periodic = dict['periodic']
         else: periodic = 0
         BPF.__init__(self, pairs, periodic)
@@ -235,7 +235,7 @@
     >>> a = HalfCosineSegment([(0, 1), (5, 3), (20, 1)])
     """
     def __init__(self, pairs, **dict):
-        if dict.has_key('periodic'):
+        if 'periodic' in dict:
             periodic = dict['periodic']
         else: periodic = 0
         BPF.__init__(self, pairs, periodic)
@@ -263,7 +263,7 @@
 
         >>> a = NoInterpolationSegment([(0, 1), (5, 3), (20, 1)])
         """
-        if dict.has_key('periodic'):
+        if 'periodic' in dict:
             periodic = dict['periodic']
         else: periodic = 0
         BPF.__init__(self, pairs, periodic)
--- ./athenaCL/libATH/omde/functional.py	(original)
+++ ./athenaCL/libATH/omde/functional.py	(refactored)
@@ -468,7 +468,7 @@
           t is the freeze time (default is 0.0).
           """
           if not isinstance(f, Function):
-                raise ValueError, "Function expected. got '%s'", type(f)
+                raise ValueError("Function expected. got '%s'").with_traceback(type(f))
           
           self.f = f
           self.t = make_generator(t)
@@ -502,9 +502,9 @@
           if begin is not None and end is not None:
                 return object.instance(begin, end)
           elif begin is not None and end is None:
-                raise ValueError, 'generator model not allowed without complete life span'
+                raise ValueError('generator model not allowed without complete life span')
           else:
-                raise ValueError, 'generator model without life span'
+                raise ValueError('generator model without life span')
      
      return ConstantFunction(object)
 
--- ./athenaCL/libATH/omde/miscellaneous.py	(original)
+++ ./athenaCL/libATH/omde/miscellaneous.py	(refactored)
@@ -35,6 +35,7 @@
 
 
 from athenaCL.libATH.omde import rand # used for omdeRand
+from functools import reduce
 omdeRand = rand
 from athenaCL.libATH.omde.functional import Function, Generator, make_function
 
@@ -126,7 +127,7 @@
                 self.add = self.noBounds
           else:
                 if upper is None or lower is None:
-                     raise ValueError, 'cannot create a bound accumulator with undefined bounds'
+                     raise ValueError('cannot create a bound accumulator with undefined bounds')
                 
                 self.upper = make_function(upper)
                 self.lower = make_function(lower)
@@ -137,7 +138,7 @@
                 elif mode in ['wrap', 'w']:
                      self.add = self.wrapAtBounds
                 else:
-                     raise ValueError, "mode can only be 'unbound', 'limit', 'reflect', 'mirror' or 'wrap' (got %s)" % mode
+                     raise ValueError("mode can only be 'unbound', 'limit', 'reflect', 'mirror' or 'wrap' (got %s)" % mode)
 
      def __call__(self, t):
           """
@@ -334,12 +335,12 @@
 
           mode = 'cycle'
 
-          for key in dict.keys():
+          for key in list(dict.keys()):
                 if key == 'mode': mode = dict['mode']
          
           list0 = list(list0)
           if len(list0) == 0:
-                raise ValueError, 'cannot create an empty List'
+                raise ValueError('cannot create an empty List')
           self.list = copy.deepcopy(list0)
 
           if mode in ['cycle', 'c']:
@@ -364,10 +365,10 @@
           elif mode in ['random', 'r']:
                 self.next = self.random_next
           else:
-                raise ValueError, self._value_error_message % mode
+                raise ValueError(self._value_error_message % mode)
 
      def __call__(self):
-          return self.next()
+          return next(self)
 
      def computePermutations(self, list):
           permutations = []
@@ -444,8 +445,8 @@
      def __init__(self, pair0, *pairs):
           Function.__init__(self)
           for pair in pairs:
-                if type(pair) is not types.TupleType:
-                     raise ValueError, 'pair (object, probability) expected. got %s', repr(pair)
+                if type(pair) is not tuple:
+                     raise ValueError('pair (object, probability) expected. got %s').with_traceback(repr(pair))
 
           self.set = []
           for o, p in [pair0] + list(pairs):
@@ -453,7 +454,7 @@
 
      def __call__(self, t):
           sum = reduce(lambda x,y: x+y, [possible_choice.probability(t) for possible_choice in self.set ])
-          self.set = map(_MarkAccumulatorEvaluate(t, sum), self.set)
+          self.set = list(map(_MarkAccumulatorEvaluate(t, sum), self.set))
 
           n = omdeRand.random()
           for possible_choice in self.set:
@@ -482,7 +483,7 @@
 
           sum = reduce(lambda x,y: x+y, 
                   [possible_choice.probability for possible_choice in self.set])
-          self.set = map(_MarkAccumulator(sum), self.set)
+          self.set = list(map(_MarkAccumulator(sum), self.set))
 
      def __call__(self, t):
           n = omdeRand.random()
--- ./athenaCL/libATH/omde/rand.py	(original)
+++ ./athenaCL/libATH/omde/rand.py	(refactored)
@@ -109,7 +109,7 @@
           self._seed = seed
           while self._seed == 0 or self._seed == self._mod:
                 time.sleep(.01)
-                self._seed = long((time.time() % 1) * self._mod)
+                self._seed = int((time.time() % 1) * self._mod)
 
 
 
@@ -146,7 +146,7 @@
           are two *independent* variables with normal distribution
           (mu = 0, sigma = 1).
           """
-          z = self.next
+          z = self.__next__
           self.next = None
           if z is None:
                      x2pi = random() * math.pi * 2
--- ./athenaCL/test/test.py	(original)
+++ ./athenaCL/test/test.py	(refactored)
@@ -80,7 +80,7 @@
             except Exception as excp: # this takes all exceptions!
                 msg = ['failed import:', fp, '\n', 
                     '\tEXCEPTION:', str(excp).strip()]
-                print(' '.join(msg))
+                print((' '.join(msg)))
                 continue
             modules.append(mod)
 
@@ -120,7 +120,7 @@
         unitTestCases = []
     
         if not hasattr(module, 'Test'):
-            print('%s has no Test class' % module)
+            print(('%s has no Test class' % module))
         else:
             if 'test' in testGroup:
                 unitTestCases.append(module.Test)
@@ -140,7 +140,7 @@
                 optionflags = (doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE))
             s1.addTests(s3)
         except ValueError:
-            print('%s cannot load Doctests' % module)
+            print(('%s cannot load Doctests' % module))
             continue
 
     print('running Tests...\n')
--- ./obsolete/MC.py	(original)
+++ ./obsolete/MC.py	(refactored)
@@ -150,7 +150,7 @@
             # must reverse these to get a dict to then reverse the mappings of
             sourceDict = vlMapDict[(dstSize, srcSize)]  
             newDict   = {}
-            for key in sourceDict.keys():
+            for key in list(sourceDict.keys()):
                 map = sourceDict[key]
                 newMap = self.flipMap(map)
                 newDict[key] = newMap
@@ -161,7 +161,7 @@
         map = self.getMapDict(srcSize, dstSize)
         if map == None: return None
         else:
-            return len(map.keys())
+            return len(list(map.keys()))
 
 
     def getSingleMap(self, srcSize, dstSize, mapIndexNo):
@@ -233,7 +233,7 @@
                                  'd' : '3',
                                  'e' : '4',
                                  'f' : '5' }
-        for letter in translationDict.keys():
+        for letter in list(translationDict.keys()):
             stringMap = stringMap.replace(letter, translationDict[letter])
         try:
             newMap = eval(stringMap)
@@ -242,7 +242,7 @@
         srcSize, dstSize = self._getMapSrcDstSize(newMap)
         mapDict = self.getMapDict(srcSize, dstSize)
         if mapDict == None: return None
-        for key in mapDict.keys():
+        for key in list(mapDict.keys()):
             if mapDict[key] == newMap:
                 goodMap = 1
                 goodKey = key
@@ -313,7 +313,7 @@
 
             srcPosCount = srcPosCount + 1
         
-        keyList = rowDict.keys()
+        keyList = list(rowDict.keys())
         keyList.sort()
         for key in keyList:
             if len(rowDict[key]) == 0:
@@ -331,7 +331,7 @@
              with pcsX and its next movement as strings
         """
         rowDict = self.genSingleVlDiagram(pcsX, map)
-        rowKeys = rowDict.keys()
+        rowKeys = list(rowDict.keys())
         
         for i in range(0,len(pcsY)):
             if len(rowDict[i]) == 0:
@@ -353,7 +353,7 @@
         dstSize = len(pcsY)
         mapDict = self.getMapDict(srcSize, dstSize)
 
-        for key in mapDict.keys():
+        for key in list(mapDict.keys()):
             map = mapDict[key]
             vlPairs = self.genVlPairs(pcsX, pcsY, map)
             vlDict[key] = vlPairs
@@ -442,7 +442,7 @@
         rawVlPairs = tuple(rawVlPairs)
         vlPairDict = self.getAllVl(pcsX, pcsY)
         foundMapKey = 0
-        for key in vlPairDict.keys():
+        for key in list(vlPairDict.keys()):
             if vlPairDict[key] == rawVlPairs:
                 foundMapKey = key
                 break
@@ -464,7 +464,7 @@
                         tempRawVlPairs[counter]     = b
                         tempRawVlPairs[counter+1]   = a
                         tempRawVlPairs = tuple(tempRawVlPairs)
-                        for key in vlPairDict.keys():
+                        for key in list(vlPairDict.keys()):
                             if vlPairDict[key] == tempRawVlPairs:
                                 foundMapKey = key
                                 break
@@ -497,7 +497,7 @@
                         tempRawVlPairs[counter]     = b
                         tempRawVlPairs[counter+1]   = a
                         tempRawVlPairs = tuple(tempRawVlPairs)
-                        for key in vlPairDict.keys():
+                        for key in list(vlPairDict.keys()):
                             if vlPairDict[key] == tempRawVlPairs:
                                 foundMapKey = key
                                 break
@@ -927,7 +927,7 @@
                 dstSet = tuple(range(mapIdTuple[1]))
 
             rowDict = self.genDoubleVlDiagram(srcSet, dstSet, mapGotten)
-            printKeyList = rowDict.keys()
+            printKeyList = list(rowDict.keys())
             printKeyList.sort()
             for key in printKeyList:
                 tempRow = rowDict[key].strip()
@@ -968,7 +968,7 @@
                 ### createa  display
                 rowDict = self.genDoubleVlDiagram(sourceSet, destinationSet, 
                              self.fetchMap(mapIdTuple))
-                printKeyList = rowDict.keys()
+                printKeyList = list(rowDict.keys())
                 printKeyList.sort()
                 for key in printKeyList:
                     tempRow = rowDict[key].strip()
@@ -1021,7 +1021,7 @@
         if len(pcsX) > 6 or len(pcsX) < 1 or len(pcsY) > 6 or len(pcsY) < 1:
             return None # error, bad size
         mapDict = self.getMapDict(len(pcsX), len(pcsY))
-        keyList = mapDict.keys()
+        keyList = list(mapDict.keys())
         keyList.sort()
         dictS = {}
         for key in keyList:
@@ -1152,7 +1152,7 @@
                 line = line + repr(entry).replace(' ', '') + ':'
             mapString = self.rawMapToString(map)
             msg = msg + '%sMC %i, map %s\n' % (line.ljust(55), key, mapString)
-        print msg
+        print(msg)
 
 
 
@@ -1182,7 +1182,7 @@
                 orderedIcPeaksU.append(i)
             dummy_vector[i] = -1     # knock out so that will not get chosen again
         ### use to finde span
-        double_range = range(0,12) + range(0,12)
+        double_range = list(range(0,12)) + list(range(0,12))
         start     = 0 
         count     = 0
         max   = 0
@@ -1259,7 +1259,7 @@
         if len(pcsX) > 6 or len(pcsX) < 1 or len(pcsY) > 6 or len(pcsY) < 1:
             return None
         mapDict = self.getMapDict(len(pcsX), len(pcsY))
-        keyList = mapDict.keys()
+        keyList = list(mapDict.keys())
         keyList.sort()
         dictU = {}
         for key in keyList:
@@ -1434,7 +1434,7 @@
                 line = line + repr(entry).replace(' ', '') + ':'
             mapString = self.rawMapToString(map)
             msg = msg + '%sMC %i, map %s\n' % (line.ljust(55), key, mapString)
-        print msg
+        print(msg)
 
     #-----------------------------------------------------------------------||--
     def BAL(self, pcsX, pcsY, map):
@@ -1461,7 +1461,7 @@
                 orderedIcPeaksB.append(i)
             dummy_vector[i] = -1     # knock out so that will not get chosen again
 
-        double_range = range(0,12) + range(0,12)
+        double_range = list(range(0,12)) + list(range(0,12))
         start     = 0 
         count     = 0
         max   = 0
@@ -1536,7 +1536,7 @@
         if len(pcsX) > 6 or len(pcsX) < 1 or len(pcsY) > 6 or len(pcsY) < 1:
             return None
         mapDict = self.getMapDict(len(pcsX), len(pcsY))
-        keyList = mapDict.keys()
+        keyList = list(mapDict.keys())
         keyList.sort()
         dictB = {}
         for key in keyList:
@@ -1715,6 +1715,6 @@
                 line = line + repr(entry).replace(' ', '') + ':'
             mapString = self.rawMapToString(map)
             msg = msg + '%sMC %i, map %s\n' % (line.ljust(55), key, mapString)
-        print msg
-
-
+        print(msg)
+
+
--- ./obsolete/fileTools.py	(original)
+++ ./obsolete/fileTools.py	(refactored)
@@ -87,8 +87,8 @@
           # note that this does not work for some raw audio files 
           try:
                 audioData = sndhdr.what(self.absPath)
-          except RuntimeError, e:
-                print _MOD, 'bad audio file: %s' % absPath
+          except RuntimeError as e:
+                print(_MOD, 'bad audio file: %s' % absPath)
                 audioData = None
 
           if audioData == None:
@@ -276,11 +276,11 @@
      def reportCount(self):
           sum, white, comments, defs, classes = self.countLines()
           for entry in self.dirList:
-                print entry
-          print '\n%s lines of code found for %s .py files' % (sum,
-                                                                        len(self.fileList))
-          print '(%s white, %s comments)' % (white, comments) 
-          print '%s class, %s def statements\n' % (classes, defs)
+                print(entry)
+          print('\n%s lines of code found for %s .py files' % (sum,
+                                                                        len(self.fileList)))
+          print('(%s white, %s comments)' % (white, comments)) 
+          print('%s class, %s def statements\n' % (classes, defs))
 
 #-----------------------------------------------------------------||||||||||||--
 class GatherCvs(DirWalk):
@@ -422,11 +422,11 @@
      
           for path in pathList:
                 if os.path.isdir(path):
-                     print "not a file (dir): %s" % path
+                     print("not a file (dir): %s" % path)
                      continue
                 data = open(path, "rb").read()
                 if '\0' in data:
-                     print "not a file (binary): %s" % path
+                     print("not a file (binary): %s" % path)
                      continue
 
                 newdata = re.sub("\r?\n", newLF, data)
@@ -441,14 +441,14 @@
                                                       ['txt', 'py', 'xml'])
           filteredFileList = selPaths
           if len(filteredFileList) == 0:
-                print 'empty directory: %s' % self.searchDir
+                print('empty directory: %s' % self.searchDir)
           else:
                 fileNumber = '%i' % len(filteredFileList)
                 msg = ('convert to %s: %s files in %s' % 
                                                   (self.dstFormat.upper(), 
                                                   fileNumber.rjust(4), 
                                                   self.searchDir))
-                print msg
+                print(msg)
                 self.convert(filteredFileList, self.dstFormat)
 
 
@@ -473,24 +473,24 @@
                      or file[-3:] == 'CH3' or file[-3:] == 'CH4'):
                      newKey = file[:-3] # name, with out period ?
                      newRef = file[-3:] # ext
-                     if self.group.has_key(newKey):
+                     if newKey in self.group:
                           self.group[newKey].append(newRef)
                      else:
                           self.group[newKey] = []
                           self.group[newKey].append(newRef)
 
      def rename(self):
-          for fileGroup in self.group.keys():
-                print 'renaming %s' % fileGroup
+          for fileGroup in list(self.group.keys()):
+                print('renaming %s' % fileGroup)
                 for ext in self.group[fileGroup]:
                      oldName = fileGroup + ext
                      newName = fileGroup + '.' + self.conversion[ext] # . needed
                      oldPath = os.path.join(self.searchDir, oldName)
                      newPath = os.path.join(self.searchDir, newName)
                      cmdStr = 'mv %s %s' % (oldPath, newPath)
-                     print cmdStr
+                     print(cmdStr)
                      os.system(cmdStr)
-          print ''          
+          print('')          
 
 class RenameStereo:
      """strip L,R extensions from files"""
@@ -512,15 +512,15 @@
                 if file[-2:] == '.L' or file[-2:] == '.R':
                      newKey = file[:-2] # name, with out period
                      newRef = file[-2:] # extension
-                     if self.group.has_key(newKey):
+                     if newKey in self.group:
                           self.group[newKey].append(newRef)
                      else:
                           self.group[newKey] = []
                           self.group[newKey].append(newRef)
 
      def rename(self):
-          for fileGroup in self.group.keys():
-                print 'renaming %s' % fileGroup
+          for fileGroup in list(self.group.keys()):
+                print('renaming %s' % fileGroup)
                 for ext in self.group[fileGroup]:
                      oldName = fileGroup + ext
                      if len(self.group[fileGroup]) == 1: # if only one file here
@@ -532,7 +532,7 @@
                      cmdStr = 'mv %s %s' % (oldPath, newPath)
                      #print cmdStr
                      os.system(cmdStr)
-          print ''          
+          print('')          
 
 #-----------------------------------------------------------------||||||||||||--
 
@@ -558,18 +558,18 @@
                      if name[-len(ext):] == ext: # if has this ext
                           nameStub = name[:-len(ext)]
                           break
-                if nameStub not in bundleDict.keys():
+                if nameStub not in list(bundleDict.keys()):
                      bundleDict[nameStub] = []
                 bundleDict[nameStub].append(path)
 
-          for groupName in bundleDict.keys():
+          for groupName in list(bundleDict.keys()):
                 if len(bundleDict[groupName]) > 1: # dont bundle single items
                      groupDir = os.path.join(self.searchDir, groupName)
                      if os.path.isdir(groupDir) != 1: # if doesnt exists
-                          print groupDir # if doesnt exist
+                          print(groupDir) # if doesnt exist
                           os.mkdir(groupDir)
                      else:
-                          print "dir in the way: %s" % groupDir 
+                          print("dir in the way: %s" % groupDir) 
 
                      for path in bundleDict[groupName]:
                           dir, name = os.path.split(path)
@@ -579,7 +579,7 @@
                                 #print cmdStr
                                 os.system(cmdStr)
                           else:
-                                print "file in the way: %s" % newDst 
+                                print("file in the way: %s" % newDst) 
 
 
 class BundleAudio:
@@ -604,7 +604,7 @@
                      cmdStr = 'mv %s %s' % (path, newDst)
                      os.system(cmdStr)
                 else:
-                     print "file in the way: %s" % newDst 
+                     print("file in the way: %s" % newDst) 
 
 
 
@@ -620,8 +620,8 @@
      "parent class for proof sheets"
      def __init__(self, dirPath):
           if not os.path.isdir(dirPath):
-                print 'got bad dir path', dirPath
-                raise error.ArgumentError, 'bad file path supplied'
+                print('got bad dir path', dirPath)
+                raise error.ArgumentError('bad file path supplied')
           dirPath = drawer.pathScrub(dirPath)
 
           self.dirPath = dirPath
@@ -632,7 +632,7 @@
           self.proofDirPath = os.path.join(self.dirPath, self.proofDirName)
           if os.path.exists(self.proofDirPath) != 1:
                 os.mkdir(self.proofDirPath)
-                print 'writing: %s' % self.proofDirPath
+                print('writing: %s' % self.proofDirPath)
           else: pass
           # create index path
           self.indexPath = os.path.join(self.proofDirPath, 'index.html')
@@ -772,12 +772,12 @@
           except:
                 return None
           msg = []
-          sortKeys = exifData.keys()
+          sortKeys = list(exifData.keys())
           sortKeys.sort()
           for key in sortKeys:
                 #if not drawer.isStr(exifData[key]):
                 #     print '%s: %s' % (key, exifData[key].printable)
-                if key in viewKeys.keys():
+                if key in list(viewKeys.keys()):
                      msg.append('%s-%s' % (viewKeys[key], exifData[key]))
           f.close()
           if msg == []:
@@ -1051,7 +1051,7 @@
 
      def process(self):
           # get all file paths (after removing old images dir!)
-          from urllib import urlopen
+          from urllib.request import urlopen
 
           doc = urlopen(self.url).read()
 
@@ -1079,7 +1079,7 @@
           count = 0
 
           if self.filteredLinks == []:
-                print 'no matches'
+                print('no matches')
                 return None
                 
           for descr, url in self.filteredLinks:
@@ -1165,13 +1165,13 @@
           """count relative subdirs, excluding parent dir
           first method called to gather all file data"""
           self.dirListA = []
-          for file in self.fileDictA.keys():
+          for file in list(self.fileDictA.keys()):
                 relDir = self.fileDictA[file].relDir
                 if relDir != None:
                      if relDir not in self.dirListA:
                           self.dirListA.append(relDir)
           self.dirListB = []
-          for file in self.fileDictB.keys():
+          for file in list(self.fileDictB.keys()):
                 relDir = self.fileDictB[file].relDir
                 if relDir != None:
                      if relDir not in self.dirListB:
@@ -1180,38 +1180,38 @@
 
      def _mergeFiles(self):
           "combine files from a, b into a composite"
-          for file in self.fileDictA.keys():
-                if file not in self.mergedFileDict.keys():
+          for file in list(self.fileDictA.keys()):
+                if file not in list(self.mergedFileDict.keys()):
                      self.mergedFileDict[file] = {} #each entry a dictionary
-                if not self.mergedFileDict[file].has_key('found'):
+                if 'found' not in self.mergedFileDict[file]:
                      self.mergedFileDict[file]['found'] = []
                 self.mergedFileDict[file]['found'].append('a')
-          for file in self.fileDictB.keys():
-                if file not in self.mergedFileDict.keys():
+          for file in list(self.fileDictB.keys()):
+                if file not in list(self.mergedFileDict.keys()):
                      self.mergedFileDict[file] = {} #each entry a dictionary
-                if not self.mergedFileDict[file].has_key('found'):
+                if 'found' not in self.mergedFileDict[file]:
                      self.mergedFileDict[file]['found'] = []
                 self.mergedFileDict[file]['found'].append('b')
           #print self.mergedFileDict
 
      def _mergeDirs(self):
           "combine dirs from a, b into a composite"
-          for file in self.fileDictA.keys():
+          for file in list(self.fileDictA.keys()):
                 relDir = self.fileDictA[file].relDir
                 if relDir != None: # not toplevel dir
-                     if relDir not in self.mergedDirDict.keys():
+                     if relDir not in list(self.mergedDirDict.keys()):
                           self.mergedDirDict[relDir] = {}
-                     if not self.mergedDirDict[relDir].has_key('found'):
+                     if 'found' not in self.mergedDirDict[relDir]:
                           self.mergedDirDict[relDir]['found'] = []
                      # only need one mark for many files in this dir
                      if 'a' not in self.mergedDirDict[relDir]['found']:
                           self.mergedDirDict[relDir]['found'].append('a')
-          for file in self.fileDictB.keys():
+          for file in list(self.fileDictB.keys()):
                 relDir = self.fileDictB[file].relDir
                 if relDir != None: # not toplevel dir
-                     if relDir not in self.mergedDirDict.keys():
+                     if relDir not in list(self.mergedDirDict.keys()):
                           self.mergedDirDict[relDir] = {}
-                     if not self.mergedDirDict[relDir].has_key('found'):
+                     if 'found' not in self.mergedDirDict[relDir]:
                           self.mergedDirDict[relDir]['found'] = []
                      # only need one mark for many files in this dir
                      if 'b' not in self.mergedDirDict[relDir]['found']:
@@ -1221,7 +1221,7 @@
           "find each file in merged that does not have a copy in a, then b"
           self.fileMissListA = []
           self.fileMissListB = []
-          for file in self.mergedFileDict.keys():
+          for file in list(self.mergedFileDict.keys()):
                 if len(self.mergedFileDict[file]['found']) == 2:
                      pass # has both
                 else:
@@ -1234,7 +1234,7 @@
           "find each dir in merged that does not have a copy in a, then b"
           self.dirMissListA = []
           self.dirMissListB = []
-          for dir in self.mergedDirDict.keys():
+          for dir in list(self.mergedDirDict.keys()):
                 if len(self.mergedDirDict[dir]['found']) == 2:
                      pass # has both
                 else:
@@ -1290,9 +1290,9 @@
           # must be handled carefully
           if reasonInt > 0 and mostrecent == None:
                 mostrecent = 'ERROR'
-                print 'ambiguity with %s' % fileObjA.relPath
-                print 'mTimeA %s mTimeB %s' % (fileObjA.mTime, fileObjB.mTime)
-                print 'cTimeA %s cTimeB %s' % (fileObjA.cTime, fileObjB.cTime)
+                print('ambiguity with %s' % fileObjA.relPath)
+                print('mTimeA %s mTimeB %s' % (fileObjA.mTime, fileObjB.mTime))
+                print('cTimeA %s cTimeB %s' % (fileObjA.cTime, fileObjB.cTime))
 
           return reasonInt, reasonList, mostrecent
 
@@ -1301,7 +1301,7 @@
           self.fileOutdateListA = [] # files outdated on a
           self.fileOutdateListB = [] # files outdated on b
 
-          for file in self.mergedFileDict.keys():
+          for file in list(self.mergedFileDict.keys()):
                 if len(self.mergedFileDict[file]['found']) == 2: # has both
                      fileObjA = self.fileDictA[file]
                      fileObjB = self.fileDictB[file]
@@ -1323,7 +1323,7 @@
                      
      def _displayFileDiff(self):
           fileDiffList = [] # temporary
-          for file in self.mergedFileDict.keys():
+          for file in list(self.mergedFileDict.keys()):
                 if self.mergedFileDict[file]['diff'][0] > 0: # a 
                      relPathA = self.fileDictA[file].relPath
                      relPathB = self.fileDictB[file].relPath
@@ -1413,58 +1413,58 @@
           if len(list) == 0: pass
           for entry in list:
                 if drawer.isStr(entry):
-                     print '\t%s' % entry
+                     print('\t%s' % entry)
                 else:
-                     print '\t%s\n\t%s --> \n\t%s' % (entry[0], entry[1], entry[2])
+                     print('\t%s\n\t%s --> \n\t%s' % (entry[0], entry[1], entry[2]))
 
      def report(self):
           self.analyze()
 
           # display all files that must be movied
-          print 'A: %s' % self.srcA
-          print 'B: %s' % self.srcB
-
-          print 'AB: (diff)'
+          print('A: %s' % self.srcA)
+          print('B: %s' % self.srcB)
+
+          print('AB: (diff)')
           self._printList(self._displayFileDiff())
 
-          print 'A: (mkdir)'
+          print('A: (mkdir)')
           self._printList(self.mkdirA)
-          print 'B to A: (cp)'
+          print('B to A: (cp)')
           self._printList(self.cpBA)
 
-          print 'B: (mkdir)'
+          print('B: (mkdir)')
           self._printList(self.mkdirB)
-          print 'A to B: (cp)'
+          print('A to B: (cp)')
           self._printList(self.cpAB)
 
           # display statistics of numbers
-          print 'A: %s' % self.srcA
-          print 'B: %s' % self.srcB
-          print '\t\t\tA\tB\tAB'
-          print 'total dirs\t\t%s\t%s\t%s' % (len(self.dirListA), 
+          print('A: %s' % self.srcA)
+          print('B: %s' % self.srcB)
+          print('\t\t\tA\tB\tAB')
+          print('total dirs\t\t%s\t%s\t%s' % (len(self.dirListA), 
                                                                   len(self.dirListB),
-                                                                  len(self.mergedDirDict.keys()))
-          print 'total files\t\t%s\t%s\t%s' % (len(self.fileDictA.keys()), 
-                                                                     len(self.fileDictB.keys()),
-                                                                     len(self.mergedFileDict.keys()))
-          print 'missing dirs\t\t%s\t%s'     % (len(self.dirMissListA), 
-                                                                        len(self.dirMissListB))
-          print 'missing files\t\t%s\t%s' % (len(self.fileMissListA), 
-                                                                        len(self.fileMissListB))
-          print 'outdated files\t\t%s\t%s' % (len(self.fileOutdateListA), 
-                                                                                len(self.fileOutdateListB))
+                                                                  len(list(self.mergedDirDict.keys()))))
+          print('total files\t\t%s\t%s\t%s' % (len(list(self.fileDictA.keys())), 
+                                                                     len(list(self.fileDictB.keys())),
+                                                                     len(list(self.mergedFileDict.keys()))))
+          print('missing dirs\t\t%s\t%s'     % (len(self.dirMissListA), 
+                                                                        len(self.dirMissListB)))
+          print('missing files\t\t%s\t%s' % (len(self.fileMissListA), 
+                                                                        len(self.fileMissListB)))
+          print('outdated files\t\t%s\t%s' % (len(self.fileOutdateListA), 
+                                                                                len(self.fileOutdateListB)))
 
      def update(self):
           # self.report() # call separately
           if len(self.cpBA) > 0 or len(self.cpAB) > 0:
                 ok = dialog.askYesNo('\nare you sure you want to update these files?')
                 if ok != 1:
-                     print 'no changes made'
+                     print('no changes made')
                 else:
                      self._processDir() # create dirs first
                      self._processFile()
           else:
-                print 'files and directories are up to date!'
+                print('files and directories are up to date!')
 
 
 
@@ -1512,7 +1512,7 @@
           for counter in range(numberOfTimes):
                 calibrator += p.calibrate(10000)
           calibrator /= numberOfTimes
-          print calibrator
+          print(calibrator)
           return calibrator
      
      def runProfile(self, methodStr=None, statFile=None, recalibrate=1,\
@@ -1573,12 +1573,12 @@
      #-----------------------------------------------------------------------||--
      def _randStr(self):
           txt = '' # to add to files
-          for char in range(0, random.choice(range(10, 500))):
+          for char in range(0, random.choice(list(range(10, 500)))):
                 txt = txt + random.choice(['a', 'b', 'c', 'd', 'e', 'f'])
           return txt
 
      def _randMutate(self, path):
-          if random.choice(range(0,99)) % 2 == 0: # if even
+          if random.choice(list(range(0,99))) % 2 == 0: # if even
                 if drawer.isDarwin():
                      if random.choice([0,1]) == 1:
                           osTools.rsrcSetCreator(path, 'R*ch')
--- ./obsolete/imageNetwork.py	(original)
+++ ./obsolete/imageNetwork.py	(refactored)
@@ -168,7 +168,7 @@
             self.totalSets = len(rowAxisSets) + len(columnAxisSets)
             self.masterSetList = rowAxisSets + columnAxisSets
 
-        if (srcSize, dstSize) in self.fixedPosChart.keys():
+        if (srcSize, dstSize) in list(self.fixedPosChart.keys()):
             self.mapPostitionType = 'fixed'
         else:
             self.mapPostitionType = 'perimeter'
@@ -184,7 +184,7 @@
                     sideUnits = side
                     break
 
-        self.areaKeys = range(0,area) # list to get a point for all area
+        self.areaKeys = list(range(0,area)) # list to get a point for all area
         self.noGutters        = sideUnits + 1
         self.mapGUTTER        = 3 # in pixels
         self.nodeWidth        = 46
@@ -207,7 +207,7 @@
             if xCord == sideUnits:
                 xCord = 0
                 yCord = yCord + 1
-        cordKeys = self.cordDict.keys()
+        cordKeys = list(self.cordDict.keys())
         cordKeys.sort()
 
         # this calculate the height of the entire window
@@ -263,14 +263,14 @@
         if self.mapPostitionType == 'fixed':
             setLoc = self.fixedPosChart[(srcSize, dstSize)]['setLoc']
             # assign sets to coords
-            for node in setLoc.keys():
+            for node in list(setLoc.keys()):
                 position = setLoc[node]
                 self.cordDict[position]['set'] = node
           #  counter = counter + 1
 
         elif self.mapPostitionType == 'perimeter': # use parimiter method
             # get perimeter points
-            locations =  self.cordDict.keys()
+            locations =  list(self.cordDict.keys())
             tempLocs = []
             for node in locations:
                 if node[0] == 0 or node[1] == 0:
@@ -348,7 +348,7 @@
                 minDispl, maxDispl, orderedResults, counter = a
                 if minDispl == 1: # find sets in grid
                     lineCords = [] # clear before finding two points
-                    for node in self.cordDict.keys():
+                    for node in list(self.cordDict.keys()):
                         if self.cordDict[node]['set'] == colEntry:
                             lineCords.append(node)
                         if self.cordDict[node]['set'] == rowEntry:
--- ./obsolete/setMeasure.py	(original)
+++ ./obsolete/setMeasure.py	(refactored)
@@ -81,7 +81,7 @@
 
         scToCompare = self.scObj.getAllScTriples(cardRange, tniTog)
         if len(scToCompare) == 0:   # in_case something goes wrong
-            print _MOD, 'bad cardRange', cardRange,
+            print(_MOD, 'bad cardRange', cardRange, end=' ')
             return None
 
         analysisValues = []     # enter as pairs: (chord, value)          
@@ -92,7 +92,7 @@
             else:
                 value = self.compareSet(SCx, scTriple)
             if value == None:
-                print _MOD, 'failed set comparison:', SCx, scTriple
+                print(_MOD, 'failed set comparison:', SCx, scTriple)
                 continue
 
             analysisValues.append((scTriple, value))
--- ./obsolete/xmlMusicTools.py	(original)
+++ ./obsolete/xmlMusicTools.py	(refactored)
@@ -445,7 +445,7 @@
         a.setMeasures(measureList)
 
         fp = drawer.tempFile('.xml')
-        print fp
+        print(fp)
         a.write(fp)
         
         osTools.openMedia(fp)
